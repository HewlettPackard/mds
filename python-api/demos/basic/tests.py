"""
Managed Data Structures
Copyright Â© 2017 Hewlett Packard Enterprise Development Company LP.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

As an exception, the copyright holders of this Library grant you permission
to (i) compile an Application with the Library, and (ii) distribute the 
Application containing code generated by the Library and added to the 
Application during this compilation process under terms of your choice, 
provided you also meet the terms and conditions of the Application license.
"""

from datetime import timedelta

from store import init_store, make_basket, Basket
from util import Pause

from mds.managed import String, Namespace
from mds.threading import ChildThread

global_ns = Namespace.get_global()


def print_final(store):
    for i, product in enumerate(store.ranked_products()):
        print("{} {}".format(i, product))


def test1():
    """
    Test 1: Initialize the store, make a purchase, update the ranks,
    and print the ranked products.
    """
    store, popularity = init_store()
    basket = make_basket(5, store, popularity)
    store.purchase(basket)
    store.update_ranks()
    print_final(store)


def test2():
    """
    Test 2: Like test 1, two conflicting purchases in separate threads.
    The first has five items, and the second has the same number of the
    first item in the first thread's basket, with the second purchase
    allowed to succeed first.  Resolution on the first purchase should
    succeed after reprocessing the single conflicted BasketItem and the
    task adding the basket to recent purchases (conflicted because the
    other thread grabbed the index first).
    """
    store, popularity = init_store()
    basket_a = make_basket(5, store, popularity)
    singleton = basket_a.items[0]
    basket_b = Basket(singleton)
    button = Pause.Button()

    t1 = ChildThread(
        target=lambda s=store, a=basket_a, b=button: s.purchase(a, b)
    )

    def worker_t2(store, basket_b, button):
        Pause.time(timedelta(seconds=3))
        store.purchase(basket_b)
        button.press()

    t2 = ChildThread(target=worker_t2, args=(store, basket_b, button))
    t1.join()
    t2.join()
    store.update_ranks()
    print_final(store)


def test3():
    """
    Test 3 is identical to test 2, but the second purchase happens in
    the main thread.
    """
    store, popularity = init_store()
    basket_a = make_basket(5, store, popularity)
    singleton = basket_a.items[0]
    basket_b = Basket(singleton)
    button = Pause.Button()

    t1 = ChildThread(
        target=lambda s=store, a=basket_a, b=button: s.purchase(a, b)
    )

    Pause.time(timedelta(seconds=3))
    store.purchase(basket_b)
    button.press()
    t1.join()
    store.update_ranks()
    print_final(store)


def test4():
    """
    Test 4: Update ranks in a thread, but pause before finishing.
    Meanwhile, do a purchase and allow the update to finish.  It needs
    to redo the task for the recent slot filled by the purchase and
    setting the ranks.
    """
    store, popularity = init_store()
    basket = make_basket(5, store, popularity)
    button = Pause.Button()

    t1 = ChildThread(
        target=lambda s=store, b=button: s.update_ranks(b)
    )

    Pause.time(timedelta(seconds=3))
    store.purchase(basket)
    button.press()
    t1.join()
    print_final(store)


def test5():
    """
    Test 5: The paused thread does a restock of 5 of every product
    """
    store, popularity = init_store()
    basket = make_basket(5, store, popularity)
    button = Pause.Button()

    def worker_t1(store):
        store.restock(lambda p: 5)

    t1 = ChildThread(target=worker_t1, args=(store,))
    Pause.time(timedelta(seconds=3))
    store.purchase(basket)
    button.press()
    store.update_ranks()
    t1.join()
    print_final(store)


def test6():
    """
    Test 6: Testing detached contexts and namespaces.
    """
    p = "path"
    key = "key"
    outer_val = String("Outer")
    inner_val = String("Inner")

    def trace(which, ns, key):
        s = String(ns[key])
        print("{} = {}".format(which, s))

    gns = global_ns[p]
    gns[key] = outer_val
    trace("GNS", gns, key)

    # TODO: Is this feasible? iso_ctxt c = iso_ctxt::nested_detached_from_current();
    def worker(p, gns, key, inner_val):
        print("--- In detached context")
        local = global_ns[p]
        trace("GNS", gns, key)
        trace("LNS", local, key)
        print("--- Binding")
        gns[key] = inner_val
        trace("GNS", gns, key)
        trace("LNS", local, key)
        print("--- Returning from detached context")
        return local

    lns = isolated(
        target=worker,
        view="nested_detached",
        args=(p, gns, key, inner_val)
    )

    trace("GNS", gns, key)
    trace("LNS", lns, key)


ALL_TESTS = [test1, test2, test3, test4, test5, test6]
