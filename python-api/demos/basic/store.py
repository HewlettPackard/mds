"""
Managed Data Structures
Copyright Â© 2017 Hewlett Packard Enterprise Development Company LP.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

As an exception, the copyright holders of this Library grant you permission
to (i) compile an Application with the Library, and (ii) distribute the 
Application containing code generated by the Library and added to the 
Application during this compilation process under terms of your choice, 
provided you also meet the terms and conditions of the Application license.
"""

import csv

from collections import defaultdict
from datetime import timedelta
from functools import reduce
from typing import Callable, Text, Union, Dict

import mds
from mds.managed import Record, declare_field, RecordArray
from mds.containers import IsolationContext, Task, PublicationResult, as_task, isolated

from util import Pause

RECORD_NAME = "PythonTest::{}".format
PROD_FILE = "products.csv"  # TODO: Should import this from the argparse stuff in driver

# TODO: Every isolated() call here is broken
# TODO: Every tasks.map is broken too

class Trace(PublicationResult):

    class State(object):
        RESET, RUNNING, RESOLVING, SUCCEEDED, FAILED = range(5)

    def __init__(self, prefix: Text):
        self._prefix = prefix if len(prefix) == 0 else prefix + ": "
        self._state = Trace.State.RESET
        self._n_runs = 0
        self._n_resolves = 0

    def reset(self) -> None:
        super().reset()  # TODO: Is this implemented? Where?
        self._state = Trace.State.RESET
        self._n_runs = 0

    def before_run(self, context: IsolationContext) -> None:
        ss = "snapshot " if context.is_snapshot else ""
        self._n_runs += 1

        if self._n_runs - 1 == 0:
            print("{}Isolated in {}context {} (TL task: {})".format(
                self._prefix, context, context.top_level_task
            ))
        else:
            if self._state == Trace.State.RESOLVING:
                print(f"{self._prefix}Resolution failed after attempt {self._n_resolves}")
            else:
                print(f"{self._prefix}Publish failed")

            print(f"{self._prefix}Rerun {self._n_runs} in {ss}context {context}")

        self._state = Trace.State.RUNNING

    def before_resolve(self, pub_result: PublicationResult) -> None:
        self._n_resolves += 1

        print(f"{self._prefix}Publish failed")
        print("{}Resolving, attempt {}, tasks = {}".format(
            self._prefix, self._n_resolves,
            " ".join(pub_result.redo_tasks_by_start_time())
        ))

        self._state = Trace.State.RESOLVING

    def note_success(self) -> None:
        print(f"{self._prefix}Publish succeeded")
        self._state = Trace.State.SUCCEEDED
        super().note_success()

    def note_failure(self) -> None:
        print(f"{self._prefix}Publish failed")
        self._state = Trace.State.FAILED
        super().note_failure()


class Department(Record, ident=RECORD_NAME('Department')):

    def __init__(self, number: int, name: Text):
        self.name.set(name)
        self.number.set(name)

    @staticmethod
    def schema():
        return {
            'name': declare_field(mds.typing.primitives.String)
            'number': declare_field(mds.typing.primitives.unsigned)
            'sales_rank': declare_field(mds.typing.primitives.unsigned)
        }

class Product(Record, ident=RECORD_NAME('Product')):

    def __init__(self, number: int, name: Text, dept: Department):
        self.name.set(name)
        self.number.set(number)
        self.dept.set(dept)

    @staticmethod
    def schema():
        return {
            'name': declare_field(mds.typing.composites.String)
            'number': declare_field(mds.typing.primitives.unsigned)
            'dept': declare_field(mds.typing.composities.Record)
            'nbr_sold': declare_field(mds.typing.primitives.unsigned)
            'sales_rank': declare_field(mds.typing.primitives.unsigned)
        }

    def __str__(self):
        return "[{}] {} ({}) [sold {}, inStock {}]".format(
            self.number,
            self.name,
            self.dept.name,
            self.nbr_sold,
            self.number_in_stock
        )

    def remove_stock(self, n: int) -> int:
        pass

    def add_stock(self, n: int, product_button: Pause.Button=None) -> None:
        pass

    @property
    def number_in_stock(self) -> int:
        pass

    def is_perishable(self) -> bool:
        pass


class NonPerishableProduct(Product, ident=RECORD_NAME('NonPerishableProduct')):

    def __init__(self, number: int, name: Text, dept: Department, initial_stock: int):
        self.stock_on_hand.set(initial_stock)
        super().__init__(number, name, dept)

    @staticmethod
    def schema():
        return {
            'stock_on_hand': declare_field(mds.typing.primitives.unsigned)
        }

    @property
    def is_perishable(self) -> bool:
        return False

    def add_stock(self, n: int, product_button: Pause.Button=None) -> None:
        tag = f"Adding to {self.name}: "

        def worker(cls: 'NonPerishableProduct', n: int, product_button: Pause.Button, tag: Text) -> None:
            # mds_ptr<Product> me = THIS_RECORD;
            # DONE: Check semantics of THIS_RECORD macro
            print(f"Adding {n} of {cls}")
            cls.stock_on_hand += n
            # DONE: Semantics / repr: cout << "Now " << THIS_RECORD << endl;
            print(f"Now {cls}")
            Pause.on(product_button, tag)

        isolated(target=worker, args=(self, n, product_button, tag))

    def remove_stock(self, n: int) -> int:
        current = self.stock_on_hand

        if current < n:
            n = current

        self.stock_on_hand = current - n
        self.nbr_sold += n
        return n

    @property
    def number_in_stock(self) -> int:
        return self.stock_on_hand


class PerishableProduct(Product, ident=RECORD_NAME('PerishableProduct')):

    def __init__(self, number: int, name: Text, dept: Department, life: int, initial_stock: int):
        self.shelf_life.set(life)
        self.stock_on_hand[0].set(initial_stock)
        super().__init__(number, name, dept)

    @staticmethod
    def schema():
        return {
            'shelf_life': declare_field(mds.typing.primitives.unsigned)
            'oldest': declare_field(mds.typing.primitives.unsigned)
            'today': declare_field(mds.typing.primitives.unsigned)
            'wastage': declare_field(mds.typing.primitives.unsigned)
            # TODO: How to instantiate MDSList(dtype=mds.types.unsigned) without len
            'stock_on_hand': declare_field(mds.typing.arrays.UIntArray)
        }

    @property
    def is_perishable(self) -> bool:
        return True

    def add_stock(self, n: int, product_button: Pause.Button=None) -> None:
        tag = "Adding to {}: ".format(self.name)

        def worker(cls, n, product_button, tag):
            # mds_ptr<Product> me = THIS_RECORD;
            # DONE: Check semantics of THIS_RECORD macro
            print("Adding {} of {}".format(n, cls))
            cls.stock_on_hand[cls.today % cls.shelf_life] += n
            # DONE: Semantics / repr: cout << "Now " << THIS_RECORD << endl;
            print("Now {}".format(cls))
            Pause.on(product_button, tag)

        isolated(target=worker, args=(self, n, product_button, tag))

    def remove_stock(self, n: int) -> int:
        stock = self.stock_on_hand
        wanted = n
        bumped = False
        life = self.shelf_life
        o = self.oldest.value()
        t = self.today

        while n > 0:
            i = o % self.life
            k = stock[i]

            if k >= n:
                stock[i] -= n
                n = 0
                break
            else:
                stock[i] = 0
                n -= k

                if o == t:
                    break

                o += 1
                bumped = True

        if bumped:
            self.oldest = o

        self.nbr_sold += wanted - n
        return wanted - n

    @property
    def number_in_stock(self) -> int:
        return reduce(lambda acc, el: acc + el, self.stock_on_hand)

    def new_day(self) -> None:
        # DONE: Updating orig object too: unsigned t = ++today;
        self.today += 1
        t = self.today
        o = self.oldest
        life = self.shelf_life
        stock = self.stock_on_hand

        if (t % life) == (o % life):
            wasted = stock[o % life].exchange(0)
            self.wastage += wasted
            self.oldest += 1


class BasketItem(Record, ident=RECORD_NAME('BasketItem')):

    def __init__(self, p: Product, q: int):
        self.product.set(p)
        self.quantity.set(q)

    @staticmethod
    def schema():
        return {
            'product': declare_field(mds.typing.composite.Record[Product], p)
            'quantity': declare_field(mds.types.unsigned)
        }

    def __str__(self):
        return "{} of {}".format(self.quantity, self.product)

    def purchase(self) -> None:
        print(f"Purchashing {self.quantity} of {self.product}")
        self.product.remove_stock(self.quantity)
        print(f"Now {self.product}")


class Basket(Record, ident=RECORD_NAME('Basket')):

    def __init__(self, items: RecordArray):
        self.items.set(items)

    @staticmethod
    def schema():
        return {
            'items': declare_field(mds.typing.arrays.Record[BasketItem])
        }

    def __str__(self):
        return "[{}]".format(", ".join(self.items))

    def purchase(self, recent: RecentPurchases, button: Pause.Button=None) -> None:
        items = self.items

        def worker(cls: Basket, recent: RecentPurchases, items: RecordArray) -> None:
            # TODO: Need to check this internal tasks::task_fn; if it's launching
            # a task per object, I'll need to wrap that, otherwise iterating as
            # below is fine.
            #
            # for_each_in_tasks(is.begin(), is.end(),
            #     [](const mds_ptr<BasketItem> &bi){
            #         cout << "Purchase task " << task::current() << endl;
            #         bi->purchase();
            #     });
            def task_worker_purchase(basket_item: BasketItem):
                print("Purchase task {}".format(Task.get_current()))
                basket_item.purchase()

            # Emulate native map API, @TODO: also implement .reduce / .filter?
            # TODO: This isn't implemented....
            mds.tasks.map(function=task_worker_purchase, iterable=items)

            def task_worker_add(cls: Basket, recent: RecentPurchases) -> None:
                print(f"Adding basket to recent: {cls}")
                recent.note(cls)

            as_task(target=task_worker_add, args=(cls, recent))
            Pause.on(button)

        # TODO: Missing this still: report_to(make_shared<Trace>("purchase"))
        isolated(target=worker, args=(self, recent, items))

    def add_to(self, total, mult: int) -> None:
        def worker(item: BasketItem, total, mult: int) -> None:
            total[item.product] += mult * item.quantity

        for item in self.items:
            as_task(target=worker, args=(item, total, mult))


class RecentPurchases(Record, ident=RECORD_NAME('RecentPurchases')):

    def __init__(self, n: int):
        # TODO: How to deal with mds.types.RecordArray? Check C++
        self.purchases = RecordArray(length=n)  # TODO: Check this in original demo
        self.window_size = n

    @staticmethod
    def schema():
        return {
            'purchases': declare_field(mds.typing.arrays.Record, reserve=n)  # TODO: Allocation
            'next_purchase': declare_field(mds.typing.primitives.unsigned)
            'window_size': declare_field(mds.typing.primitives.unsigned)
        }

    def note(self, basket: Basket) -> None:
        i = self.next_purchase + 1

        if i == self.window_size - 1:
            self.next_purchase = 0

        print("Recent[{}] = {}".format(i, basket))
        self.purchases[i] = basket

    def update_ranks(self, prods: RecordArray, button: Pause.Button) -> None:
        array = self.purchases
        total = defaultdict(int)
        # TODO: Missing something? vector<task::computed_val<mds_ptr<Basket> > > tcs;
        tcs = [None] * len(array)

        def worker(array: RecordArray, total, tcs):
            print("In snapshot")
            Pause.on(button)
            print("Outside task {}".format(Task.get_current()))

            def tc_fn(i, array, total, old):
                print("Basket task {}: {}".format(i, Task.get_current()))
                basket = array[i]

                if basket is not None:
                    print("Basket: {}".format(basket))
                    basket.add_to(total, 1)

                if old is not None:
                    old.add_to(total, -1)

                return basket

            # TODO: is ruts::indexes(array) doing something special? for (size_t i : ruts::indexes(array))
            for i, element in enumerate(array):
                # TODO: look into tasks.computed
                # TODO: How does the param old get passed thru to tc_fn?
                tcs[i] = mds.tasks.computed(target=tc_fn, args=(i, array, total, ...))

            def task_worker(tcs, prods, total):
                print("Sort task {}".format(Task.get_current()))

                # We touch each of the tcs to ensure that this task
                # is dependent on all products
                for tc in tcs:
                    td.get()

                # TODO: Ensure same logic: sort(pairs.begin(), pairs.end(),
                #       greater<decltype(pairs)::value_type>());
                pairs = [(total[prod], prod) for prod in prods]
                pairs.sort(key=lambda x, y: x[0] > y[0])
                rank = 0

                for _, product in pairs:
                    product.sales_rank = rank
                    rank += 1

            as_task(target=task_worker, args=(tcs, prods, total))

        # TODO: Missing param: report_to(make_shared<Trace>("Update"))
        isolated(target=worker, view="snapshot", args=(array, total, tcs))


class Store(mds.managed.Record, ident=RECORD_NAME('Store'):

    def __init__(self, ds: RecordArray, ps: RecordArray, window_size: int):
        self.depts = []
        self.products = []
        self.perishable = []
        self.recent_purchases = None

    @staticmethod
    def schema():
        return {
            # TODO: Again, how to declare MDSList instance of type T
            'depts': declare_field(mds.typing.arrays.Record[Department], original=ds)
            'products': declare_field(mds.typing.arrays.Record[Product], original=ps)
            'perishable': declare_field(mds.typing.arrays.Record[PerishableProduct], filter(lambda x: isinstance(x, PerishableProduct), ps))
            'recent_purchases': declare_field(mds.typing.composites.Record[RecentPurchases], window_size)  # TODO: Forward args?
        }

    def purchase(self, basket: Basket, button: Pause.Button=None) -> None:
        basket.purchase(self.recent_purchases, button)

    def restock(self, qfn: Callable, button: Pause.Button=None) -> None:
        # TODO: Pretty sure this is very broken

        def worker(qfn: Callable, products: RecordArray, button: Pause.Button) -> None:
            def task_worker(qfn, p, button):
                q = qfn(p)

                if q > 0:
                    p.add_stock(q, button)

            # TODO: This isn't implemented
            mds.tasks.map(function=task_worker, iterable=products)

        # TODO: report_to(make_shared<Trace>("Restock"))
        isolated(target=worker, args=(qfn, self.products, button))

    def new_day(self) -> None:
        # TODO: report_to(make_shared<Trace>("NewDay"))
        isolated(
            target=lambda x=self.perishable: mds.tasks.map(function=lambda p: p.new_day(), iterable=x)
        )

    def update_ranks(self, button: Pause.Button=None) -> None:
        self.recent_purchases.update_ranks(self.products, button)

    def ranked_products(self) -> List[Product]:
        prods = isolated(target=lambda p: p.read(), view="read_only", args=(self.products,))
        return sorted([x for x in prods], cmp=lambda x, y: x.sales_rank < y.sales_rank)


class StoreBuilder(object):

    WINDOW_SIZE = 10

    def __init__(self):
        self._dept_map = dict()
        self._depts = []
        self._prods = []

    def __find_dept(self, name):
        try:
            dept = self._dept_map[name]
        except KeyError:
            self.create_dept(name)
            dept = self._dept_map[name]

        return dept

    def add_non_perishable(self, dname, pname, initial):
        dept = self._find_dept(dname)
        prod = NonPerishableProduct(len(self._prods), pname, dept, initial)
        self._prods.append(prod)
        return prod

    def add_perishable(self, dname, pname, life, initial):
        dept = self._find_dept(dname)
        prod = PerishableProduct(len(self._prods), pname, dept, life, initial)
        self._prods.append(prod)
        return prod

    def build(self):
        return Store(self._depts, self._prods, StoreBuilder.WINDOW_SIZE)


def init_store():
    try:
        parse_or = lambda x, y: float(y) if len(y) > 0 else x
        parse_or_unsigned = lambda x, y: int(y) if len(y) > 0 else x
        builder = StoreBuilder()
        pops = []

        with open(PROD_FILE, mode="r") as f_ptr:
            reader = csv.reader(f_ptr, delimiter=",")

            for dept_name, prod_name, pop, shelf_life, initial in reader:
                pops.append(parse_or(1.0, pop))
                shelf_life = parse_or_unsigned(0, shelf_life)
                initial = parse_or_unsigned(0, initial)

                if 0 == shelf_life:
                    prod = builder.add_non_perishable(dept_name, prod_name, initial)
                else:
                    prod = builder.add_perishable(dept_name, prod_name, shelf_life, init_store)

        return (builder.build(), pops)
    except EnvironmentError:
        print("Product file '{}' not found".format(PROD_FILE))


def choose_product(store, popularity):
    # TODO: Port this
    # discrete_distribution<size_t> d(popularity.begin(), popularity.end());
    # size_t which = d(tl_rand());
    return store.products[which]


def make_basket(n, store, popularity):
    contents = dict()
    print("Creating a basked with {} items".format(n))

    for i in range(n):
        product = choose_product(store, popularity)

        if product in contents:
            contents[product].quantity += 1
        else:
            contents[product] = BasketItem(product, 1)

    basket = Basket(contents.values())
    printf("Basket is {}".format(basket))
    return basket

