"""
Managed Data Structures
Copyright Â© 2017 Hewlett Packard Enterprise Development Company LP.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

As an exception, the copyright holders of this Library grant you permission
to (i) compile an Application with the Library, and (ii) distribute the 
Application containing code generated by the Library and added to the 
Application during this compilation process under terms of your choice, 
provided you also meet the terms and conditions of the Application license.
"""

import mds


class WrongPriceException(Exception):

    def __init__(self, sku, asked, actual):
        super().__init__("Wrong Cost: SKU {}, wanted {}, but got {}.BaseException".format(
            sku, asked, actual
        ))


class InsufficientQuantityException(Exception):

    def __init__(self, sku, asked, actual):
        super().__init__("Wrong Quantity: SKU {}, wanted {}, but got {}.".format(
            sku, asked, actual
        ))


class NoSuchSKUException(Exception):

    def __init__(self, sku):
        super().__init__("SKU {} doesn't exist.".format(sku))


class SKUExistsException(Exception):

    def __init__(self, sku):
        super().__init__("SKU {} already exists.".format(sku))


class LineItem():

    def __init__(self, quantity, price, sku):
        self.sku = sku
        self.price = price
        self.quantity = quantity

"""
In both Product and Report, the first user-defined param `token` has been
removed from the C++ versions. This should be automatically deduced from
mds.MDSRecord.__new__

TODO: Make sure that this triggers as expected!
"""
class Product(mds.types.MDSRecord):
    by_sku = mds.mds_namespace["SKUs"]
    data_ns = mds.mds_namespace["/MyCo/data"]
    first_product_key = mds.types.MDSString("first_product")

    def __init__(self, sku, price, num_in_stock):
        # In C++ these must be DECLARE_FIELD'd first, then final RECORD_SETUP
        self.sku = sku
        self.n_in_stock = num_in_stock
        self.n_sold = None
        self.price = price
        self.revenue = None
        self.next_product = None

        self.__register_field(mds.types.str, "sku")
        self.__register_field(mds.types.unsigned, "n_in_stock")
        self.__register_field(mds.types.unsigned, "n_sold", 0)
        self.__register_field(mds.types.float, "price")
        self.__register_field(mds.types.float, "revenue", 0.0)
        self.__register_field(Product, "next_product")

        def worker(cls):
            cls.next_product = cls.lookup_in(cls.data_ns, cls.first_product_key)
            # TODO: THIS_RECORD->bind_in(data_ns, first_product_key);

        mds.isolated(target=worker, args=(self))
        # TODO: THIS_RECORD->bind_in(by_sku, s);

        # TODO: This is where RECORD_SETUP needs to be autocalled
        super().__init__()

    def check(self, q, p):
        if self.price != p:
            raise WrongPriceException(self.sku, p, self.price)

        if self.n_in_stock < q:
            raise InsufficientQuantityException(self.sku, q, self.n_in_stock)

    def sell(self, q, p):
        self.revenue += p * q
        self.n_sold += q
        self.n_in_stock -= q

    def __push_and_get_first(self):
        def worker(cls):
            old = Product.lookup_in(Product.data_ns, Product.first_product_key)
            # TODO: THIS_RECORD->bind_in(data_ns, first_product_key);
            return old

        return mds.isolated(target=worker, args=(self))

    @staticmethod
    def exists(sku):
        # TODO: return (*by_sku)[sku].is_bound();
        pass

    @staticmethod
    def lookup(sku):
        p = Product.lookup_in(Product.by_sku, sku)

        if p is None:
            raise NoSuchSKUException(sku)

        return p

    @staticmethod
    def get_first_product():
        return Product.lookup_in(Product.data_ns, Product.first_product_key)

    @staticmethod
    def new_product(sku, price, n_in_stock):
        def worker():
            if Product.lookup(sku) is not None:
                raise SKUExistsException(sku)

            # This should automagically make all the necessary handles etc.
            # communicating with MDS core in the compiled library
            return Product(sku, price, n_in_stock)

        return mds.isolated(function=worker)


class Report(mds.types.MDSRecord):
    by_sku = mds.mds_namespace
    data_ns = mds.mds_namespace

    def __init__(self, r, s, top_ten):
        self._register_field(mds.types.float, "total_revenue")
        self._register_field(mds.types.float, "stock_value")
        self._register_field(mds.types.MDSList, "top_ten_products", top_ten)

        self.total_revenue = r
        self.stock_value = s

        super().__init__()

    @staticmethod
    def get_report():
        all_products = []
        total_revenue = 0.0
        stock_value = 0.0
        p = mds.views.in_read_only_snapshot(Product.get_first_product)

        while p is not None:
            total_revenue += p.revenue
            stock_value += p.n_in_stock * p.price
            all_products.append(p)
            p = p.next_product

        # TODO: is the order of this correct? If not, reverse=True
        all_products.sort(key=lambda x: x.price)
        num_products = len(all_products)
        top_ten = all_products[:min(num_products, 10)]

        return Report(total_revenue, stock_value, top_ten)


def stock_in(sku, n):
    Product.lookup(sku).n_in_stock += n


def new_price(sku, p):
    Product.lookup(sku).price = p


def price_check(sku):
    return Product.lookup(sku).price


def process_sale(items):
    if len(items) == 0:
        return

    assert type(items[0]) == LineItem

    def worker(local_items):
        for item in local_items:
            p = Product.lookup(item.sku)
            p.check(item.quantity, item.price)

        for item in local_items:
            p = Product.lookup(item.sku)
            p.sell(item.quantity, item.price)

    mds.isolated(target=worker, args=(items))
