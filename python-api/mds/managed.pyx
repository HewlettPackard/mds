# -*- coding: utf-8 -*-
"""
Managed Data Structures
Copyright Â© 2017 Hewlett Packard Enterprise Development Company LP.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

As an exception, the copyright holders of this Library grant you permission
to (i) compile an Application with the Library, and (ii) distribute the
Application containing code generated by the Library and added to the
Application during this compilation process under terms of your choice,
provided you also meet the terms and conditions of the Application license.
"""

from itertools import chain

from libcpp cimport bool
from libcpp.string cimport string

from mds.core.api_strings cimport *
from mds.core.api_arrays cimport *
from mds.core.api_records cimport *
from mds.core.api_helpers cimport initialize_base_task
from mds.core.api_namespaces cimport *
from mds.core.api_primitives cimport *

from mds import typing, TypeInfo

import threading

__LOCAL = threading.local()
__LOCAL.token_stack = []

initialize_base_task()

# =========================================================================
#  Base
# =========================================================================

cdef class MDSObject(object):

    def _throw_const_error(self):
        raise ConstError("Can't assign value to const field.")

    # TODO: memoize?
    property is_const:
        def __get__(self):
            return self.__class__.__name__.startswith("Const")

    property is_null:
        def __get__(self):
            pass  # TODO

# =========================================================================
#  Errors & Exceptions
# =========================================================================

cdef class UnderflowError(Exception):
    pass

cdef class ConstError(Exception):
    pass

# =========================================================================
#  Managed Values
# =========================================================================

cdef class MDSPrimitiveBase(MDSObject):
    # TODO: Use the API's math operation to ensure atomicity

    def __int__(self):
        pass

    def __long__(self):
        pass

    def __float__(self):
        pass

    def _sanitize(self, value):
        return value

    def _to_python(self):
        raise NotImplementedError("Specialization required.")

    def _to_mds(self):
        raise NotImplementedError("Specialization required.")

    property python_copy:
        def __get__(self):
            raise NotImplementedError("Specialization required.")


cdef class MDSIntPrimitiveBase(MDSPrimitiveBase):

    def _sanitize(self, value):
        if isinstance(value, float):
            value = int(value)
        elif not isinstance(value, int):
            t = type(value)
            raise TypeError('Unable to parse value of type `{t}`')

        if value < self.MIN:
            raise UnderflowError(f"Can't fit {value} in container {self.dtype}")
        elif value > self.MAX:
            raise OverflowError(f"Can't fit {value} in container {self.dtype}")

        return value

    property MIN:
        def __get__(self):
            raise NotImplementedError("Integer specialization required.")

    property MAX:
        def __get__(self):
            raise NotImplementedError("Integer specialization required.")


cdef class MDSFloatPrimitiveBase(MDSPrimitiveBase):
    pass

# =========================================================================
#  Arrays
# =========================================================================

cdef class MDSArrayBase(MDSObject):
    
    def _index_bounds_check(self, index):
         # TODO: Need to handle slices. Should this be a new array?
        cdef long l = <long> len(self)

        if index >= l or index < -l:
            raise IndexError('list index out of range')

        if index < 0:
            index += l

        return index

    def _to_python(self, index):
        raise NotImplementedError('Specialization of MDSList required') 

    def _to_mds(self, index, value):
        raise NotImplementedError('Specialization of MDSList required') 

    def __getitem__(self, index):
        index = self._index_bounds_check(index)
        return self._to_python(index)

    def __setitem__(self, index, value):
        index = self._index_bounds_check(index)
        self._to_mds(index, value)

    def __iter__(self):
        return NotImplemented # TODO Implement this

    def __next__(self):
        return NotImplemented # TODO Implement this

    def __len__(self):
        raise NotImplementedError('Specialization of MDSArrayBase required') 

    def index(self, start=None, end=None):
        return NotImplemented # TODO Implement this

    def count(self, value):
        # TODO: Handle len 0, should this even be instantiable?
        # TODO: Bool still a str-literal here
        if not isinstance(value, type(self[0])):
            raise TypeError("value to be searched for must match list-type `bool`")

        cdef:
            size_t i = 0, l = len(self), c = 0

        for i in range(l):
            if self[i] == value:
                c += 1

        return c

    def sort(self):
        return NotImplemented # TODO Implement this

    def reverse(self):
        return NotImplemented # TODO Implement this

    def copy(self):
        raise NotImplementedError('Specialization of MDSArrayBase required')
 
    property dtype:
        def __get__(self):
            raise NotImplementedError('Specialization of MDSArrayBase required')


cdef class MDSIntArrayBase(MDSArrayBase):

    def _numeric_bounds_check(self, value):
        """
        TODO: This needs to check the bounds of the different int sizes in MDS.
        """
        raise NotImplementedError('Requires a type-specific instantiation')

    def __setitem__(self, index, value):
        index = self._index_bounds_check(index)
        value = self._numeric_bounds_check(value)
        self._to_mds(index, value)

    property dtype:
        def __get__(self):
            return type(1)


cdef class MDSFloatArrayBase(MDSArrayBase):

    property dtype:
        def __get__(self):
            return type(1.0)

# =========================================================================
#  Records
# =========================================================================

cdef class MDSRecordFieldMemberPair(object):
    cdef:
        MDSRecordFieldBase field
        type member

    def __init__(self, field, member):
        self.field = field  # derived <- MDSRecordFieldBase
        self.member = member  # type: derived <- MDSRecordMemberBase


cdef class Record(MDSObject):
    cdef:
        managed_record_handle _handle
        # RecordTypeDeclaration _type_decl

    def __cinit__(self, MDSRecordCreatorToken token):
        self._handle = managed_record_handle(token.create())
        token.cache_shared(self)

        # self._type_decl = self.type_declaration()

    def __init_subclass__(cls, ident, **kwargs):
        """
        This is called whenever a subclass of Record comes into scope, this
        provides a couple of nice opportunities:

        1) Ensure the type is properly declared in MDS before an instance
           is called, and bind the type declaration as a static member in
           Python-land
        2) TODO: See if any ambiguous proxies from Namespace are awaiting this
           specific implementation, and deal with that accordingly.
        """
        super().__init_subclass__(**kwargs)
        cls.ident = ident

        # This is the same as rt_decl ... type_decl() in that it instantiates
        # the RecordTypeDeclarion (rt_decl)
        # TODO: Do I need to cache/store this somewhere to avoid multiple attempts?
        cls.type_decl = cls.type_declaration()

    def _register_fields(self):
        """
        When this subclass was declared, with automagically registered the Record type
        with MDS; in so doing we stored single-instances of the RecordFields we required,
        but type references to the members, as they must be instance-bound.

        This method iterates through that container and updates the object's dict
        to enable dot notation access to the associated MemberRecords
        """
        # Stll need to make the RecordMembers and bind them to this instance
        for label, field_member_pair in cls.type_decl.get_field_member_pairs().items():
            field, member_t = field_member_pair.field, field_member_pair.member
            self.__dict__[label] = member_t(self)

    @classmethod
    def lookup_in_namespace(cls, ns, *args):
        if not isinstance(ns, Namespace):
            raise TypeError('Need a `Namespace` object as first argument')

        if not len(args):
            raise KeyError('Need at least one path for the namespace')
    
        record = ns[args]
        retval = cls()
        # TODO: update retval's fields accordingly

        return retval

    @classmethod
    def force(cls):
        MDSManagedType.ensure_complete(cls)

    @classmethod
    def type_declaration(cls):
        raise TypeError("Derived `Record`s should return a RecordTypeDeclaration here.")

    @staticmethod
    def declare_const_field(klass):
        """
        Delegates to Record.declare_field; could be deleted, but here to map 1:1 to CAPI.
        """
        return Record.declare_field(klass, make_const=True)

    @staticmethod
    def declare_field(klass, make_const=False):  # const is broken here, not at field level, should be member
        """
        This returns the derived RecordField for the combination of the arguments.

        TODO: This only works for primitives, will need adaptation for {String, Array, Record}
        TODO: String-based hacking isn't neat, should make a dict using the generator,
        but this works for now.

        Args:
            klass:  TypeInfo, obtained from `mds.typing`
            make_const: Bool, whether to make the associated RecordMember const or not
        """
        if not isinstance(klass, TypeInfo):
            raise TypeError("First parameter needs to be a type from `mds.typing`")

        associated_member = "{constness}{title}RecordMember".format(
            constness="Const" if make_const else "",
            title=klass.title
        )

        # Now, let's see if it's known and of the correct lineage
        cls = globals()[klass.title]
        assert issubclass(cls, MDSRecordFieldBase)

        member = globals()[associated_member]
        assert issubclass(member, MDSRecordMemberBase) or isinstance(member, MDSConstRecordMemberBase)

        # DEBUG
        print(f"?> Making pair {cls.__name__}, {member.__name__}")

        # Unlike the CAPI we return both the instantiated field and a type for the member
        return MDSRecordFieldMemberPair(field=cls(), member=member)

cdef class ExampleRecord(Record, ident="PythonTest::ExampleRecord"):  # => Test
    """
    Descendents of Record should explictly declare an `ident` key/value pair in the
    class descriptor as above; this is how the type will be known to MDS.
    """

    @classmethod
    def type_declaration(cls):
        """
        This method *must* be overridden in Record-derived classes, and follow the
        following syntax for declaring the record schema.

        Once the class `cls` has come into scope, an instantaited copy of this object
        will be available via cls.type_decl

        TODO: Could this just return fields? Deal with cls etc. in __init_subclass__?
        """
        fields = {
            "is_active": Record.declare_const_field(mds.typing.bool),
            "number_of_players": Record.declare_field(mds.typing.ushort)
        }

        # return RecordTypeDeclaration(cls.ident(), fields, Record)
        return RecordTypeDeclaration(cls, fields)

############################################################# RECORD CREATOR TOKENS

cdef class MDSRecordCreatorToken(MDSObject):
    # If we create the initial shared ptr as a
    # shared_ptr<mds_record>, then when the last shared_ptr
    # goes away and the mds_record is destroyed, if there were
    # virtual functions added below, the wrong pointer to the
    # memory will be wrong.  So we indirect through the rc_token,
    # which knows the type to create the pointer to cache.
    cdef:
        Record _shared_ptr

    def __cinit__(self):
        self.recent_stack = MDSTokenStack.recent_stack
        self.recent_stack.push(None)

    def __dealloc__(self):
        self.recent_stack.pop()

    def create(self):
        pass

    def cache_shared(self, Record record):
        pass


cdef class MDSTypedRecordCreatorToken(MDSRecordCreatorToken):

    def create(self):
        # TODO: ensure_thread_initialized()
        # TODO: return MDSManagedRecordType.ensure_complete(cls).create_record()
        pass

    def cached_shared_ptr(self):
        return self._shared_ptr

    def cache_shared(self, Record r):
        # This is called from mds_record's ctor, so the actual
        # concrete class hasn't been constructed yet.  I'm assuming
        # that creating a shared_ptr to it won't involve anythnig more
        # than doing some adjustment to the this pointer.
        self._shared_ptr = r
        self.recent_stack.append(r)

    @staticmethod
    def being_constructed():
        recent = MDSTokenStack.recent_stack
        assert len(recent) and recent[-1] is not None
        return recent[-1]


cpdef new_record(type cls, *args, **kwargs):
    token = MDSTypedRecordCreatorToken(cls)
    obj = cls(token, *args, **kwargs)
    return obj


# TODO: Leave these until RecordTypeDeclaration is looking OK
# __GLOBAL_CREATOR_MAP = dict()

# class MDSCreatorCache():
    
#     @staticmethod
#     def register_type(RecordTypeDeclaration rtd, klass):
#         """
#         Thanks to the GIL, we don't need to worry about races / mutexes
#         NOTE name came from const api::const_record_type_handle &type_handle(.name())

#         This function is called from RecordTypeDeclaration.ensure_created(),
#         so let's have that as the first input and pull out the exact value
#         """

#         # 
#         __GLOBAL_CREATOR_MAP[name] = klass


#     @staticmethod
#     def create()

# class MDSRecordCreator():
#     pass


cdef class MDSManagedRecordType(MDSObject):
    cdef:
        Record _parent

    def __cinit__(self, Record parent)
        self._parent = parent

    def ensure_created(self):
        return self._parent.type_declaration().ensure_created()

    @staticmethod
    def ensure_complete(cls):
        return cls.type_declaration().ensure_created()

    @staticmethod
    def from_handle(self):
  # static mds_ptr<R> from_handle(const Record::handle_t &h) {
  #   if (!std::is_abstract<R>::value) {
  #     /*
  #      * If there are no virtual functions we might as well just create
  #      * a new proxy object.  We could cache them, but this is probably
  #      * at least as efficient.
  #      */
  #     return RecordCreator<R>::create_from_handle(h);
  #   } else {
  #     /*
  #      * If there are virtual functions, we need to find the actual type
  #      * for the record.
  #      */
  #     const_handle_t th = h.type();
  #     /*
  #      * If it's ours, we can just create it here.
  #      */
  #     if (th == ManagedType().handle()) {
  #       return RecordCreator<R>::create_from_handle(h);
  #     }
  #     mds_ptr<Record> r = CreatorCache::create(th, h);
  #     /*
  #      * We should be guaranteed of at least finding *this* class.
  #      */
  #     assert(r != nullptr);
  #     return r.static_pointer_cast<R>();
  #   }
  # }

        pass

    def from_core(self):
  # mds_ptr<R> from_core(const Record::handle_t &val) const {
  #   if (val == nullptr) {
  #     return nullptr;
  #   }
  #   return from_handle(val);
  # }
        pass

    def to_core(self):
  # core_api_type to_core(const mds_ptr<R> &val) const {
  #   core_api_type tcv = val == nullptr ? core_api_type { } : val->_handle;
  #   return tcv;
  # }

  # core_api_type to_core(const mds_ptr<const R> &val) const {
  #   return val == nullptr ? core_api_type { } : val->_handle;
  # }
        pass

############################################################# RECORD FIELDS

cdef class MDSRecordFieldBase(MDSObject):

    def __getitem__(self, item):
  # reference operator[](const mds_ptr<R> &r) const {
  #   R::type_decl().ensure_created();
  #   return reference(*this, *r);
  # }

  # reference operator[](R *r) const {
  #   R::type_decl().ensure_created();
  #   return reference(*this, *r);
  # }

  # const_reference operator[](const mds_ptr<const R> &r) const {
  #   R::type_decl().ensure_created();
  #   return const_reference(*this, *r);
  # }

  # const_reference operator[](const R *r) const {
  #   R::type_decl().ensure_created();
  #   return const_reference(*this, *r);
  # }
        pass

    def ensure_type(self):
        pass

    def declare(self, String name, Record record):
        pass

    # These two, either use them in generated RecordFields and then Members, or
    # use overloaded calls in Members directly, then delete these.
    @classmethod
    def from_core(cls, val):
        pass

    @classmethod
    def to_core(cls, val):
        pass

# No const RecordField, const-ness is handled by RecordMembers

cdef class UShortRecordField(MDSRecordFieldBase):  # => Generator
    cdef:
        h_rfield_ushort_t _handle
        h_mushort_t mtype
  # using handle_type = typename managed_type<T>::field_handle_type;
  # handle_type _handle;
    # using mtype = managed_type<T>;
    # using value_type = typename mtype::mds_type;
    # using core_api_type = typename mtype::core_api_type;  


    def ensure_type(self):
    # managed_type<T>::ensure_complete(); // h_mushort_t?
        pass

    def declare(self, String name, Record record):
        assert self._handle.is_null()
        self._handle = h_mushort_t().field_in(record._handle, name._handle, True)


# TODO: Work through some Const*RecordField examples

######################################################################### REFERENCES

cdef class MDSConstRecordFieldReferenceBase(MDSObject):
    cdef:
        managed_record_handle _record_handle

    def read(self):
        pass

    def peek(self):
        pass

    def write(self, value):
        self._throw_const_error()


cdef class MDSRecordFieldReferenceBase(MDSConstRecordFieldReferenceBase):

    def write(self, value):
        pass

  # static value_type from_core(const core_api_type &val) {
  #   return mtype().from_core(val);
  # }

  # /*
  #  * When we're and array field, the API read methods only get it as the base
  #  * array pointer, so we need to downcast.  This should be safe
  #  */
  # template<typename U = T, typename = std::enable_if_t<is_mds_array<U>::value>>
  # static value_type from_core(const api::managed_array_base_handle &handle) {
  #   using elt_type = typename mtype::elt_type;
  #   core_api_type h(handle.pointer()->template downcast<elt_type::kind>(),
  #                   handle.view());
  #   return from_core(h);
  # }

  # static core_api_type to_core(const value_type &val) {
  #   return mtype().to_core(val);
  # }

cdef class ConstBoolRecordFieldReference(MDSConstRecordFieldReferenceBase):   # => Generator
    cdef:
        h_const_rfield_bool_t _field_handle
        Record _record

    def __cinit__(self, MDSRecordFieldBase field, Record record):
        self._record = record
        self._field_handle = h_const_rfield_bool_t(field._handle)
        self._record_handle = managed_record_handle(record._handle)

    def read(self):
        cdef bool retval = self._field_handle.frozen_read(self._record_handle)
        return from_core_bool(retval)

    def peek(self):
        cdef bool retval = self._field_handle.free_read(self._record_handle)
        return from_core_bool(retval)


cdef class BoolRecordFieldReference(ConstBoolRecordFieldReference):  # => Generator
    
    def write(self, bint value):
        self._field_handle.write(self._record_handle, to_core_bool(value));


cdef class ConstUShortRecordFieldReference(MDSConstRecordFieldReferenceBase):  # => Generator
    cdef:
        h_const_rfield_ushort_t _field_handle
        Record _record

    def __cinit__(self, MDSRecordFieldBase field, Record record):
        self._record = record
        self._field_handle = h_const_rfield_ushort_t(field._handle)
        self._record_handle = managed_record_handle(record._handle)

    def read(self):
        cdef uint16_t retval = self._field_handle.frozen_read(self._record_handle)
        return from_core_uint16_t(retval)

    def peek(self):
        cdef uint16_t retval = self._field_handle.free_read(self._record_handle)
        return from_core_uint16_t(retval)


cdef class UShortRecordFieldReference(ConstUShortRecordFieldReference):  # => Generator
    
    def write(self, uint16_t value):
        self._field_handle.write(self._record_handle, to_core_uint16_t(value));

    def __iadd__(self, other):
        self._field_handle.add(self._record_handle, to_core_uint16_t(other))

    def __isub__(self, other):
        self._field_handle.sub(self._record_handle, to_core_uint16_t(other))

    def __imul__(self, other):
        self._field_handle.mul(self._record_handle, to_core_uint16_t(other))

    def __idiv__(self, other):
        self._field_handle.div(self._record_handle, to_core_uint16_t(other))


############################################################# RECORD MEMBERS

cdef class MDSRecordMemberBase(MDSObject):
    cdef:
        Record _enclosing

    # using value_type = typename record_field<R,T>::value_type;

    def __cinit__(self, Record record, other=None):
  # record_member()
  #     : _enclosing(*typed_rc_token<R>::being_constructed()) {
  #   assert(&_enclosing != nullptr);
  # }
        self._enclosing = record

        # Delegate this checking to the write() method
  # explicit record_member(const value_type &v)
  #     : record_member() {
  #   write(v);
  # }

  # explicit record_member(const record_member &other)
  #     : record_member() {
  #   write(other);
  # }


        if other is not None:
            self.write(other)

    def _field_ref(self):
        return MDSRecordFieldBase()[self]

    def read(self):
        pass

    def peek(self):
        pass

    def write(self, value):
        pass


cdef class UShortRecordMember(MDSRecordMemberBase):  # => Generator

    def read(self):
        return self._field_ref().read()

    def peek(self):
        return self._field_ref().peek()

    def write(self, uint16_t value):
        self._field_ref().write(value);

    def __iadd__(self, other):
        self._field_ref() += other

    def __isub__(self, other):
        self._field_ref() -= other

    def __imul__(self, other):
        self._field_ref() *= other

    def __idiv__(self, other):
        self._field_ref() /= other


cdef class MDSConstRecordMemberBase(MDSObject):
    cdef:
        Record _enclosing
        bint _is_cached
 # public:
 #  using value_type = typename record_field<R,T>::value_type;
 # private:
 #  R &_enclosing;
 #  mutable value_type _cached_val;
 #  mutable bool _is_cached;

    def _field_ref(self):
        return MDSRecordFieldBase()[self]

    def __cinit__(self, other):
  # record_const_member()
  #     : _enclosing(*typed_rc_token<R>::being_constructed()),
  #       _is_cached { false } {
  #   assert(&_enclosing != nullptr);
  # }

  # explicit record_const_member(const value_type &v)
  #     : _enclosing(*typed_rc_token<R>::being_constructed()),
  #       _cached_val(_field_ref().write(v)),
  #       _is_cached { true } {
  # }

  # explicit record_const_member(const record_const_member &other)
  #     : record_const_member(other.read()) {
  # }
        if other is not None:
            pass

    def write(self, value):
        self._throw_const_error()


cdef class ConstUShortRecordMember(MDSConstRecordMemberBase):  # => Generator
    cdef:
        uint16_t _cached_val

    def read(self):
        if not self._is_cached:
            self._cached_val = self._field_ref.read()
            self._is_cached = True

        return self._cached_val

    def peek(self):
        return self.read()


######################################################### RECORD TYPE DECLARATIONS

cdef class RecordFieldDeclaration(object):
    cdef:
        String name
        MDSRecordFieldBase field

    def __cinit__(self, String name, MDSRecordFieldBase field):
        self.name = name
        self.field = field


__RECORD_DECLARATION_MUTEX = threading.Lock()

cdef class RecordTypeDeclaration(object):
    cdef:
        list _field_decls
        list _field_member_pairs
        const record_type_handle _declared_type
        const_record_type_handle _created_type
        bint _created

    # def __cinit__(self, String name, list fields, type parent):
    #     self._declared_type = self.declare(name, parent)
    #     self.note_fields(fields)

    def __cinit__(self, type cls, dict fields):
        self._declared_type = self.declare(cls.ident, parent)
        self._field_member_pairs = fields
        self.note_fields(fields)

 #  api::const_record_type_handle handle() const {
 #    return _created_type.is_null() ? _declared_type : _created_type;
 #  }

 #  template<typename S>
 #  api::record_type_handle declare(const mds_string &name, managed_type<S> s) {
 #    static_assert(is_record_type<S>::value, "Super type not a record type");
 #    auto sp = s.ensure_created();
 #    return api::record_type_handle::declare(name.handle(), sp);
 #  }

    def declare(self, String name, type s=None):
        if s is None:
            return record_type_handle.declare(name._handle)

        assert issubclass(s, Record), "Super type not a record type"
        sp = s.ensure_created()  # This is returning a const_record_handle_type
        return record_type_handle.declare(name._handle, sp)

    # def note_fields(self, list fields):
    #     for field, label in fields:
    #         self._field_decls.append(RecordFieldDeclaration(label, field))

    def note_fields(self, dict fields):
        for label, field_member_pair in fields.items():
            self._field_decls.append(RecordFieldDeclaration(label, field_member_pair.field))

    def declare_fields(self):
        for fd in self._field_decls:
            fd.field.declare(fd.name, self._declared_type)

    def ensure_field_types(self):
        for fd in self._field_decls:
            fd.field.ensure_type()

    def ensure_created(self):
        if not self._created:
            __RECORD_DECLARATION_MUTEX.acquire()

            # Ensure no one else has beat us to the punch
            if not self._created:
                # Call once semantics, -> threading.Condition
                self.declare_fields()
                self._created_type = self._declared_type.ensure_created()
                # We want to keep a copy of this alive so we don't have to
                # rebuild it
                MDSRecordCreator.register_type(self)
                self.ensure_field_types()
                self._created = True

            __RECORD_DECLARATION_MUTEX.release()

        return self._created_type  # TODO: Wrap

    def get_field_member_pairs(self):
        return self._field_member_pairs

# =========================================================================
#  Strings
# =========================================================================


cdef class String(MDSObject):
    """
    This class provides the functionality expected from the native str type,
    but backed by MDS. As with str, Strings are immutable.
    """

    cdef:
        managed_string_handle _handle
        int __iter_idx

    def __cinit__(self, value=None):
        cdef interned_string_handle handle = convert_py_to_ish(value) 
        self._handle = managed_string_handle(handle)
        self.__iter_idx = 0

    def __len__(self):
        return self._handle.length()

    def __hash__(self):
        return self._handle.hash1()

    def __iter__(self):
        self.__iter_idx = 0
        return self

    def __next__(self):
        if self.__iter_idx < len(self):
            retval = self[self.__iter_idx]
            self.__iter_idx += 1
            return retval
        else:
            raise StopIteration

    def __str__(self):
        return <str> self._handle.utf8().decode("utf-8")

    def __repr__(self):
        return "'{}'".format(str(self))

    def __getitem__(self, item):
        cdef:
            string s
            int i
            char_type c

        if isinstance(item, int):
            c = self._handle.at(item)
            u = chr(c)
            return u
        elif isinstance(item, slice):
            # TODO: Check this
            s.reserve((item.stop - item.start) // item.step)

            for i in range(start=item.start, stop=item.stop, step=item.step):
                s.push_back(self._handle.at(i))

            return String(s)

        raise TypeError(
            "list indices must be integers or slices, not {}".format(
                type(item)
            )
        )

    def __add__(self, other):
        """
        Concatenates this string with another, returns this as a new String
        """
        # TODO: Could probably open this to [str, bytes] too.
        cdef:
            string s
            str c

        if isinstance(other, String):       
            s.reserve(<size_t> (len(self) + len(other)))

            # Chain the iterators to avoid any string copying
            for c in chain(iter(self), iter(other)):
                s.push_back(ord(c))  # Need as an int for char

            return String(s)

        raise TypeError("must be String")

    def __mul__(self, other):
        """
        Internal method to perform String multiplication without overhead
        """
        cdef:
            string s
            str c
            int it, l = len(self)

        if isinstance(other, int):
            s.reserve(l * other)

            for it in range(other):
                for c in self:
                    s.push_back(ord(c))

            return String(<unicode> s.decode("utf-8"))

        raise TypeError(
            "can't multiply sequence by non-int of type 'String'"
        )

    def __rmul__(self, other):
        pass

    def __mod__(self, other):
        pass

    def __rmod__(self, other):
        pass

    def __richcmp__(a, b, op):
        if op == 0:    # <
            return a._handle < b._handle
        elif op == 1:  # <=
            return a._handle <= b._handle
        elif op == 2:  # ==
            return a._handle == b._handle
        elif op == 3:  # !=
            return a._handle != b._handle
        elif op == 4:  # >
            return a._handle > b._handle
        elif op == 5:  # >=
            return a._handle >= b._handle

    def __sizeof__(self):
        return self._handle.size()

    # TODO: Write equivalents that use the MDS-stored data

    def capitalize(self):
        return String(str(self).capitalize())

    def casefold(self):
        return String(str(self).casefold())

    def center(self, *args, **kwargs):
        return String(str(self).center(*args, **kwargs))

    # TODO: encode(encoding="utf-8", errors="strict")

    def endswith(self, *args, **kwargs):
        return str(self).endswith(*args, **kwargs)

    def expandtabs(self, *args, **kwargs):
        return String(str(self).expandtabs(*args, **kwargs))

    def find(self, *args, **kwargs):
        return str(self).find(*args, **kwargs)

    def format(self, *args, **kwargs):
        return String(str(self).format(*args, **kwargs))

    def format_map(self, *args, **kwargs):
        return String(str(self).format_map(*args, **kwargs))

    def index(self, *args, **kwargs):
        return str(self).index(*args, **kwargs)

    def isalnum(self, *args, **kwargs):
        return str(self).isalnum(*args, **kwargs)

    def isalpha(self, *args, **kwargs):
        return str(self).isalpha(*args, **kwargs)

    def isdecimal(self, *args, **kwargs):
        return str(self).isdecimal(*args, **kwargs)

    def isdigit(self, *args, **kwargs):
        return str(self).isdigit(*args, **kwargs)
    
    def isidentifier(self, *args, **kwargs):
        return str(self).isidentifier(*args, **kwargs)
    
    def islower(self, *args, **kwargs):
        return str(self).islower(*args, **kwargs)

    def isnumeric(self, *args, **kwargs):
        return str(self).isnumeric(*args, **kwargs)

    def isprintable(self, *args, **kwargs):
        return str(self).isprintable(*args, **kwargs)

    def isspace(self, *args, **kwargs):
        return str(self).isspace(*args, **kwargs)

    def istitle(self, *args, **kwargs):
        return str(self).istitle(*args, **kwargs)

    def isupper(self, *args, **kwargs):
        return str(self).isupper(*args, **kwargs)

    def join(self, *args, **kwargs):
        return String(str(self).join(*args, **kwargs))

    def ljust(self, *args, **kwargs):
        return String(str(self).ljust(*args, **kwargs))

    def lower(self, *args, **kwargs):
        return String(str(self).lower(*args, **kwargs))

    def lstrip(self, *args, **kwargs):
        return String(str(self).lstrip(*args, **kwargs))

    def partition(self, *args, **kwargs):
        return tuple([String(x) for x in str(self).partition(*args, **kwargs)])

    def replace(self, *args, **kwargs):
        return String(str(self).replace(*args, **kwargs))

    def rfind(self, *args, **kwargs):
        return str(self).rfind(*args, **kwargs)

    def rindex(self, *args, **kwargs):
        return str(self).rindex(*args, **kwargs)

    def rjust(self, *args, **kwargs):
        return String(str(self).rjust(*args, **kwargs))

    def rpartition(self, *args, **kwargs):
        return tuple([String(x) for x in str(self).rpartition(*args, **kwargs)])

    def rsplit(self, *args, **kwargs):
        return [String(x) for x in str(self).rsplit(*args, **kwargs)]

    def rstrip(self, *args, **kwargs):
        return String(str(self).rstrip(*args, **kwargs))

    def split(self, *args, **kwargs):
        return [String(x) for x in str(self).split(*args, **kwargs)]

    def splitlines(self, *args, **kwargs):
        return [String(x) for x in str(self).split(*args, **kwargs)]

    def startswith(self, *args, **kwargs):
        return str(self).startswith(*args, **kwargs)

    def strip(self, *args, **kwargs):
        return String(str(self).strip(*args, **kwargs))
    
    def swapcase(self, *args, **kwargs):
        return String(str(self).swapcase(*args, **kwargs))

    def title(self, *args, **kwargs):
        return String(str(self).title(*args, **kwargs))

    # TODO: translate

    def upper(self, *args, **kwargs):
        return String(str(self).upper(*args, **kwargs))

    def zfill(self, *args, **kwargs):
        return String(str(self).zfill(*args, **kwargs))

# =========================================================================
#  Namespace
# =========================================================================


cdef class Namespace(MDSObject):

    cdef namespace_handle _handle

    def __setitem__(self, key, value):
        cdef:
            interned_string_handle ish = convert_py_to_ish(key)
            uint16_t val = value

        # TODO: Restrict value to MDSObject, or just do smallest-fitting-elem?
        # if not issubclass(type(value), MDSObject):
        #     raise TypeError('Cannot commit a non-MDS type into a MDS namespace')

        # TODO: get the boxed item to release its wrapped value into bind...
        self._handle.bind(ish, val)

    def __getitem__(self, key):
        # TODO: Need some type inference here, require explicit third param?
        cdef:
            uint16_t retval
            interned_string_handle ish = convert_py_to_ish(key)

        retval = self._handle.lookup(ish, managed_ushort_type_handle())
        return retval

    def create_child(self, child_id, bint create_if_missing=True):
        cdef:
            interned_string_handle ish = convert_py_to_ish(child_id)
            bool cim = <bool> create_if_missing
        
        return Namespace_Init(self._handle.child_namespace(ish, cim))

    @staticmethod
    def from_path(path):
        pass

    @staticmethod
    def get_current():
        pass  # TODO: mds_namespace::current()

    @staticmethod
    def get_global():
        return Namespace_Init(handle=namespace_handle._global())

    property is_root:
        def __get__(self):
            # TODO: Implement this
            pass

    property parent:
        def __get__(self):
            # TODO: Implement this
            pass


cdef inline Namespace_Init(namespace_handle handle):
    initialize_base_task()
    result = Namespace()
    result._handle = handle
    return result

# =========================================================================
#  Helpers
# =========================================================================

cpdef inline is_record_type(obj):
    return issubclass(obj, Record)

# TODO: These record_creator methods
cdef inline _register_type(const_record_type_handle crht):
    pass

cdef inline _create_from_handle(managed_record_handle mrh):
    pass

cdef inline record_type_handle _declare_record_type(str ident):
    return record_type_handle.declare(convert_py_to_ish(ident))

# =========================================================================
#  Primitives
# =========================================================================

# START INJECTION | tmpl_concrete_array

cdef class Bool(MDSPrimitiveBase):

    cdef mv_bool _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    

cdef inline BoolArray_Inplace(BoolArray cls, size_t length):
    cls._handle = create_bool_marray(length)

cdef class BoolArray(MDSArrayBase):

    cdef h_marray_bool_t _handle
    _primitive = Bool

    def __cinit__(self, length=None):
        if length is not None:
            BoolArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_bool(value))
    
    def copy(self):
        retval = BoolArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

    property dtype:
        def __get__(self):
            return type(True)

cdef class Byte(MDSIntPrimitiveBase):

    cdef mv_byte _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return -128

    property MAX:
        def __get__(self):
            return 127 


cdef inline ByteArray_Inplace(ByteArray cls, size_t length):
    cls._handle = create_byte_marray(length)

cdef class ByteArray(MDSIntArrayBase):

    cdef h_marray_byte_t _handle
    _primitive = Byte

    def __cinit__(self, length=None):
        if length is not None:
            ByteArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_byte(value))
    
    def copy(self):
        retval = ByteArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class UByte(MDSIntPrimitiveBase):

    cdef mv_ubyte _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 255 


cdef inline UByteArray_Inplace(UByteArray cls, size_t length):
    cls._handle = create_ubyte_marray(length)

cdef class UByteArray(MDSIntArrayBase):

    cdef h_marray_ubyte_t _handle
    _primitive = UByte

    def __cinit__(self, length=None):
        if length is not None:
            UByteArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_ubyte(value))
    
    def copy(self):
        retval = UByteArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class Short(MDSIntPrimitiveBase):

    cdef mv_short _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return -32768

    property MAX:
        def __get__(self):
            return 32767 


cdef inline ShortArray_Inplace(ShortArray cls, size_t length):
    cls._handle = create_short_marray(length)

cdef class ShortArray(MDSIntArrayBase):

    cdef h_marray_short_t _handle
    _primitive = Short

    def __cinit__(self, length=None):
        if length is not None:
            ShortArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_short(value))
    
    def copy(self):
        retval = ShortArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class UShort(MDSIntPrimitiveBase):

    cdef mv_ushort _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 65535 


cdef inline UShortArray_Inplace(UShortArray cls, size_t length):
    cls._handle = create_ushort_marray(length)

cdef class UShortArray(MDSIntArrayBase):

    cdef h_marray_ushort_t _handle
    _primitive = UShort

    def __cinit__(self, length=None):
        if length is not None:
            UShortArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_ushort(value))
    
    def copy(self):
        retval = UShortArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class Int(MDSIntPrimitiveBase):

    cdef mv_int _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return -2147483648

    property MAX:
        def __get__(self):
            return 2147483647 


cdef inline IntArray_Inplace(IntArray cls, size_t length):
    cls._handle = create_int_marray(length)

cdef class IntArray(MDSIntArrayBase):

    cdef h_marray_int_t _handle
    _primitive = Int

    def __cinit__(self, length=None):
        if length is not None:
            IntArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_int(value))
    
    def copy(self):
        retval = IntArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class UInt(MDSIntPrimitiveBase):

    cdef mv_uint _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 4294967295 


cdef inline UIntArray_Inplace(UIntArray cls, size_t length):
    cls._handle = create_uint_marray(length)

cdef class UIntArray(MDSIntArrayBase):

    cdef h_marray_uint_t _handle
    _primitive = UInt

    def __cinit__(self, length=None):
        if length is not None:
            UIntArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_uint(value))
    
    def copy(self):
        retval = UIntArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class Long(MDSIntPrimitiveBase):

    cdef mv_long _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return -9223372036854775808

    property MAX:
        def __get__(self):
            return 9223372036854775807 


cdef inline LongArray_Inplace(LongArray cls, size_t length):
    cls._handle = create_long_marray(length)

cdef class LongArray(MDSIntArrayBase):

    cdef h_marray_long_t _handle
    _primitive = Long

    def __cinit__(self, length=None):
        if length is not None:
            LongArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_long(value))
    
    def copy(self):
        retval = LongArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class ULong(MDSIntPrimitiveBase):

    cdef mv_ulong _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 18446744073709551615 


cdef inline ULongArray_Inplace(ULongArray cls, size_t length):
    cls._handle = create_ulong_marray(length)

cdef class ULongArray(MDSIntArrayBase):

    cdef h_marray_ulong_t _handle
    _primitive = ULong

    def __cinit__(self, length=None):
        if length is not None:
            ULongArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_ulong(value))
    
    def copy(self):
        retval = ULongArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class Float(MDSFloatPrimitiveBase):

    cdef mv_float _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    

cdef inline FloatArray_Inplace(FloatArray cls, size_t length):
    cls._handle = create_float_marray(length)

cdef class FloatArray(MDSFloatArrayBase):

    cdef h_marray_float_t _handle
    _primitive = Float

    def __cinit__(self, length=None):
        if length is not None:
            FloatArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_float(value))
    
    def copy(self):
        retval = FloatArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class Double(MDSFloatPrimitiveBase):

    cdef mv_double _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    

cdef inline DoubleArray_Inplace(DoubleArray cls, size_t length):
    cls._handle = create_double_marray(length)

cdef class DoubleArray(MDSFloatArrayBase):

    cdef h_marray_double_t _handle
    _primitive = Double

    def __cinit__(self, length=None):
        if length is not None:
            DoubleArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_double(value))
    
    def copy(self):
        retval = DoubleArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

# END INJECTION

# START INJECTION | tmpl_record_member

cdef class BoolRecordMember(RecordMemberBase):

    cdef h_rfield_bool_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

    def declare(self):
        self._handle = h_mbool_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: self._handle.write_initial(self._initial_value)

   # def ensure_type(self):
   #     # TODO: For Const* too
   #     # managed_type<T>::ensure_complete()
   #     pass


cdef class ConstBoolRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_bool_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def declare(self):
        self._handle = h_const_mbool_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: write_initial?

cdef class ByteRecordMember(RecordMemberBase):

    cdef h_rfield_byte_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

    def declare(self):
        self._handle = h_mbyte_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: self._handle.write_initial(self._initial_value)

   # def ensure_type(self):
   #     # TODO: For Const* too
   #     # managed_type<T>::ensure_complete()
   #     pass


cdef class ConstByteRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_byte_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def declare(self):
        self._handle = h_const_mbyte_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: write_initial?

cdef class UByteRecordMember(RecordMemberBase):

    cdef h_rfield_ubyte_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

    def declare(self):
        self._handle = h_mubyte_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: self._handle.write_initial(self._initial_value)

   # def ensure_type(self):
   #     # TODO: For Const* too
   #     # managed_type<T>::ensure_complete()
   #     pass


cdef class ConstUByteRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_ubyte_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def declare(self):
        self._handle = h_const_mubyte_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: write_initial?

cdef class ShortRecordMember(RecordMemberBase):

    cdef h_rfield_short_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

    def declare(self):
        self._handle = h_mshort_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: self._handle.write_initial(self._initial_value)

   # def ensure_type(self):
   #     # TODO: For Const* too
   #     # managed_type<T>::ensure_complete()
   #     pass


cdef class ConstShortRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_short_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def declare(self):
        self._handle = h_const_mshort_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: write_initial?

cdef class UShortRecordMember(RecordMemberBase):

    cdef h_rfield_ushort_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

    def declare(self):
        self._handle = h_mushort_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: self._handle.write_initial(self._initial_value)

   # def ensure_type(self):
   #     # TODO: For Const* too
   #     # managed_type<T>::ensure_complete()
   #     pass


cdef class ConstUShortRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_ushort_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def declare(self):
        self._handle = h_const_mushort_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: write_initial?

cdef class IntRecordMember(RecordMemberBase):

    cdef h_rfield_int_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

    def declare(self):
        self._handle = h_mint_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: self._handle.write_initial(self._initial_value)

   # def ensure_type(self):
   #     # TODO: For Const* too
   #     # managed_type<T>::ensure_complete()
   #     pass


cdef class ConstIntRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_int_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def declare(self):
        self._handle = h_const_mint_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: write_initial?

cdef class UIntRecordMember(RecordMemberBase):

    cdef h_rfield_uint_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

    def declare(self):
        self._handle = h_muint_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: self._handle.write_initial(self._initial_value)

   # def ensure_type(self):
   #     # TODO: For Const* too
   #     # managed_type<T>::ensure_complete()
   #     pass


cdef class ConstUIntRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_uint_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def declare(self):
        self._handle = h_const_muint_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: write_initial?

cdef class LongRecordMember(RecordMemberBase):

    cdef h_rfield_long_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

    def declare(self):
        self._handle = h_mlong_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: self._handle.write_initial(self._initial_value)

   # def ensure_type(self):
   #     # TODO: For Const* too
   #     # managed_type<T>::ensure_complete()
   #     pass


cdef class ConstLongRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_long_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def declare(self):
        self._handle = h_const_mlong_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: write_initial?

cdef class ULongRecordMember(RecordMemberBase):

    cdef h_rfield_ulong_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

    def declare(self):
        self._handle = h_mulong_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: self._handle.write_initial(self._initial_value)

   # def ensure_type(self):
   #     # TODO: For Const* too
   #     # managed_type<T>::ensure_complete()
   #     pass


cdef class ConstULongRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_ulong_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def declare(self):
        self._handle = h_const_mulong_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: write_initial?

cdef class FloatRecordMember(RecordMemberBase):

    cdef h_rfield_float_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

    def declare(self):
        self._handle = h_mfloat_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: self._handle.write_initial(self._initial_value)

   # def ensure_type(self):
   #     # TODO: For Const* too
   #     # managed_type<T>::ensure_complete()
   #     pass


cdef class ConstFloatRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_float_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def declare(self):
        self._handle = h_const_mfloat_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: write_initial?

cdef class DoubleRecordMember(RecordMemberBase):

    cdef h_rfield_double_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

    def declare(self):
        self._handle = h_mdouble_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: self._handle.write_initial(self._initial_value)

   # def ensure_type(self):
   #     # TODO: For Const* too
   #     # managed_type<T>::ensure_complete()
   #     pass


cdef class ConstDoubleRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_double_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def declare(self):
        self._handle = h_const_mdouble_t().field_in(_get_record_type_handle(self._parent.type_declaration), self._type_ident, True)
        # TODO: write_initial?

# END INJECTION
