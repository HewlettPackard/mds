# -*- coding: utf-8 -*-
"""
Managed Data Structures
Copyright Â© 2017 Hewlett Packard Enterprise Development Company LP.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

As an exception, the copyright holders of this Library grant you permission
to (i) compile an Application with the Library, and (ii) distribute the
Application containing code generated by the Library and added to the
Application during this compilation process under terms of your choice,
provided you also meet the terms and conditions of the Application license.
"""

from itertools import chain

from libcpp cimport bool
from libcpp.string cimport string

from mds.core.api_strings cimport *
from mds.core.api_arrays cimport *
from mds.core.api_records cimport *
from mds.core.api_helpers cimport initialize_base_task
from mds.core.api_namespaces cimport *
from mds.core.api_primitives cimport *

import mds
from mds import TypeInfo

import threading

__LOCAL = threading.local()
__LOCAL.token_stack = []

initialize_base_task()

# =========================================================================
#  Base
# =========================================================================

cdef class MDSObject(object):

    def _throw_const_error(self):
        raise ConstError("Can't assign value to const field.")

    # TODO: memoize?
    property is_const:
        def __get__(self):
            return self.__class__.__name__.startswith("Const")

    property is_null:
        def __get__(self):
            pass  # TODO

# =========================================================================
#  Errors & Exceptions
# =========================================================================

cdef class UnderflowError(Exception):
    pass

cdef class ConstError(Exception):
    pass

# =========================================================================
#  Managed Values
# =========================================================================

cdef class MDSPrimitiveBase(MDSObject):
    # TODO: Use the API's math operation to ensure atomicity

    def __int__(self):
        pass

    def __long__(self):
        pass

    def __float__(self):
        pass

    def _sanitize(self, value):
        return value

    def _to_python(self):
        raise NotImplementedError("Specialization required.")

    def _to_mds(self):
        raise NotImplementedError("Specialization required.")

    property python_copy:
        def __get__(self):
            raise NotImplementedError("Specialization required.")


cdef class MDSIntPrimitiveBase(MDSPrimitiveBase):

    def _sanitize(self, value):
        if isinstance(value, float):
            value = int(value)
        elif not isinstance(value, int):
            t = type(value)
            raise TypeError('Unable to parse value of type `{t}`')

        if value < self.MIN:
            raise UnderflowError(f"Can't fit {value} in container {self.dtype}")
        elif value > self.MAX:
            raise OverflowError(f"Can't fit {value} in container {self.dtype}")

        return value

    property MIN:
        def __get__(self):
            raise NotImplementedError("Integer specialization required.")

    property MAX:
        def __get__(self):
            raise NotImplementedError("Integer specialization required.")


cdef class MDSFloatPrimitiveBase(MDSPrimitiveBase):
    pass

# =========================================================================
#  Arrays
# =========================================================================

cdef class MDSArrayBase(MDSObject):
    
    def _index_bounds_check(self, index):
         # TODO: Need to handle slices. Should this be a new array?
        cdef long l = <long> len(self)

        if index >= l or index < -l:
            raise IndexError('list index out of range')

        if index < 0:
            index += l

        return index

    def _to_python(self, index):
        raise NotImplementedError('Specialization of MDSList required') 

    def _to_mds(self, index, value):
        raise NotImplementedError('Specialization of MDSList required') 

    def __getitem__(self, index):
        index = self._index_bounds_check(index)
        return self._to_python(index)

    def __setitem__(self, index, value):
        index = self._index_bounds_check(index)
        self._to_mds(index, value)

    def __iter__(self):
        return NotImplemented # TODO Implement this

    def __next__(self):
        return NotImplemented # TODO Implement this

    def __len__(self):
        raise NotImplementedError('Specialization of MDSArrayBase required') 

    def index(self, start=None, end=None):
        return NotImplemented # TODO Implement this

    def count(self, value):
        # TODO: Handle len 0, should this even be instantiable?
        # TODO: Bool still a str-literal here
        if not isinstance(value, type(self[0])):
            raise TypeError("value to be searched for must match list-type `bool`")

        cdef:
            size_t i = 0, l = len(self), c = 0

        for i in range(l):
            if self[i] == value:
                c += 1

        return c

    def sort(self):
        return NotImplemented # TODO Implement this

    def reverse(self):
        return NotImplemented # TODO Implement this

    def copy(self):
        raise NotImplementedError('Specialization of MDSArrayBase required')
 
    property dtype:
        def __get__(self):
            raise NotImplementedError('Specialization of MDSArrayBase required')


cdef class MDSIntArrayBase(MDSArrayBase):

    def _numeric_bounds_check(self, value):
        """
        TODO: This needs to check the bounds of the different int sizes in MDS.
        """
        raise NotImplementedError('Requires a type-specific instantiation')

    def __setitem__(self, index, value):
        index = self._index_bounds_check(index)
        value = self._numeric_bounds_check(value)
        self._to_mds(index, value)

    property dtype:
        def __get__(self):
            return type(1)


cdef class MDSFloatArrayBase(MDSArrayBase):

    property dtype:
        def __get__(self):
            return type(1.0)

# =========================================================================
#  Records
# =========================================================================

cdef class MDSRecordFieldMemberPair(object):
    """
    This is an internal class to deal with the fact that we don't have
    static variables per-se in Python, and certainly not in Cython, so
    we pair the instantiated RecordField with the type of the requested
    RecordMember (whether const or not), to be plugged into derived
    classes
    """
    cdef:
        MDSRecordFieldBase field
        type member

    def __init__(self, field: MDSRecordFieldBase, member: type):
        self.field = field  # derived <- MDSRecordFieldBase
        self.member = member  # type: derived <- MDSRecordMemberBase


# This is where we keep built record types, with the associated Lock
__RECORD_DECLARATION_MUTEX = threading.Lock()
__DECLARED_TYPES = dict()


cdef implant_record_handle(Record record, RecordTypeDeclaration decl):
    cdef const_record_type_handle handle = decl._handle
    record._handle = handle.create_record()


cdef class Record(MDSObject):
    """
    The main Record, allowing complex data-structures using a combination of MDS
    and Python types.

    The MDS schema should be defined in a static method schema() returning a dictionary
    mapping field names (str) to field declarations. Examples are given.

    TODO: implement __getitem__ and __setitem__ to mask the write() read() ops, maybe make this primary?
    """
    cdef managed_record_handle _handle

    def __cinit__(self):
        # This token.create just delegates to type_decl anywa...
        # self._handle = managed_record_handle(token.create())
        implant_record_handle(self, self.type_decl.ensure_created())

    def __init_subclass__(cls, ident: str, **kwargs):
        """
        This is called whenever a subclass of Record comes into scope, this
        provides a couple of nice opportunities:

        1) Ensure the type is properly declared in MDS before an instance
           is called, and bind the type declaration as a static member in
           Python-land
        2) TODO: See if any ambiguous proxies from Namespace are awaiting this
           specific implementation, and deal with that accordingly.
        """
        super().__init_subclass__(**kwargs)
        cls.ident = ident

        # This is the same as rt_decl ... type_decl() in that it instantiates
        # the RecordTypeDeclarion (rt_decl)
        cls.type_decl = RecordTypeDeclaration(cls, cls.schema())
        # This will store a reference in __DECLARED_TYPES in a thread-safe way - CreatorCache?
        cls.type_decl.ensure_created()

    def _register_fields(self) -> None:
        """
        When this subclass was declared, with automagically registered the Record type
        with MDS; in so doing we stored single-instances of the RecordFields we required,
        but type references to the members, as they must be instance-bound.

        This method iterates through that container and updates the object's dict
        to enable dot notation access to the associated MemberRecords

        TODO: When and where should this be called?
        """
        # Stll need to make the RecordMembers and bind them to this instance
        for label, field_member_pair in self.type_decl.get_field_member_pairs().items():
            field, member_t = field_member_pair.field, field_member_pair.member
            self.__dict__[label] = member_t(self)

    @classmethod
    def lookup_in_namespace(cls, ns: Namespace, *args) -> Record:
        if not isinstance(ns, Namespace):
            raise TypeError('Need a `Namespace` object as first argument')

        if not len(args):
            raise KeyError('Need at least one path for the namespace')
    
        record = ns[args]
        retval = cls()
        # TODO: update retval's fields accordingly

        return retval

    @classmethod
    def force(cls) -> None:
        MDSManagedRecordType.ensure_complete(cls)

    @staticmethod
    def schema() -> dict:
        # TODO: Move this to a class param?
        raise TypeError("Derived `Record`s should return a `dict` detailing the schema here.")

    @staticmethod
    def declare_const_field(klass: type) -> MDSRecordFieldMemberPair:
        """
        Delegates to Record.declare_field; could be deleted, but here to map 1:1 to CAPI.
        """
        return Record.declare_field(klass, make_const=True)

    @staticmethod
    def declare_field(klass: type, make_const=False) -> MDSRecordFieldMemberPair:  # const is broken here, not at field level, should be member
        """
        This returns the derived RecordField for the combination of the arguments.

        TODO: This only works for primitives, will need adaptation for {String, Array, Record}
        TODO: String-based hacking isn't neat, should make a dict using the generator,
        but this works for now.

        Args:
            klass:  TypeInfo, obtained from `mds.typing`
            make_const: Bool, whether to make the associated RecordMember const or not
        """
        if not isinstance(klass, TypeInfo):
            raise TypeError("First parameter needs to be a type from `mds.typing`")

        # Now, let's see if it's known and of the correct lineage
        field_t = globals()[klass.title_record_field]
        assert issubclass(field_t, MDSRecordFieldBase)

        if make_const:
            identifier = klass.title_const_record_member
            base = MDSConstRecordMemberBase
        else:
            identifier = klass.title_record_member
            base = MDSRecordMemberBase

        member_t = globals()[identifier]
        assert issubclass(member_t, base)

        # DEBUG
        print(f"?> Making pair {field_t.__name__}, {member_t.__name__}")

        # Unlike the CAPI we return both the instantiated field and a type for the member
        return MDSRecordFieldMemberPair(field=field_t(), member=member_t)


class ExampleRecord(Record, ident="PythonTest::ExampleRecord"):  # TODO => Test
    """
    Descendents of Record should explictly declare an `ident` key/value pair in the
    class descriptor as above; this is how the type will be known to MDS.
    """

    @staticmethod
    def schema():
        """
        This method *must* be overridden in Record-derived classes, and follow the
        following syntax for declaring the record schema.

        Once the class `cls` has come into scope, an instantaited copy of this object
        will be available via cls.type_decl
        """
        return {
            "is_active": Record.declare_const_field(mds.typing.bool),
            "number_of_players": Record.declare_field(mds.typing.ushort)
        }


cdef class MDSManagedRecordType(MDSObject):
    cdef Record _parent

    def __cinit__(self, parent: Record):
        self._parent = parent

    def ensure_created(self) -> MDSConstRecordHandleWrapper:
        return self._parent.type_decl.ensure_created()

    @staticmethod
    def ensure_complete(klass: type) -> MDSConstRecordHandleWrapper:
        return klass.type_decl.ensure_created()

    @staticmethod
    def from_handle(handle: MDSConstRecordHandleWrapper) -> Record:
  # static mds_ptr<R> from_handle(const Record::handle_t &h) {
  #   if (!std::is_abstract<R>::value) {
  #     /*
  #      * If there are no virtual functions we might as well just create
  #      * a new proxy object.  We could cache them, but this is probably
  #      * at least as efficient.
  #      */
  #     return RecordCreator<R>::create_from_handle(h);
  #   } else {
  #     /*
  #      * If there are virtual functions, we need to find the actual type
  #      * for the record.
  #      */
  #     const_handle_t th = h.type();
  #     /*
  #      * If it's ours, we can just create it here.
  #      */
  #     if (th == ManagedType().handle()) {
  #       return RecordCreator<R>::create_from_handle(h);
  #     }
  #     mds_ptr<Record> r = CreatorCache::create(th, h);
  #     /*
  #      * We should be guaranteed of at least finding *this* class.
  #      */
  #     assert(r != nullptr);
  #     return r.static_pointer_cast<R>();
  #   }
  # }

        pass

    def from_core(self, handle: MDSConstRecordHandleWrapper) -> Record:
  # mds_ptr<R> from_core(const Record::handle_t &val) const {
  #   if (val == nullptr) {
  #     return nullptr;
  #   }
  #   return from_handle(val);
  # }
        pass

    def to_core(self):
  # core_api_type to_core(const mds_ptr<R> &val) const {
  #   core_api_type tcv = val == nullptr ? core_api_type { } : val->_handle;
  #   return tcv;
  # }

  # core_api_type to_core(const mds_ptr<const R> &val) const {
  #   return val == nullptr ? core_api_type { } : val->_handle;
  # }
        pass

############################################################# RECORD FIELDS

cdef class MDSRecordFieldBase(MDSObject):
    """
    Base class to wrap around the field_handle_types, analog to CAPI::record_field

    There are no const RecordField, const-ness is handled by RecordMembers
    """

    def __getitem__(self, item):
  # reference operator[](const mds_ptr<R> &r) const {
  #   R::type_decl().ensure_created();
  #   return reference(*this, *r);
  # }

  # reference operator[](R *r) const {
  #   R::type_decl().ensure_created();
  #   return reference(*this, *r);
  # }

  # const_reference operator[](const mds_ptr<const R> &r) const {
  #   R::type_decl().ensure_created();
  #   return const_reference(*this, *r);
  # }

  # const_reference operator[](const R *r) const {
  #   R::type_decl().ensure_created();
  #   return const_reference(*this, *r);
  # }
        pass

    def ensure_type(self):
        pass

    def declare(self, String name, RecordTypeDeclaration rt):
        pass

    # These two, either use them in generated RecordFields and then Members, or
    # use overloaded calls in Members directly, then delete these.
    @classmethod
    def from_core(cls, val):
        pass

    @classmethod
    def to_core(cls, val):
        pass


cdef class UShortRecordField(MDSRecordFieldBase):  # => Generator
    cdef:
        h_rfield_ushort_t _handle
        h_mushort_t mtype
  # using handle_type = typename managed_type<T>::field_handle_type;
  # handle_type _handle;
    # using mtype = managed_type<T>;
    # using value_type = typename mtype::mds_type;
    # using core_api_type = typename mtype::core_api_type;  


    def ensure_type(self):
    # managed_type<T>::ensure_complete(); // h_mushort_t?
        pass

    def declare(self, String name, RecordTypeDeclaration rt):
        assert self._handle.is_null()
        self._handle = h_mushort_t().field_in(rt._declared_type, name._ish, True)


# TODO: Work through some Const*RecordField examples

######################################################################### REFERENCES

cdef class MDSConstRecordFieldReferenceBase(MDSObject):
    cdef:
        managed_record_handle _record_handle

    def read(self):
        pass

    def peek(self):
        pass

    def write(self, value):
        self._throw_const_error()


cdef class MDSRecordFieldReferenceBase(MDSConstRecordFieldReferenceBase):

    def write(self, value):
        pass

  # static value_type from_core(const core_api_type &val) {
  #   return mtype().from_core(val);
  # }

  # /*
  #  * When we're and array field, the API read methods only get it as the base
  #  * array pointer, so we need to downcast.  This should be safe
  #  */
  # template<typename U = T, typename = std::enable_if_t<is_mds_array<U>::value>>
  # static value_type from_core(const api::managed_array_base_handle &handle) {
  #   using elt_type = typename mtype::elt_type;
  #   core_api_type h(handle.pointer()->template downcast<elt_type::kind>(),
  #                   handle.view());
  #   return from_core(h);
  # }

  # static core_api_type to_core(const value_type &val) {
  #   return mtype().to_core(val);
  # }

cdef class ConstBoolRecordFieldReference(MDSConstRecordFieldReferenceBase):   # => Generator
    cdef:
        h_const_rfield_bool_t _field_handle
        Record _record

    def __cinit__(self, MDSRecordFieldBase field, Record record):
        self._record = record
        self._field_handle = h_const_rfield_bool_t(field._handle)
        self._record_handle = managed_record_handle(record._handle)

    def read(self):
        cdef bool retval = self._field_handle.frozen_read(self._record_handle)
        return from_core_bool(retval)

    def peek(self):
        cdef bool retval = self._field_handle.free_read(self._record_handle)
        return from_core_bool(retval)


cdef class BoolRecordFieldReference(ConstBoolRecordFieldReference):  # => Generator
    
    def write(self, bint value):
        self._field_handle.write(self._record_handle, to_core_bool(value));


cdef class ConstUShortRecordFieldReference(MDSConstRecordFieldReferenceBase):  # => Generator
    cdef:
        h_const_rfield_ushort_t _field_handle
        Record _record

    def __cinit__(self, MDSRecordFieldBase field, Record record):
        self._record = record
        self._field_handle = h_const_rfield_ushort_t(field._handle)
        self._record_handle = managed_record_handle(record._handle)

    def read(self):
        cdef uint16_t retval = self._field_handle.frozen_read(self._record_handle)
        return from_core_uint16_t(retval)

    def peek(self):
        cdef uint16_t retval = self._field_handle.free_read(self._record_handle)
        return from_core_uint16_t(retval)


cdef class UShortRecordFieldReference(ConstUShortRecordFieldReference):  # => Generator
    
    def write(self, uint16_t value):
        self._field_handle.write(self._record_handle, to_core_uint16_t(value));

    def __iadd__(self, other):
        self._field_handle.add(self._record_handle, to_core_uint16_t(other))

    def __isub__(self, other):
        self._field_handle.sub(self._record_handle, to_core_uint16_t(other))

    def __imul__(self, other):
        self._field_handle.mul(self._record_handle, to_core_uint16_t(other))

    def __idiv__(self, other):
        self._field_handle.div(self._record_handle, to_core_uint16_t(other))


############################################################# RECORD MEMBERS

cdef class MDSRecordMemberBase(MDSObject):
    cdef:
        Record _enclosing

    # using value_type = typename record_field<R,T>::value_type;

    def __cinit__(self, Record record, other=None):
  # record_member()
  #     : _enclosing(*typed_rc_token<R>::being_constructed()) {
  #   assert(&_enclosing != nullptr);
  # }
        self._enclosing = record

        # Delegate this checking to the write() method
  # explicit record_member(const value_type &v)
  #     : record_member() {
  #   write(v);
  # }

  # explicit record_member(const record_member &other)
  #     : record_member() {
  #   write(other);
  # }


        if other is not None:
            self.write(other)

    def _field_ref(self):
        return MDSRecordFieldBase()[self]

    def read(self):
        pass

    def peek(self):
        pass

    def write(self, value):
        pass


cdef class UShortRecordMember(MDSRecordMemberBase):  # => Generator

    def read(self):
        return self._field_ref().read()

    def peek(self):
        return self._field_ref().peek()

    def write(self, uint16_t value):
        self._field_ref().write(value);

    def __iadd__(self, other):
        ref = self._field_ref()
        ref += other

    def __isub__(self, other):
        ref = self._field_ref()
        ref -= other

    def __imul__(self, other):
        ref = self._field_ref()
        ref *= other

    def __idiv__(self, other):
        ref = self._field_ref()
        ref /= other


cdef class MDSConstRecordMemberBase(MDSObject):
    cdef:
        Record _enclosing
        bint _is_cached
 # public:
 #  using value_type = typename record_field<R,T>::value_type;
 # private:
 #  R &_enclosing;
 #  mutable value_type _cached_val;
 #  mutable bool _is_cached;

    def _field_ref(self):
        return MDSRecordFieldBase()[self]

    def __cinit__(self, other):
  # record_const_member()
  #     : _enclosing(*typed_rc_token<R>::being_constructed()),
  #       _is_cached { false } {
  #   assert(&_enclosing != nullptr);
  # }

  # explicit record_const_member(const value_type &v)
  #     : _enclosing(*typed_rc_token<R>::being_constructed()),
  #       _cached_val(_field_ref().write(v)),
  #       _is_cached { true } {
  # }

  # explicit record_const_member(const record_const_member &other)
  #     : record_const_member(other.read()) {
  # }
        if other is not None:
            pass

    def write(self, value):
        self._throw_const_error()


cdef class ConstUShortRecordMember(MDSConstRecordMemberBase):  # => Generator
    cdef:
        uint16_t _cached_val

    def read(self):
        if not self._is_cached:
            self._cached_val = self._field_ref.read()
            self._is_cached = True

        return self._cached_val

    def peek(self):
        return self.read()


######################################################### RECORD TYPE DECLARATIONS

cdef class RecordFieldDeclaration(object):
    """
    This could probably be avoided, but it's copying CAPI
    """
    cdef:
        String name
        MDSRecordFieldBase field

    def __cinit__(self, String name, MDSRecordFieldBase field):
        self.name = name
        self.field = field


cdef class MDSRecordHandleWrapper(object):
    cdef:
        record_type_handle _handle


cdef class MDSConstRecordHandleWrapper(object):
    cdef:
        const_record_type_handle _handle


cdef emplace_handle(record_type_handle wrapped):
    wrapper = MDSRecordHandleWrapper()
    wrapper._handle = wrapped
    return wrapper

cdef emplace_const_handle(const_record_type_handle wrapped):
    wrapper = MDSConstRecordHandleWrapper()
    wrapper._handle = wrapped
    return wrapper


cdef class RecordTypeDeclaration(object):
    cdef:
        list _field_decls
        dict _field_member_pairs
        const record_type_handle _declared_type  # Can I do const here? <- CAPI
        const_record_type_handle _created_type
        type _cls

    def __cinit__(self, cls: type, fields: dict):
        # TODO: Get rid of fields, invole cls.schema() directly and delegate here
        # TODO: This assumes singular inheritance path for Record, could probably do getmro...
        self._declared_type = self.declare(cls.ident, cls.__bases__[0])
        self._cls = cls
        self._field_member_pairs = fields
        self.note_fields(fields)

    def get_field_member_pairs(self) -> dict:
        return self._field_member_pairs

    def declare(self, name: String, parent: type) -> MDSRecordHandleWrapper:
        """
        The logic of this, from the CAPI, is that we want to declare a type
        of name `name`, and we check its ancestor;

        1) If the ancestor is Record, just declare it.
        2) If the direct ancestor is not Record, make sure that
           itself is an instance thereof

        TODO: s should be a parameterized managed_type<R>?
        """
        if parent is None or parent is Record:
            return emplace_handle(record_type_handle.declare(name._ish))

        assert issubclass(parent, Record), "Super type not a record type"

        # As soon as `s` came into scope, it should have registered its type,
        # so this is unnecessary, but left in for posterity.
        sp = parent.type_decl.ensure_created()  # MDSConstRecordHandleWrapper
        return emplace_handle(record_type_handle.declare(name._ish, sp._handle))

    def note_fields(self, fields: dict) -> None:
        for label, field_member_pair in fields.items():
            self._field_decls.append(
                RecordFieldDeclaration(
                    String(label),  # We want to grab the interned_string_handle later
                    field_member_pair.field
                )
            )

    def declare_fields(self) -> None:
        for fd in self._field_decls:
            fd.field.declare(fd.name, self)

    def ensure_field_types(self) -> None:
        for fd in self._field_decls:
            fd.field.ensure_type()

    def ensure_created(self) -> MDSConstRecordHandleWrapper:
        if not self._cls.ident in __DECLARED_TYPES:
            __RECORD_DECLARATION_MUTEX.acquire()

            # Ensure no one else has beat us to the punch (call_once)
            if not self._cls.ident in __DECLARED_TYPES:
                self.declare_fields()
                self._created_type = const_record_type_handle(self._declared_type.ensure_created())
                # We want to keep a copy of this alive so we don't have to rebuild it
                # MDSRecordCreator.register_type(self)
                self.ensure_field_types()
                __DECLARED_TYPES[self._cls.ident] = self

            __RECORD_DECLARATION_MUTEX.release()

        return emplace_const_handle(__DECLARED_TYPES[self._cls.ident]._created_type)


# =========================================================================
#  Strings
# =========================================================================


cdef class String(MDSObject):
    """
    This class provides the functionality expected from the native str type,
    but backed by MDS. As with str, Strings are immutable.
    """

    cdef:
        managed_string_handle _handle
        interned_string_handle _ish
        int __iter_idx

    def __cinit__(self, value=None):
        self._ish = convert_py_to_ish(value) 
        self._handle = managed_string_handle(self._ish)
        self.__iter_idx = 0

    def __len__(self):
        return self._handle.length()

    def __hash__(self):
        return self._handle.hash1()

    def __iter__(self):
        self.__iter_idx = 0
        return self

    def __next__(self):
        if self.__iter_idx < len(self):
            retval = self[self.__iter_idx]
            self.__iter_idx += 1
            return retval
        else:
            raise StopIteration

    def __str__(self):
        return <str> self._handle.utf8().decode("utf-8")

    def __repr__(self):
        return "'{}'".format(str(self))

    def __getitem__(self, item):
        cdef:
            string s
            int i
            char_type c

        if isinstance(item, int):
            c = self._handle.at(item)
            u = chr(c)
            return u
        elif isinstance(item, slice):
            # TODO: Check this
            s.reserve((item.stop - item.start) // item.step)

            for i in range(start=item.start, stop=item.stop, step=item.step):
                s.push_back(self._handle.at(i))

            return String(s)

        raise TypeError(
            "list indices must be integers or slices, not {}".format(
                type(item)
            )
        )

    def __add__(self, other):
        """
        Concatenates this string with another, returns this as a new String
        """
        # TODO: Could probably open this to [str, bytes] too.
        cdef:
            string s
            str c

        if isinstance(other, String):       
            s.reserve(<size_t> (len(self) + len(other)))

            # Chain the iterators to avoid any string copying
            for c in chain(iter(self), iter(other)):
                s.push_back(ord(c))  # Need as an int for char

            return String(s)

        raise TypeError("must be String")

    def __mul__(self, other):
        """
        Internal method to perform String multiplication without overhead
        """
        cdef:
            string s
            str c
            int it, l = len(self)

        if isinstance(other, int):
            s.reserve(l * other)

            for it in range(other):
                for c in self:
                    s.push_back(ord(c))

            return String(<unicode> s.decode("utf-8"))

        raise TypeError(
            "can't multiply sequence by non-int of type 'String'"
        )

    def __rmul__(self, other):
        pass

    def __mod__(self, other):
        pass

    def __rmod__(self, other):
        pass

    def __richcmp__(a, b, op):
        if op == 0:    # <
            return a._handle < b._handle
        elif op == 1:  # <=
            return a._handle <= b._handle
        elif op == 2:  # ==
            return a._handle == b._handle
        elif op == 3:  # !=
            return a._handle != b._handle
        elif op == 4:  # >
            return a._handle > b._handle
        elif op == 5:  # >=
            return a._handle >= b._handle

    def __sizeof__(self):
        return self._handle.size()

    # TODO: Write equivalents that use the MDS-stored data

    def capitalize(self):
        return String(str(self).capitalize())

    def casefold(self):
        return String(str(self).casefold())

    def center(self, *args, **kwargs):
        return String(str(self).center(*args, **kwargs))

    # TODO: encode(encoding="utf-8", errors="strict")

    def endswith(self, *args, **kwargs):
        return str(self).endswith(*args, **kwargs)

    def expandtabs(self, *args, **kwargs):
        return String(str(self).expandtabs(*args, **kwargs))

    def find(self, *args, **kwargs):
        return str(self).find(*args, **kwargs)

    def format(self, *args, **kwargs):
        return String(str(self).format(*args, **kwargs))

    def format_map(self, *args, **kwargs):
        return String(str(self).format_map(*args, **kwargs))

    def index(self, *args, **kwargs):
        return str(self).index(*args, **kwargs)

    def isalnum(self, *args, **kwargs):
        return str(self).isalnum(*args, **kwargs)

    def isalpha(self, *args, **kwargs):
        return str(self).isalpha(*args, **kwargs)

    def isdecimal(self, *args, **kwargs):
        return str(self).isdecimal(*args, **kwargs)

    def isdigit(self, *args, **kwargs):
        return str(self).isdigit(*args, **kwargs)
    
    def isidentifier(self, *args, **kwargs):
        return str(self).isidentifier(*args, **kwargs)
    
    def islower(self, *args, **kwargs):
        return str(self).islower(*args, **kwargs)

    def isnumeric(self, *args, **kwargs):
        return str(self).isnumeric(*args, **kwargs)

    def isprintable(self, *args, **kwargs):
        return str(self).isprintable(*args, **kwargs)

    def isspace(self, *args, **kwargs):
        return str(self).isspace(*args, **kwargs)

    def istitle(self, *args, **kwargs):
        return str(self).istitle(*args, **kwargs)

    def isupper(self, *args, **kwargs):
        return str(self).isupper(*args, **kwargs)

    def join(self, *args, **kwargs):
        return String(str(self).join(*args, **kwargs))

    def ljust(self, *args, **kwargs):
        return String(str(self).ljust(*args, **kwargs))

    def lower(self, *args, **kwargs):
        return String(str(self).lower(*args, **kwargs))

    def lstrip(self, *args, **kwargs):
        return String(str(self).lstrip(*args, **kwargs))

    def partition(self, *args, **kwargs):
        return tuple([String(x) for x in str(self).partition(*args, **kwargs)])

    def replace(self, *args, **kwargs):
        return String(str(self).replace(*args, **kwargs))

    def rfind(self, *args, **kwargs):
        return str(self).rfind(*args, **kwargs)

    def rindex(self, *args, **kwargs):
        return str(self).rindex(*args, **kwargs)

    def rjust(self, *args, **kwargs):
        return String(str(self).rjust(*args, **kwargs))

    def rpartition(self, *args, **kwargs):
        return tuple([String(x) for x in str(self).rpartition(*args, **kwargs)])

    def rsplit(self, *args, **kwargs):
        return [String(x) for x in str(self).rsplit(*args, **kwargs)]

    def rstrip(self, *args, **kwargs):
        return String(str(self).rstrip(*args, **kwargs))

    def split(self, *args, **kwargs):
        return [String(x) for x in str(self).split(*args, **kwargs)]

    def splitlines(self, *args, **kwargs):
        return [String(x) for x in str(self).split(*args, **kwargs)]

    def startswith(self, *args, **kwargs):
        return str(self).startswith(*args, **kwargs)

    def strip(self, *args, **kwargs):
        return String(str(self).strip(*args, **kwargs))
    
    def swapcase(self, *args, **kwargs):
        return String(str(self).swapcase(*args, **kwargs))

    def title(self, *args, **kwargs):
        return String(str(self).title(*args, **kwargs))

    # TODO: translate

    def upper(self, *args, **kwargs):
        return String(str(self).upper(*args, **kwargs))

    def zfill(self, *args, **kwargs):
        return String(str(self).zfill(*args, **kwargs))

# =========================================================================
#  Namespace
# =========================================================================


cdef class Namespace(MDSObject):

    cdef namespace_handle _handle

    def __setitem__(self, key, value):
        cdef:
            interned_string_handle ish = convert_py_to_ish(key)
            uint16_t val = value

        # TODO: Restrict value to MDSObject, or just do smallest-fitting-elem?
        # if not issubclass(type(value), MDSObject):
        #     raise TypeError('Cannot commit a non-MDS type into a MDS namespace')

        # TODO: get the boxed item to release its wrapped value into bind...
        self._handle.bind(ish, val)

    def __getitem__(self, key):
        # TODO: Need some type inference here, require explicit third param?
        cdef:
            uint16_t retval
            interned_string_handle ish = convert_py_to_ish(key)

        retval = self._handle.lookup(ish, managed_ushort_type_handle())
        return retval

    def create_child(self, child_id, bint create_if_missing=True):
        cdef:
            interned_string_handle ish = convert_py_to_ish(child_id)
            bool cim = <bool> create_if_missing
        
        return Namespace_Init(self._handle.child_namespace(ish, cim))

    @staticmethod
    def from_path(path):
        pass

    @staticmethod
    def get_current():
        pass  # TODO: mds_namespace::current()

    @staticmethod
    def get_global():
        return Namespace_Init(handle=namespace_handle._global())

    property is_root:
        def __get__(self):
            # TODO: Implement this
            pass

    property parent:
        def __get__(self):
            # TODO: Implement this
            pass


cdef inline Namespace_Init(namespace_handle handle):
    initialize_base_task()
    result = Namespace()
    result._handle = handle
    return result

# =========================================================================
#  Helpers
# =========================================================================

cpdef inline is_record_type(obj):
    return issubclass(obj, Record)

# TODO: These record_creator methods
cdef inline _register_type(const_record_type_handle crht):
    pass

cdef inline _create_from_handle(managed_record_handle mrh):
    pass

cdef inline record_type_handle _declare_record_type(str ident):
    return record_type_handle.declare(convert_py_to_ish(ident))

# =========================================================================
#  Primitives
# =========================================================================

# START INJECTION | tmpl_concrete_array

cdef class Bool(MDSPrimitiveBase):

    cdef mv_bool _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    

cdef inline BoolArray_Inplace(BoolArray cls, size_t length):
    cls._handle = create_bool_marray(length)

cdef class BoolArray(MDSArrayBase):

    cdef h_marray_bool_t _handle
    _primitive = Bool

    def __cinit__(self, length=None):
        if length is not None:
            BoolArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_bool(value))
    
    def copy(self):
        retval = BoolArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

    property dtype:
        def __get__(self):
            return type(True)

cdef class Byte(MDSIntPrimitiveBase):

    cdef mv_byte _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return -128

    property MAX:
        def __get__(self):
            return 127 


cdef inline ByteArray_Inplace(ByteArray cls, size_t length):
    cls._handle = create_byte_marray(length)

cdef class ByteArray(MDSIntArrayBase):

    cdef h_marray_byte_t _handle
    _primitive = Byte

    def __cinit__(self, length=None):
        if length is not None:
            ByteArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_byte(value))
    
    def copy(self):
        retval = ByteArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class UByte(MDSIntPrimitiveBase):

    cdef mv_ubyte _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 255 


cdef inline UByteArray_Inplace(UByteArray cls, size_t length):
    cls._handle = create_ubyte_marray(length)

cdef class UByteArray(MDSIntArrayBase):

    cdef h_marray_ubyte_t _handle
    _primitive = UByte

    def __cinit__(self, length=None):
        if length is not None:
            UByteArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_ubyte(value))
    
    def copy(self):
        retval = UByteArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class Short(MDSIntPrimitiveBase):

    cdef mv_short _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return -32768

    property MAX:
        def __get__(self):
            return 32767 


cdef inline ShortArray_Inplace(ShortArray cls, size_t length):
    cls._handle = create_short_marray(length)

cdef class ShortArray(MDSIntArrayBase):

    cdef h_marray_short_t _handle
    _primitive = Short

    def __cinit__(self, length=None):
        if length is not None:
            ShortArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_short(value))
    
    def copy(self):
        retval = ShortArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class UShort(MDSIntPrimitiveBase):

    cdef mv_ushort _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 65535 


cdef inline UShortArray_Inplace(UShortArray cls, size_t length):
    cls._handle = create_ushort_marray(length)

cdef class UShortArray(MDSIntArrayBase):

    cdef h_marray_ushort_t _handle
    _primitive = UShort

    def __cinit__(self, length=None):
        if length is not None:
            UShortArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_ushort(value))
    
    def copy(self):
        retval = UShortArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class Int(MDSIntPrimitiveBase):

    cdef mv_int _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return -2147483648

    property MAX:
        def __get__(self):
            return 2147483647 


cdef inline IntArray_Inplace(IntArray cls, size_t length):
    cls._handle = create_int_marray(length)

cdef class IntArray(MDSIntArrayBase):

    cdef h_marray_int_t _handle
    _primitive = Int

    def __cinit__(self, length=None):
        if length is not None:
            IntArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_int(value))
    
    def copy(self):
        retval = IntArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class UInt(MDSIntPrimitiveBase):

    cdef mv_uint _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 4294967295 


cdef inline UIntArray_Inplace(UIntArray cls, size_t length):
    cls._handle = create_uint_marray(length)

cdef class UIntArray(MDSIntArrayBase):

    cdef h_marray_uint_t _handle
    _primitive = UInt

    def __cinit__(self, length=None):
        if length is not None:
            UIntArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_uint(value))
    
    def copy(self):
        retval = UIntArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class Long(MDSIntPrimitiveBase):

    cdef mv_long _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return -9223372036854775808

    property MAX:
        def __get__(self):
            return 9223372036854775807 


cdef inline LongArray_Inplace(LongArray cls, size_t length):
    cls._handle = create_long_marray(length)

cdef class LongArray(MDSIntArrayBase):

    cdef h_marray_long_t _handle
    _primitive = Long

    def __cinit__(self, length=None):
        if length is not None:
            LongArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_long(value))
    
    def copy(self):
        retval = LongArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class ULong(MDSIntPrimitiveBase):

    cdef mv_ulong _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 18446744073709551615 


cdef inline ULongArray_Inplace(ULongArray cls, size_t length):
    cls._handle = create_ulong_marray(length)

cdef class ULongArray(MDSIntArrayBase):

    cdef h_marray_ulong_t _handle
    _primitive = ULong

    def __cinit__(self, length=None):
        if length is not None:
            ULongArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_ulong(value))
    
    def copy(self):
        retval = ULongArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class Float(MDSFloatPrimitiveBase):

    cdef mv_float _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    

cdef inline FloatArray_Inplace(FloatArray cls, size_t length):
    cls._handle = create_float_marray(length)

cdef class FloatArray(MDSFloatArrayBase):

    cdef h_marray_float_t _handle
    _primitive = Float

    def __cinit__(self, length=None):
        if length is not None:
            FloatArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_float(value))
    
    def copy(self):
        retval = FloatArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class Double(MDSFloatPrimitiveBase):

    cdef mv_double _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    

cdef inline DoubleArray_Inplace(DoubleArray cls, size_t length):
    cls._handle = create_double_marray(length)

cdef class DoubleArray(MDSFloatArrayBase):

    cdef h_marray_double_t _handle
    _primitive = Double

    def __cinit__(self, length=None):
        if length is not None:
            DoubleArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_double(value))
    
    def copy(self):
        retval = DoubleArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

# END INJECTION

# START INJECTION | tmpl_record_member
# END INJECTION
