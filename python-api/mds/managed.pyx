# -*- coding: utf-8 -*-
"""
Managed Data Structures
Copyright Â© 2017 Hewlett Packard Enterprise Development Company LP.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

As an exception, the copyright holders of this Library grant you permission
to (i) compile an Application with the Library, and (ii) distribute the
Application containing code generated by the Library and added to the
Application during this compilation process under terms of your choice,
provided you also meet the terms and conditions of the Application license.
"""

from itertools import chain

from libcpp cimport bool
from libcpp.string cimport string

from mds.core.api_strings cimport *
from mds.core.api_arrays cimport *
from mds.core.api_records cimport *
from mds.core.api_helpers cimport initialize_base_task
from mds.core.api_namespaces cimport *
from mds.core.api_primitives cimport *

from mds.typing import Types, TypeInfo

initialize_base_task()

# =========================================================================
#  Errors & Exceptions
# =========================================================================

cdef class UnderflowError(Exception):
    pass

cdef class ConstError(Exception):
    pass

# =========================================================================
#  Records
# =========================================================================

cdef class Record(MDSObject):
    """

    Development Notes:
    * skipped force -- not sure when this would be needed
    * not implemented token yet -- unsure why this is needed, for forward()? Check JAPI
    """

    cdef:
        RecordTypeDeclaration __type_decl
        RecordToken __tok
        managed_record_handle _handle
        dict __field_decls

    def __init__(self):
        if not hasattr(self, '_ident'):
            raise TypeError('Record subclasses must have a static `_ident` type name')

        # Working on the assumption this is called at the end:
        self.__type_decl = RecordTypeDeclaration(self.ident, self, self.__field_decls)

    def __getattr__(self, key):
        try:
            return getattr(self.__type_decl, key).read()
        except:
            return super().__getattr__(key)

    def __setattr__(self, key, value):
        try:
            getattr(self.__type_decl, key).write(value)
        except:
            super().__setattr__(key, value)

    def _register_field(self, klass, str label, bint make_const=False, initial_value=None):
        self.__field_decls[label] = record_member_factory(self, klass, make_const, initial_value)

# mds_record(const rc_token &tok, handle_type &&h)
#     : _handle { std::move(h) } {
#   tok.cache_shared(this);
# }
#
# explicit mds_record(const rc_token &tok)
#     : _handle(tok.create()) {
#   /*
#    * By creating and caching a shared ptr, we make it possible
#    * for user ctors to call this_as_mds_ptr(), which requires
#    * shared_from_this(), which requires there to be an active
#    * shared pointer.
#    */
#   tok.cache_shared(this);
# }

    # NOTE Disabled until Cython 0.27
    # def __eq__(self, other):
    #     return self._handle == other._handle

    def bind_to_namespace(self, ns, *args):
        #template<typename First, typename ...Cpts>
        #void bind_in(const mds_ptr<mds_namespace> &ns, First &&first,
        #            Cpts &&...cpts) const {
        # ns->at(std::forward<First>(first), std::forward<Cpts>(cpts)...)
        #     .template as<mds_record>().bind(THIS_RECORD);

        pass

    @classmethod
    def lookup_in(cls, ns, *args):
        if not len(args):
            raise KeyError('Need at least one path for the namespace')
    
        root = ns

        if len(args) > 1:
            for arg in args[:-1]:
                try:
                    root = ns[arg]
                except:
                    raise KeyError(f'Couldn\'t find key {arg}')

        retval = cls()
        # Now we know that root[args[-1]] will be the record val
        # TODO: update retval's fields accordingly

        return retval
   
    @classmethod
    def lookup_name(cls, *args):
        return cls.lookup_in(Namespace.get_current(), *args)

    property ident:
        def __get__(self):
            return self._ident
    
    property type_decl:
        def __get__(self):
            return self.__type_decl

# START INJECTION | tmpl_concrete_array

cdef class Bool(MDSPrimitiveBase):

    cdef mv_bool _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    

cdef inline BoolArray_Inplace(BoolArray cls, size_t length):
    cls._handle = create_bool_marray(length)

cdef class BoolArray(MDSArrayBase):

    cdef h_marray_bool_t _handle
    _primitive = Bool

    def __cinit__(self, length=None):
        if length is not None:
            BoolArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_bool(value))
    
    def copy(self):
        retval = BoolArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

    property dtype:
        def __get__(self):
            return type(True)

cdef class Byte(MDSIntPrimitiveBase):

    cdef mv_byte _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return -128

    property MAX:
        def __get__(self):
            return 127 


cdef inline ByteArray_Inplace(ByteArray cls, size_t length):
    cls._handle = create_byte_marray(length)

cdef class ByteArray(MDSIntArrayBase):

    cdef h_marray_byte_t _handle
    _primitive = Byte

    def __cinit__(self, length=None):
        if length is not None:
            ByteArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_byte(value))
    
    def copy(self):
        retval = ByteArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class UByte(MDSIntPrimitiveBase):

    cdef mv_ubyte _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 255 


cdef inline UByteArray_Inplace(UByteArray cls, size_t length):
    cls._handle = create_ubyte_marray(length)

cdef class UByteArray(MDSIntArrayBase):

    cdef h_marray_ubyte_t _handle
    _primitive = UByte

    def __cinit__(self, length=None):
        if length is not None:
            UByteArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_ubyte(value))
    
    def copy(self):
        retval = UByteArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class Short(MDSIntPrimitiveBase):

    cdef mv_short _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return -32768

    property MAX:
        def __get__(self):
            return 32767 


cdef inline ShortArray_Inplace(ShortArray cls, size_t length):
    cls._handle = create_short_marray(length)

cdef class ShortArray(MDSIntArrayBase):

    cdef h_marray_short_t _handle
    _primitive = Short

    def __cinit__(self, length=None):
        if length is not None:
            ShortArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_short(value))
    
    def copy(self):
        retval = ShortArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class UShort(MDSIntPrimitiveBase):

    cdef mv_ushort _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 65535 


cdef inline UShortArray_Inplace(UShortArray cls, size_t length):
    cls._handle = create_ushort_marray(length)

cdef class UShortArray(MDSIntArrayBase):

    cdef h_marray_ushort_t _handle
    _primitive = UShort

    def __cinit__(self, length=None):
        if length is not None:
            UShortArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_ushort(value))
    
    def copy(self):
        retval = UShortArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class Int(MDSIntPrimitiveBase):

    cdef mv_int _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return -2147483648

    property MAX:
        def __get__(self):
            return 2147483647 


cdef inline IntArray_Inplace(IntArray cls, size_t length):
    cls._handle = create_int_marray(length)

cdef class IntArray(MDSIntArrayBase):

    cdef h_marray_int_t _handle
    _primitive = Int

    def __cinit__(self, length=None):
        if length is not None:
            IntArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_int(value))
    
    def copy(self):
        retval = IntArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class UInt(MDSIntPrimitiveBase):

    cdef mv_uint _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 4294967295 


cdef inline UIntArray_Inplace(UIntArray cls, size_t length):
    cls._handle = create_uint_marray(length)

cdef class UIntArray(MDSIntArrayBase):

    cdef h_marray_uint_t _handle
    _primitive = UInt

    def __cinit__(self, length=None):
        if length is not None:
            UIntArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_uint(value))
    
    def copy(self):
        retval = UIntArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class Long(MDSIntPrimitiveBase):

    cdef mv_long _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return -9223372036854775808

    property MAX:
        def __get__(self):
            return 9223372036854775807 


cdef inline LongArray_Inplace(LongArray cls, size_t length):
    cls._handle = create_long_marray(length)

cdef class LongArray(MDSIntArrayBase):

    cdef h_marray_long_t _handle
    _primitive = Long

    def __cinit__(self, length=None):
        if length is not None:
            LongArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_long(value))
    
    def copy(self):
        retval = LongArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class ULong(MDSIntPrimitiveBase):

    cdef mv_ulong _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    
    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 18446744073709551615 


cdef inline ULongArray_Inplace(ULongArray cls, size_t length):
    cls._handle = create_ulong_marray(length)

cdef class ULongArray(MDSIntArrayBase):

    cdef h_marray_ulong_t _handle
    _primitive = ULong

    def __cinit__(self, length=None):
        if length is not None:
            ULongArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_ulong(value))
    
    def copy(self):
        retval = ULongArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class Float(MDSFloatPrimitiveBase):

    cdef mv_float _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    

cdef inline FloatArray_Inplace(FloatArray cls, size_t length):
    cls._handle = create_float_marray(length)

cdef class FloatArray(MDSFloatArrayBase):

    cdef h_marray_float_t _handle
    _primitive = Float

    def __cinit__(self, length=None):
        if length is not None:
            FloatArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_float(value))
    
    def copy(self):
        retval = FloatArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

cdef class Double(MDSFloatPrimitiveBase):

    cdef mv_double _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        value = self._sanitize(value)

    def _to_python(self):
        return to_core_val(self._value)

    def _to_mds(self):  # TODO: This needs to update _value
        pass
    

cdef inline DoubleArray_Inplace(DoubleArray cls, size_t length):
    cls._handle = create_double_marray(length)

cdef class DoubleArray(MDSFloatArrayBase):

    cdef h_marray_double_t _handle
    _primitive = Double

    def __cinit__(self, length=None):
        if length is not None:
            DoubleArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_double(value))
    
    def copy(self):
        retval = DoubleArray(len(self))

        for i in range(len(self)):
            retval[i] = self[i]

        return retval

# END INJECTION

cpdef RecordMemberBase record_member_factory(Record record, klass, bint make_const, initial_value):
    classname = "Const" if make_const else ""

    # We need this to be a typing.TypeInfo to get consistent titles    
    if isinstance(klass, str):
        klass = Types[klass]
    
    if isinstance(klass, TypeInfo):
        classname += klass.title
    else:
        raise TypeError("Can't resolve type `{}` as MDS type identifier".format(id(klass)))

    # Now, let's see if it's known and of the correct lineage
    cls = globals()[classname]
    assert issubclass(cls, RecordMemberBase)

    # We're all good, send it back up!
    return cls(record, initial_value)

# =========================================================================
#  Base
# =========================================================================

cdef class MDSObject(object):

    def _throw_const_error(self):
        raise ConstError("Can't assign value to const field.")

    # TODO: memoize?
    property is_const:
        def __get__(self):
            return self.__class__.__name__.startswith("Const")

    property is_null:
        def __get__(self):
            pass  # TODO

# =========================================================================
#  Managed Values
# =========================================================================

cdef class MDSPrimitiveBase(MDSObject):
    # TODO: Use the API's math operation to ensure atomicity

    def __int__(self):
        pass

    def __long__(self):
        pass

    def __float__(self):
        pass

    def _sanitize(self, value):
        return value

    def _to_python(self):
        raise NotImplementedError("Specialization required.")

    def _to_mds(self):
        raise NotImplementedError("Specialization required.")

    property python_copy:
        def __get__(self):
            raise NotImplementedError("Specialization required.")


cdef class MDSIntPrimitiveBase(MDSPrimitiveBase):

    def _sanitize(self, value):
        if isinstance(value, float):
            value = int(value)
        elif not isinstance(value, int):
            t = type(value)
            raise TypeError('Unable to parse value of type `{t}`')

        if value < self.MIN:
            raise UnderflowError(f"Can't fit {value} in container {self.dtype}")
        elif value > self.MAX:
            raise OverflowError(f"Can't fit {value} in container {self.dtype}")

        return value

    property MIN:
        def __get__(self):
            raise NotImplementedError("Integer specialization required.")

    property MAX:
        def __get__(self):
            raise NotImplementedError("Integer specialization required.")


cdef class MDSFloatPrimitiveBase(MDSPrimitiveBase):
    pass

# =========================================================================
#  Arrays
# =========================================================================

cdef class MDSArrayBase(MDSObject):
    
    def _index_bounds_check(self, index):
         # TODO: Need to handle slices. Should this be a new array?
        cdef long l = <long> len(self)

        if index >= l or index < -l:
            raise IndexError('list index out of range')

        if index < 0:
            index += l

        return index

    def _to_python(self, index):
        raise NotImplementedError('Specialization of MDSList required') 

    def _to_mds(self, index, value):
        raise NotImplementedError('Specialization of MDSList required') 

    def __getitem__(self, index):
        index = self._index_bounds_check(index)
        return self._to_python(index)

    def __setitem__(self, index, value):
        index = self._index_bounds_check(index)
        self._to_mds(index, value)

    def __iter__(self):
        return NotImplemented # TODO Implement this

    def __next__(self):
        return NotImplemented # TODO Implement this

    def __len__(self):
        raise NotImplementedError('Specialization of MDSArrayBase required') 

    def index(self, start=None, end=None):
        return NotImplemented # TODO Implement this

    def count(self, value):
        # TODO: Handle len 0, should this even be instantiable?
        # TODO: Bool still a str-literal here
        if not isinstance(value, type(self[0])):
            raise TypeError("value to be searched for must match list-type `bool`")

        cdef:
            size_t i = 0, l = len(self), c = 0

        for i in range(l):
            if self[i] == value:
                c += 1

        return c

    def sort(self):
        return NotImplemented # TODO Implement this

    def reverse(self):
        return NotImplemented # TODO Implement this

    def copy(self):
        raise NotImplementedError('Specialization of MDSArrayBase required')
 
    property dtype:
        def __get__(self):
            raise NotImplementedError('Specialization of MDSArrayBase required')


cdef class MDSIntArrayBase(MDSArrayBase):

    def _numeric_bounds_check(self, value):
        """
        TODO: This needs to check the bounds of the different int sizes in MDS.
        """
        raise NotImplementedError('Requires a type-specific instantiation')

    def __setitem__(self, index, value):
        index = self._index_bounds_check(index)
        value = self._numeric_bounds_check(value)
        self._to_mds(index, value)

    property dtype:
        def __get__(self):
            return type(1)


cdef class MDSFloatArrayBase(MDSArrayBase):

    property dtype:
        def __get__(self):
            return type(1.0)

# =========================================================================
#  Records
# =========================================================================

cdef _grab_record_handle(Record record, RecordMemberBase member):
    member._mr_handle = record._handle

cdef class RecordMemberBase(MDSObject):

    cdef managed_record_handle _mr_handle

#   using handle_type = typename managed_type<T>::field_handle_type;
#   static value_type from_core(const core_api_type &val) {
#     return mtype().from_core(val);
#   }

#   /*
#    * When we're and array field, the API read methods only get it as the base
#    * array pointer, so we need to downcast.  This should be safe
#    */
#   template<typename U = T, typename = std::enable_if_t<is_mds_array<U>::value>>
#   static value_type from_core(const api::managed_array_base_handle &handle) {
#     using elt_type = typename mtype::elt_type;
#     core_api_type h(handle.pointer()->template downcast<elt_type::kind>(),
#                     handle.view());
#     return from_core(h);
#   }

#   static core_api_type to_core(const value_type &val) {
#     return mtype().to_core(val);
#   }
# Confusion between record_field, record_member, managed_value, managed_type?

    def __cinit__(self, record, initial_value):
        self._parent = record
        _grab_record_handle(record, self)
        self._type_ident = record.ident
        self._initial_value = initial_value

    def read(self):
        raise NotImplementedError('Specialization Required')

    def write(self, value):
        raise NotImplementedError('Specialization Required')

    # cpdef ensure_type(self):
    #     raise NotImplementedError('Specialization Required')


cdef class ConstRecordMemberBase(RecordMemberBase):

    def write(self, value):
        self._throw_const_error()

# START INJECTION | tmpl_record_member

cdef class BoolRecordMember(RecordMemberBase):

    cdef h_rfield_bool_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_bool_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass


cdef class ConstBoolRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_bool_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_bool_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass

cdef class ByteRecordMember(RecordMemberBase):

    cdef h_rfield_byte_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_byte_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass


cdef class ConstByteRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_byte_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_byte_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass

cdef class UByteRecordMember(RecordMemberBase):

    cdef h_rfield_ubyte_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_ubyte_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass


cdef class ConstUByteRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_ubyte_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_ubyte_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass

cdef class ShortRecordMember(RecordMemberBase):

    cdef h_rfield_short_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_short_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass


cdef class ConstShortRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_short_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_short_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass

cdef class UShortRecordMember(RecordMemberBase):

    cdef h_rfield_ushort_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_ushort_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass


cdef class ConstUShortRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_ushort_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_ushort_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass

cdef class IntRecordMember(RecordMemberBase):

    cdef h_rfield_int_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_int_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass


cdef class ConstIntRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_int_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_int_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass

cdef class UIntRecordMember(RecordMemberBase):

    cdef h_rfield_uint_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_uint_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass


cdef class ConstUIntRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_uint_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_uint_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass

cdef class LongRecordMember(RecordMemberBase):

    cdef h_rfield_long_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_long_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass


cdef class ConstLongRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_long_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_long_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass

cdef class ULongRecordMember(RecordMemberBase):

    cdef h_rfield_ulong_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_ulong_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass


cdef class ConstULongRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_ulong_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_ulong_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass

cdef class FloatRecordMember(RecordMemberBase):

    cdef h_rfield_float_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_float_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass


cdef class ConstFloatRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_float_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_float_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass

cdef class DoubleRecordMember(RecordMemberBase):

    cdef h_rfield_double_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

    def write(self, value):
        self._handle.write(self._mr_handle, value)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_double_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass


cdef class ConstDoubleRecordMember(ConstRecordMemberBase):

    cdef h_const_rfield_double_t _handle

    def read(self):
        return self._handle.frozen_read(self._mr_handle)

# TODO: This stuff may need to be duplicated for the const-versions
#    cpdef declare(self, str ident, record_type_handle rt):
#        assert(self._handle.is_null())
#        self._handle = managed_double_type_handle().field_in(rt, ident, True)
#        self.write_initial(self._initial_value)

#    cpdef ensure_type(self):
#        # managed_type<T>::ensure_complete()
#        pass

# END INJECTION

cdef class RecordTypeDeclaration(MDSObject):

    cdef:
        managed_record_handle _handle
        record_type_handle _declared_type
        const_record_type_handle _created_type

    def __cinit__(self, str ident, object parent, dict fields):
        self._field_decls = fields
        self._ident = ident
        self._declared_type = record_type_handle.declare(convert_py_to_ish(ident))

#  api::record_type_handle declare(const mds_string &name,
#                                  managed_type<mds_record>) {
#    return api::record_type_handle::declare(name.handle());
#  }
#
#  template<typename S>
#  api::record_type_handle declare(const mds_string &name, managed_type<S> s) {
#    static_assert(is_record_type<S>::value, "Super type not a record type");
#    auto sp = s.ensure_created();
#    return api::record_type_handle::declare(name.handle(), sp);
#  }    
# NOTE: Not sure where this is called, delegated to _decalre_record_type(ident)
    # def __declare(self, ident):
    #     return record_type_handle.declare(convert_py_to_ish(ident))

    def __getattr__(self, key):
        if key not in self._field_decls:
            return super().__getattr__(key)

        return self._field_decls[key].read()

    def __setattr__(self, key, value):
        if key not in self._field_decls:
            super().__setattr__(key, value)
        else:
            self._field_decls[key].write(value)

    def __declare_fields(self): # TODO: This is probably wrong, no binding to rm (placeholder only) -- check
        map(lambda rm: _declare_record_member(rm, self._ident, self._declared_type), 
            self.__field_decls.values())

    def __ensure_field_types(self):
        map(lambda rm: rm.ensure_type(), self.__field_decls.values())

    def __ensure_created(self):
        if self._created_type.is_null():
            # This needs to work in two phases.  In the first, we declare
            # the fields, and we have to be sure that this can't result
            # in a recursive call to __ensure_created() or we will have a
            # deadlock.  But we have to make sure that any referenced
            # types (including this one) are created, so we have a second
            # pass that loops through the fields and does this.  But we
            # go through the second pass after setting __created_type, and
            # we use a check on _created_type to avoid locking.
            #
            # There is a failure window in between the internal call to
            # __ensure_created() and the end of this function.  If we die
            # there, we will have a created record type that may have
            # fields whose types are uncreated record types.  We will
            # not, however, have actually created any instances of this
            # record type (since we died).  This will result in an
            # incompatible type exception, since the types won't be the
            # same nor will one forward to the other.
            #
            # TODO (upstream): Make it possible for the next process to finish the
            # job by overwriting the field type with its own.
            
            # TODO call_once semantics -- std::call_once(_created
            self.__delcare_fields()
            self._created_type = self._declared_type.ensure_created()
            _register_type(self._created_type)
            self.__ensure_field_types()

        # TODO does this need to return the c++ type, or will a bint suffice?
        # TODO return self._created_type
        return True

cdef class RecordToken(MDSObject):

# struct rc_token {
#  protected:
#   friend class mds_record;
#   mutable std::shared_ptr<mds_record> _shared_ptr;
#
#   virtual ~rc_token() {
#     recent_stack().pop();
#   }
#
#   virtual handle_type create() const = 0;
#   /*
#    * If we create the initial shared ptr as a
#    * shared_ptr<mds_record>, then when the last shared_ptr
#    * goes away and the mds_record is destroyed, if there were
#    * virtual functions added below, the wrong pointer to the
#    * memory will be wrong.  So we indirect through the rc_token,
#    * which knows the type to create the pointer to cache.
#    */
#   virtual void cache_shared(mds_record *) const = 0;
#
#   rc_token() {
#     recent_stack().push(nullptr);
#   }
#
#   static std::stack<mds_record *> &recent_stack() {
#     static thread_local std::stack<mds_record *> s;
#     return s;
#   }
# };

# template<typename R, typename = enable_if_record<R>>
# struct typed_rc_token : mds_record::rc_token {
#   mds_record::handle_type create() const override {
#     ensure_thread_initialized();
#     return managed_type<R>().ensure_created().create_record();
#   }

#   std::shared_ptr<R> cached_shared_ptr() const {
#     return std::static_pointer_cast<R>(_shared_ptr);
#   }

#   void cache_shared(mds_record *r) const override {
#     /*
#      * This is called from mds_record's ctor, so the actual
#      * concrete class hasn't been constructed yet.  I'm assuming
#      * that creating a shared_ptr to it won't involve anythnig more
#      * than doing some adjustment to the this pointer.
#      */
#     R *dc_rec = static_cast<R *>(r);
#     _shared_ptr = std::shared_ptr<R>(dc_rec);
#     recent_stack().top() = r;
#   }

#   static R *being_constructed() {
#     auto &recent = recent_stack();
#     R *as_record = static_cast<R*>(recent.top());
#     assert(recent.top() != nullptr);
#     return as_record;
#   }
# };
    pass

"""
TODO:
    * Implement comparisons
    * Test the heck out of unicode encoding / decoding
    * Have __repr__ give a streaming view of the string in the MDS heap
    * Deal with the '\n' ending char
    * Define str-like operations in this file, not delegating to str (invokes copy)
"""

cdef class String(MDSObject):
    """
    This class provides the functionality expected from the native str type,
    but backed by MDS. As with str, Strings are immutable.
    """

    cdef:
        managed_string_handle _handle
        int __iter_idx

    def __cinit__(self, value=None):
        cdef interned_string_handle handle = convert_py_to_ish(value) 
        self._handle = managed_string_handle(handle)
        self.__iter_idx = 0

    def __len__(self):
        return self._handle.length()

    def __hash__(self):
        return self._handle.hash1()

    def __iter__(self):
        self.__iter_idx = 0
        return self

    def __next__(self):
        if self.__iter_idx < len(self):
            retval = self[self.__iter_idx]
            self.__iter_idx += 1
            return retval
        else:
            raise StopIteration

    def __str__(self):
        return <str> self._handle.utf8().decode("utf-8")

    def __repr__(self):
        return "'{}'".format(str(self))

    def __getitem__(self, item):
        cdef:
            string s
            int i
            char_type c

        if isinstance(item, int):
            c = self._handle.at(item)
            u = chr(c)
            return u
        elif isinstance(item, slice):
            # TODO: Check this
            s.reserve((item.stop - item.start) // item.step)

            for i in range(start=item.start, stop=item.stop, step=item.step):
                s.push_back(self._handle.at(i))

            return String(s)

        raise TypeError(
            "list indices must be integers or slices, not {}".format(
                type(item)
            )
        )

    def __add__(self, other):
        """
        Concatenates this string with another, returns this as a new String
        """
        # TODO: Could probably open this to [str, bytes] too.
        cdef:
            string s
            str c

        if isinstance(other, String):       
            s.reserve(<size_t> (len(self) + len(other)))

            # Chain the iterators to avoid any string copying
            for c in chain(iter(self), iter(other)):
                s.push_back(ord(c))  # Need as an int for char

            return String(s)

        raise TypeError("must be String")

    def __mul__(self, other):
        """
        Internal method to perform String multiplication without overhead
        """
        cdef:
            string s
            str c
            int it, l = len(self)

        if isinstance(other, int):
            s.reserve(l * other)

            for it in range(other):
                for c in self:
                    s.push_back(ord(c))

            return String(<unicode> s.decode("utf-8"))

        raise TypeError(
            "can't multiply sequence by non-int of type 'String'"
        )

    def __rmul__(self, other):
        pass

    def __mod__(self, other):
        pass

    def __rmod__(self, other):
        pass

    def __richcmp__(a, b, op):
        if op == 0:    # <
            return a._handle < b._handle
        elif op == 1:  # <=
            return a._handle <= b._handle
        elif op == 2:  # ==
            return a._handle == b._handle
        elif op == 3:  # !=
            return a._handle != b._handle
        elif op == 4:  # >
            return a._handle > b._handle
        elif op == 5:  # >=
            return a._handle >= b._handle

    def __sizeof__(self):
        return self._handle.size()

    # TODO: Write equivalents that use the MDS-stored data

    def capitalize(self):
        return String(str(self).capitalize())

    def casefold(self):
        return String(str(self).casefold())

    def center(self, *args, **kwargs):
        return String(str(self).center(*args, **kwargs))

    # TODO: encode(encoding="utf-8", errors="strict")

    def endswith(self, *args, **kwargs):
        return str(self).endswith(*args, **kwargs)

    def expandtabs(self, *args, **kwargs):
        return String(str(self).expandtabs(*args, **kwargs))

    def find(self, *args, **kwargs):
        return str(self).find(*args, **kwargs)

    def format(self, *args, **kwargs):
        return String(str(self).format(*args, **kwargs))

    def format_map(self, *args, **kwargs):
        return String(str(self).format_map(*args, **kwargs))

    def index(self, *args, **kwargs):
        return str(self).index(*args, **kwargs)

    def isalnum(self, *args, **kwargs):
        return str(self).isalnum(*args, **kwargs)

    def isalpha(self, *args, **kwargs):
        return str(self).isalpha(*args, **kwargs)

    def isdecimal(self, *args, **kwargs):
        return str(self).isdecimal(*args, **kwargs)

    def isdigit(self, *args, **kwargs):
        return str(self).isdigit(*args, **kwargs)
    
    def isidentifier(self, *args, **kwargs):
        return str(self).isidentifier(*args, **kwargs)
    
    def islower(self, *args, **kwargs):
        return str(self).islower(*args, **kwargs)

    def isnumeric(self, *args, **kwargs):
        return str(self).isnumeric(*args, **kwargs)

    def isprintable(self, *args, **kwargs):
        return str(self).isprintable(*args, **kwargs)

    def isspace(self, *args, **kwargs):
        return str(self).isspace(*args, **kwargs)

    def istitle(self, *args, **kwargs):
        return str(self).istitle(*args, **kwargs)

    def isupper(self, *args, **kwargs):
        return str(self).isupper(*args, **kwargs)

    def join(self, *args, **kwargs):
        return String(str(self).join(*args, **kwargs))

    def ljust(self, *args, **kwargs):
        return String(str(self).ljust(*args, **kwargs))

    def lower(self, *args, **kwargs):
        return String(str(self).lower(*args, **kwargs))

    def lstrip(self, *args, **kwargs):
        return String(str(self).lstrip(*args, **kwargs))

    def partition(self, *args, **kwargs):
        return tuple([String(x) for x in str(self).partition(*args, **kwargs)])

    def replace(self, *args, **kwargs):
        return String(str(self).replace(*args, **kwargs))

    def rfind(self, *args, **kwargs):
        return str(self).rfind(*args, **kwargs)

    def rindex(self, *args, **kwargs):
        return str(self).rindex(*args, **kwargs)

    def rjust(self, *args, **kwargs):
        return String(str(self).rjust(*args, **kwargs))

    def rpartition(self, *args, **kwargs):
        return tuple([String(x) for x in str(self).rpartition(*args, **kwargs)])

    def rsplit(self, *args, **kwargs):
        return [String(x) for x in str(self).rsplit(*args, **kwargs)]

    def rstrip(self, *args, **kwargs):
        return String(str(self).rstrip(*args, **kwargs))

    def split(self, *args, **kwargs):
        return [String(x) for x in str(self).split(*args, **kwargs)]

    def splitlines(self, *args, **kwargs):
        return [String(x) for x in str(self).split(*args, **kwargs)]

    def startswith(self, *args, **kwargs):
        return str(self).startswith(*args, **kwargs)

    def strip(self, *args, **kwargs):
        return String(str(self).strip(*args, **kwargs))
    
    def swapcase(self, *args, **kwargs):
        return String(str(self).swapcase(*args, **kwargs))

    def title(self, *args, **kwargs):
        return String(str(self).title(*args, **kwargs))

    # TODO: translate

    def upper(self, *args, **kwargs):
        return String(str(self).upper(*args, **kwargs))

    def zfill(self, *args, **kwargs):
        return String(str(self).zfill(*args, **kwargs))

# =========================================================================
#  Namespace
# =========================================================================


cdef class Namespace(MDSObject):

    cdef namespace_handle _handle

    def __setitem__(self, key, value):
        cdef:
            interned_string_handle ish = convert_py_to_ish(key)
            uint16_t val = value

        # TODO: Restrict value to MDSObject, or just do smallest-fitting-elem?
        # if not issubclass(type(value), MDSObject):
        #     raise TypeError('Cannot commit a non-MDS type into a MDS namespace')

        # TODO: get the boxed item to release its wrapped value into bind...
        self._handle.bind(ish, val)

    def __getitem__(self, key):
        # TODO: Need some type inference here, require explicit third param?
        cdef:
            uint16_t retval
            interned_string_handle ish = convert_py_to_ish(key)

        retval = self._handle.lookup(ish, managed_ushort_type_handle())
        return retval

    def create_child(self, child_id, bint create_if_missing=True):
        cdef:
            interned_string_handle ish = convert_py_to_ish(child_id)
            bool cim = <bool> create_if_missing
        
        return Namespace_Init(self._handle.child_namespace(ish, cim))

    @staticmethod
    def from_path(path):
        pass

    @staticmethod
    def get_current():
        pass  # TODO: mds_namespace::current()

    @staticmethod
    def get_global():
        return Namespace_Init(handle=namespace_handle._global())

    property is_root:
        def __get__(self):
            # TODO: Implement this
            pass

    property parent:
        def __get__(self):
            # TODO: Implement this
            pass


cdef inline Namespace_Init(namespace_handle handle):
    initialize_base_task()
    result = Namespace()
    result._handle = handle
    return result

# =========================================================================
#  Helpers
# =========================================================================

cpdef inline is_record_type(obj):
    return issubclass(obj, Record)

cdef inline _declare_record_member(RecordMemberBase rm, str ident, record_type_handle rt):
    pass

# TODO: These record_creator methods
cdef inline _register_type(const_record_type_handle crht):
    pass

cdef inline _create_from_handle(managed_record_handle mrh):
    pass

cdef inline record_type_handle _declare_record_type(str ident):
    return record_type_handle.declare(convert_py_to_ish(ident))
