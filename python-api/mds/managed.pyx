# -*- coding: utf-8 -*-
"""
Managed Data Structures
Copyright Â© 2017 Hewlett Packard Enterprise Development Company LP.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

As an exception, the copyright holders of this Library grant you permission
to (i) compile an Application with the Library, and (ii) distribute the
Application containing code generated by the Library and added to the
Application during this compilation process under terms of your choice,
provided you also meet the terms and conditions of the Application license.
"""

from itertools import chain

from libcpp cimport bool
from libcpp.string cimport string
from libcpp.vector cimport vector

from typing import Union, List, Optional

from mds.core.api_strings cimport *
from mds.core.api_arrays cimport *
from mds.core.api_records cimport *
from mds.core.api_helpers cimport initialize_base_task
from mds.core.api_namespaces cimport *
from mds.core.api_primitives cimport *

import mds
from mds import TypeInfo

import threading

__LOCAL = threading.local()
__LOCAL.token_stack = []

initialize_base_task()

# =========================================================================
#  Base
# =========================================================================

cdef class MDSObject(object):

    def _throw_const_error(self):
        raise ConstError("Can't assign value to const field.")

    property is_const:
        def __get__(self):
            raw_name = self.__class__.__name__

            if raw_name.startswith("MDS"):
                raw_name = raw_name[3:]

            return raw_name.startswith("Const")

# =========================================================================
#  Errors & Exceptions
# =========================================================================

cdef class UnderflowError(Exception):
    pass

cdef class ConstError(Exception):
    pass

# =========================================================================
#  Managed Values
# =========================================================================

cdef class MDSConstPrimitiveBase(MDSObject):
    pass


cdef class MDSPrimitiveBase(MDSConstPrimitiveBase):

    def _sanitize(self, value, existing):
        if type(value) != type(existing):
            raise TypeError("Need the same types, got `{}` and `{}`.".format(
                    type(value), type(existing)
                )
            )

        return value

    def _to_python(self):
        return NotImplemented

    def update_value(self, value) -> None:
        return NotImplemented


cdef class MDSConstIntPrimitiveBase(MDSPrimitiveBase):

    def __int__(self):
        pass

    def __float__(self):
        pass

    def __add__(self, other):
        pass

    def __sub__(self, other):
        pass

    def __mul__(self, other):
        pass

    def __div__(self, other):
        pass

    property MIN:
        def __get__(self):
            raise NotImplementedError("Integer specialization required.")

    property MAX:
        def __get__(self):
            raise NotImplementedError("Integer specialization required.")


cdef class MDSIntPrimitiveBase(MDSConstIntPrimitiveBase):

    def __iadd__(self, other):
        pass

    def __isub__(self, other):
        pass

    def __imul__(self, other):
        pass

    def __idiv__(self, other):
        pass

    def _sanitize(self, value, existing):
        if isinstance(value, float):
            value = int(value)
        elif not isinstance(value, int):
            t = type(value)
            raise TypeError('Unable to parse value of type `{t}`')

        if value < self.MIN:
            raise UnderflowError(f"Can't fit {value} in container {self.dtype}")
        elif value > self.MAX:
            raise OverflowError(f"Can't fit {value} in container {self.dtype}")

        return value


cdef class MDSFloatPrimitiveBase(MDSPrimitiveBase):
    # TODO, Can I inherit from IntegralBase for math ops?
    pass

cdef class MDSConstFloatPrimitiveBase(MDSFloatPrimitiveBase):
    pass

# =========================================================================
#  Arrays
# =========================================================================

cdef class MDSConstArrayBase(MDSObject):
    cdef size_t _last_index

    def __iter__(self):
        return NotImplemented # TODO Implement this

    def __next__(self):
        return NotImplemented # TODO Implement this

    def __len__(self):
        raise NotImplementedError('Specialization of MDSArrayBase required')

    def __getitem__(self, index):
        index = self._index_bounds_check(index)

        # We store this for in-place ops
        self._last_index = index
        return self._to_python(index)

    def _index_bounds_check(self, index):
         # TODO: Need to handle slices. Should this be a new array?
        cdef long l = <long> len(self)

        if index >= l or index < -l:
            raise IndexError('list index out of range')

        if index < 0:
            index += l

        return index

    def _to_python(self, index):
        raise NotImplementedError('Specialization of MDSList required') 

    def _to_mds(self, index, value):
        raise NotImplementedError('Specialization of MDSList required') 

    def index(self, start=None, end=None):
        return NotImplemented # TODO Implement this

    def count(self, value):
        # TODO: Handle len 0, should this even be instantiable?
        # TODO: Bool still a str-literal here
        if not isinstance(value, type(self[0])):
            raise TypeError("value to be searched for must match list-type `bool`")

        cdef:
            size_t i = 0, l = len(self), c = 0

        for i in range(l):
            if self[i] == value:
                c += 1

        return c

    def copy(self):
        raise NotImplementedError('Specialization of MDSArrayBase required')
 
    property dtype:
        def __get__(self):
            raise NotImplementedError('Specialization of MDSArrayBase required')


cdef class MDSArrayBase(MDSConstArrayBase):

    def __setitem__(self, index, value):
        index = self._index_bounds_check(index)
        self._to_mds(index, value)


cdef class MDSIntArrayBase(MDSArrayBase):

    def _numeric_bounds_check(self, value):
        """
        TODO: This needs to check the bounds of the different int sizes in MDS.
        """
        raise NotImplementedError('Requires a type-specific instantiation')

    def __setitem__(self, index, value):
        index = self._index_bounds_check(index)
        value = self._numeric_bounds_check(value)
        self._to_mds(index, value)

    property dtype:
        def __get__(self):
            return type(1)


cdef class MDSFloatArrayBase(MDSArrayBase):

    property dtype:
        def __get__(self):
            return type(1.0)

# START INJECTION | tmpl_array

cdef inline BoolArray_Inplace(BoolArray cls, size_t length):
    cls._handle = create_bool_marray(length)

cdef class BoolArray(MDSArrayBase):

    cdef h_marray_bool_t _handle
    _primitive = Bool

    def __cinit__(self, length=None):
        if length is not None:
            BoolArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return bool_to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_bool(value))
    
    def copy(self):
        cdef:
            size_t i = 0
            size_t n = len(self)

        retval = BoolArray(length=len(self))

        for i in range(n):
            retval[i] = self[i]

        return retval

    property dtype:
        def __get__(self):
            return type(True)

cdef inline ByteArray_Inplace(ByteArray cls, size_t length):
    cls._handle = create_byte_marray(length)

cdef class ByteArray(MDSIntArrayBase):

    cdef h_marray_byte_t _handle
    _primitive = Byte

    def __cinit__(self, length=None):
        if length is not None:
            ByteArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return byte_to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_byte(value))
    
    def copy(self):
        cdef:
            size_t i = 0
            size_t n = len(self)

        retval = ByteArray(length=len(self))

        for i in range(n):
            retval[i] = self[i]

        return retval

    def __iadd__(self, other):
        return self._handle.add(self._last_index, <int8_t> other)

    def __isub__(self, other):
        return self._handle.sub(self._last_index, <int8_t> other)

    def __imul__(self, other):
        return self._handle.mul(self._last_index, <int8_t> other)

    def __idiv__(self, other):
        return self._handle.div(self._last_index, <int8_t> other)

cdef inline UByteArray_Inplace(UByteArray cls, size_t length):
    cls._handle = create_ubyte_marray(length)

cdef class UByteArray(MDSIntArrayBase):

    cdef h_marray_ubyte_t _handle
    _primitive = UByte

    def __cinit__(self, length=None):
        if length is not None:
            UByteArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return ubyte_to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_ubyte(value))
    
    def copy(self):
        cdef:
            size_t i = 0
            size_t n = len(self)

        retval = UByteArray(length=len(self))

        for i in range(n):
            retval[i] = self[i]

        return retval

    def __iadd__(self, other):
        return self._handle.add(self._last_index, <uint8_t> other)

    def __isub__(self, other):
        return self._handle.sub(self._last_index, <uint8_t> other)

    def __imul__(self, other):
        return self._handle.mul(self._last_index, <uint8_t> other)

    def __idiv__(self, other):
        return self._handle.div(self._last_index, <uint8_t> other)

cdef inline ShortArray_Inplace(ShortArray cls, size_t length):
    cls._handle = create_short_marray(length)

cdef class ShortArray(MDSIntArrayBase):

    cdef h_marray_short_t _handle
    _primitive = Short

    def __cinit__(self, length=None):
        if length is not None:
            ShortArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return short_to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_short(value))
    
    def copy(self):
        cdef:
            size_t i = 0
            size_t n = len(self)

        retval = ShortArray(length=len(self))

        for i in range(n):
            retval[i] = self[i]

        return retval

    def __iadd__(self, other):
        return self._handle.add(self._last_index, <int16_t> other)

    def __isub__(self, other):
        return self._handle.sub(self._last_index, <int16_t> other)

    def __imul__(self, other):
        return self._handle.mul(self._last_index, <int16_t> other)

    def __idiv__(self, other):
        return self._handle.div(self._last_index, <int16_t> other)

cdef inline UShortArray_Inplace(UShortArray cls, size_t length):
    cls._handle = create_ushort_marray(length)

cdef class UShortArray(MDSIntArrayBase):

    cdef h_marray_ushort_t _handle
    _primitive = UShort

    def __cinit__(self, length=None):
        if length is not None:
            UShortArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return ushort_to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_ushort(value))
    
    def copy(self):
        cdef:
            size_t i = 0
            size_t n = len(self)

        retval = UShortArray(length=len(self))

        for i in range(n):
            retval[i] = self[i]

        return retval

    def __iadd__(self, other):
        return self._handle.add(self._last_index, <uint16_t> other)

    def __isub__(self, other):
        return self._handle.sub(self._last_index, <uint16_t> other)

    def __imul__(self, other):
        return self._handle.mul(self._last_index, <uint16_t> other)

    def __idiv__(self, other):
        return self._handle.div(self._last_index, <uint16_t> other)

cdef inline IntArray_Inplace(IntArray cls, size_t length):
    cls._handle = create_int_marray(length)

cdef class IntArray(MDSIntArrayBase):

    cdef h_marray_int_t _handle
    _primitive = Int

    def __cinit__(self, length=None):
        if length is not None:
            IntArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return int_to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_int(value))
    
    def copy(self):
        cdef:
            size_t i = 0
            size_t n = len(self)

        retval = IntArray(length=len(self))

        for i in range(n):
            retval[i] = self[i]

        return retval

    def __iadd__(self, other):
        return self._handle.add(self._last_index, <int32_t> other)

    def __isub__(self, other):
        return self._handle.sub(self._last_index, <int32_t> other)

    def __imul__(self, other):
        return self._handle.mul(self._last_index, <int32_t> other)

    def __idiv__(self, other):
        return self._handle.div(self._last_index, <int32_t> other)

cdef inline UIntArray_Inplace(UIntArray cls, size_t length):
    cls._handle = create_uint_marray(length)

cdef class UIntArray(MDSIntArrayBase):

    cdef h_marray_uint_t _handle
    _primitive = UInt

    def __cinit__(self, length=None):
        if length is not None:
            UIntArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return uint_to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_uint(value))
    
    def copy(self):
        cdef:
            size_t i = 0
            size_t n = len(self)

        retval = UIntArray(length=len(self))

        for i in range(n):
            retval[i] = self[i]

        return retval

    def __iadd__(self, other):
        return self._handle.add(self._last_index, <uint32_t> other)

    def __isub__(self, other):
        return self._handle.sub(self._last_index, <uint32_t> other)

    def __imul__(self, other):
        return self._handle.mul(self._last_index, <uint32_t> other)

    def __idiv__(self, other):
        return self._handle.div(self._last_index, <uint32_t> other)

cdef inline LongArray_Inplace(LongArray cls, size_t length):
    cls._handle = create_long_marray(length)

cdef class LongArray(MDSIntArrayBase):

    cdef h_marray_long_t _handle
    _primitive = Long

    def __cinit__(self, length=None):
        if length is not None:
            LongArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return long_to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_long(value))
    
    def copy(self):
        cdef:
            size_t i = 0
            size_t n = len(self)

        retval = LongArray(length=len(self))

        for i in range(n):
            retval[i] = self[i]

        return retval

    def __iadd__(self, other):
        return self._handle.add(self._last_index, <int64_t> other)

    def __isub__(self, other):
        return self._handle.sub(self._last_index, <int64_t> other)

    def __imul__(self, other):
        return self._handle.mul(self._last_index, <int64_t> other)

    def __idiv__(self, other):
        return self._handle.div(self._last_index, <int64_t> other)

cdef inline ULongArray_Inplace(ULongArray cls, size_t length):
    cls._handle = create_ulong_marray(length)

cdef class ULongArray(MDSIntArrayBase):

    cdef h_marray_ulong_t _handle
    _primitive = ULong

    def __cinit__(self, length=None):
        if length is not None:
            ULongArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return ulong_to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_ulong(value))
    
    def copy(self):
        cdef:
            size_t i = 0
            size_t n = len(self)

        retval = ULongArray(length=len(self))

        for i in range(n):
            retval[i] = self[i]

        return retval

    def __iadd__(self, other):
        return self._handle.add(self._last_index, <uint64_t> other)

    def __isub__(self, other):
        return self._handle.sub(self._last_index, <uint64_t> other)

    def __imul__(self, other):
        return self._handle.mul(self._last_index, <uint64_t> other)

    def __idiv__(self, other):
        return self._handle.div(self._last_index, <uint64_t> other)

cdef inline FloatArray_Inplace(FloatArray cls, size_t length):
    cls._handle = create_float_marray(length)

cdef class FloatArray(MDSFloatArrayBase):

    cdef h_marray_float_t _handle
    _primitive = Float

    def __cinit__(self, length=None):
        if length is not None:
            FloatArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return float_to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_float(value))
    
    def copy(self):
        cdef:
            size_t i = 0
            size_t n = len(self)

        retval = FloatArray(length=len(self))

        for i in range(n):
            retval[i] = self[i]

        return retval

    def __iadd__(self, other):
        return self._handle.add(self._last_index, <float> other)

    def __isub__(self, other):
        return self._handle.sub(self._last_index, <float> other)

    def __imul__(self, other):
        return self._handle.mul(self._last_index, <float> other)

    def __idiv__(self, other):
        return self._handle.div(self._last_index, <float> other)

cdef inline DoubleArray_Inplace(DoubleArray cls, size_t length):
    cls._handle = create_double_marray(length)

cdef class DoubleArray(MDSFloatArrayBase):

    cdef h_marray_double_t _handle
    _primitive = Double

    def __cinit__(self, length=None):
        if length is not None:
            DoubleArray_Inplace(self, length)

    def __len__(self):
        return self._handle.size()

    def _to_python(self, index):
        return double_to_core_val(self._handle.frozen_read(index))

    def _to_mds(self, index, value):
        # Delegate bounds checking etc. to the primitive wrapper
        wrapped = self._primitive(value)
        self._handle.write(index, mv_double(value))
    
    def copy(self):
        cdef:
            size_t i = 0
            size_t n = len(self)

        retval = DoubleArray(length=len(self))

        for i in range(n):
            retval[i] = self[i]

        return retval

    def __iadd__(self, other):
        return self._handle.add(self._last_index, <double> other)

    def __isub__(self, other):
        return self._handle.sub(self._last_index, <double> other)

    def __imul__(self, other):
        return self._handle.mul(self._last_index, <double> other)

    def __idiv__(self, other):
        return self._handle.div(self._last_index, <double> other)

# END INJECTION

# =========================================================================
#  Records
# =========================================================================

class MDSRecordFieldMemberPair(object):
    """
    This is an internal class to deal with the fact that we don't have
    static variables per-se in Python, and certainly not in Cython, so
    we pair the instantiated RecordField with the type of the requested
    RecordMember (whether const or not), to be plugged into derived
    classes
    """

    def __init__(self, field: MDSRecordFieldBase, member: type):
        self.field = field  # derived <- MDSRecordFieldBase
        self.member = member  # type: derived <- MDSRecordMemberBase


# This is where we keep built record types, with the associated Lock
cdef __RECORD_DECLARATION_MUTEX = threading.Lock()
cdef __RECORD_DECLARED_TYPES = dict()
cdef __RECORD_IDENTS = dict()

cdef implant_record_handle(Record record, MDSConstRecordHandleWrapper wrapper):
    cdef const_record_type_handle handle = wrapper._handle
    record._handle = handle.create_record()


cdef class Record(MDSObject):
    """
    The main Record, allowing complex data-structures using a combination of MDS
    and Python types.

    The MDS schema should be defined in a static method schema() returning a dictionary
    mapping field names (str) to field declarations. Examples are given.

    TODO: implement __getitem__ and __setitem__ to mask the write() read() ops, maybe make this primary?
    """
    cdef managed_record_handle _handle

    def __cinit__(self):
        if self.__class__ is Record:
            raise TypeError('Cannot directly instantiate Record; a subclass is required.')

        implant_record_handle(self, self.type_decl.ensure_created())

    def __init__(self):
        self._register_fields()

    # TODO Cython .27
    # def __eq__(self):
    #     pass

    @classmethod
    def __init_subclass__(cls, ident: str, **kwargs):
        """
        This is called whenever a subclass of Record comes into scope, this
        provides a couple of nice opportunities:

        1) Ensure the type is properly declared in MDS before an instance
           is called, and bind the type declaration as a static member in
           Python-land
        2) TODO: See if any ambiguous proxies from Namespace are awaiting this
           specific implementation, and deal with that accordingly.
        """
        initialize_base_task()

        super().__init_subclass__(**kwargs)
        print(f"Called for {cls.__name__} with {ident}")

        # This is the same as rt_decl ... type_decl() in that it instantiates
        # the RecordTypeDeclarion (rt_decl)
        # This will store a reference in __RECORD_DECLARED_TYPES in a thread-safe way
        __RECORD_IDENTS[cls.__name__] = ident
        MDSRecordTypeDeclaration(cls, cls.schema()).ensure_created()
        

    property type_decl:
        def __get__(self):
            return __RECORD_DECLARED_TYPES[self.ident]

    property ident:
        def __get__(self):
            return __RECORD_IDENTS[self.__class__.__name__]

    def _register_fields(self) -> None:
        """
        When this subclass was declared, we automatically registered the Record type
        with MDS; in so doing we stored single-instances of the RecordFields we required,
        but type references to the members, as they must be instance-bound.

        This method iterates through that container and updates the object's dict
        to enable dot notation access to the associated MemberRecords
        """
        # Stll need to make the RecordMembers and bind them to this instance
        for label, field_member_pair in self.type_decl.get_field_member_pairs().items():
            field, member_t = field_member_pair.field, field_member_pair.member
            self.__dict__[label] = member_t(record=self)

    @classmethod
    def from_namespace(cls, ns: Namespace, *args) -> Record:
        # TODO: Couldn't this be in the root of all elements that can go into a namespace?
        if not isinstance(ns, Namespace):
            raise TypeError('Need a `Namespace` object as first argument')

        if not len(args):
            raise KeyError('Need at least one path for the namespace')
    
        record = ns[args]
        retval = cls()
        # TODO: update retval's fields accordingly

        return retval

    @classmethod
    def force(cls) -> None:
        MDSManagedRecordType.ensure_complete(klass=cls)

    @staticmethod
    def schema() -> dict:
        # TODO: Move this to a class param?
        raise TypeError("Derived `Record`s should return a `dict` detailing the schema here.")

    @staticmethod
    def declare_const_field(klass: type) -> MDSRecordFieldMemberPair:
        """
        Delegates to Record.declare_field; could be deleted, but here to map 1:1 to CAPI.
        """
        return Record.declare_field(klass, make_const=True)

    @staticmethod
    def declare_field(klass: type, make_const=False) -> MDSRecordFieldMemberPair:
        """
        This returns the derived RecordField for the combination of the arguments.

        TODO: This only works for primitives, will need adaptation for {String, Array, Record}
        TODO: String-based hacking isn't neat, should make a dict using the generator,
        but this works for now.

        Args:
            klass:  TypeInfo, obtained from `mds.typing`
            make_const: Bool, whether to make the associated RecordMember const or not
        """
        if not isinstance(klass, TypeInfo):
            raise TypeError("First parameter needs to be a type from `mds.typing`")

        # Now, let's see if it's known and of the correct lineage
        field_t = globals()[klass.title_record_field]
        assert issubclass(field_t, MDSRecordFieldBase)

        if make_const:
            identifier = klass.title_const_record_member
            base = MDSConstRecordMemberBase
        else:
            identifier = klass.title_record_member
            base = MDSRecordMemberBase

        member_t = globals()[identifier]
        assert issubclass(member_t, base)

        # DEBUG
        print(f"?> Making pair {field_t.__name__}, {member_t.__name__}")

        # Unlike the CAPI we return both the instantiated field and a type for the member
        return MDSRecordFieldMemberPair(field=field_t(), member=member_t)


cdef class MDSManagedRecordType(MDSObject):
    cdef Record _parent

    def __cinit__(self, parent: Record):
        self._parent = parent

    def ensure_created(self) -> MDSConstRecordHandleWrapper:
        return self._parent.type_decl.ensure_created()

    @staticmethod
    def ensure_complete(klass: type) -> MDSConstRecordHandleWrapper:
        return klass.type_decl.ensure_created()

    @staticmethod
    def from_handle(handle: MDSConstRecordHandleWrapper) -> Record:
  # static mds_ptr<R> from_handle(const Record::handle_t &h) {
  #   if (!std::is_abstract<R>::value) {
  #     /*
  #      * If there are no virtual functions we might as well just create
  #      * a new proxy object.  We could cache them, but this is probably
  #      * at least as efficient.
  #      */
  #     return RecordCreator<R>::create_from_handle(h);
  #   } else {
  #     /*
  #      * If there are virtual functions, we need to find the actual type
  #      * for the record.
  #      */
  #     const_handle_t th = h.type();
  #     /*
  #      * If it's ours, we can just create it here.
  #      */
  #     if (th == ManagedType().handle()) {
  #       return RecordCreator<R>::create_from_handle(h);
  #     }
  #     mds_ptr<Record> r = CreatorCache::create(th, h);
  #     /*
  #      * We should be guaranteed of at least finding *this* class.
  #      */
  #     assert(r != nullptr);
  #     return r.static_pointer_cast<R>();
  #   }
  # }

        pass

    def from_core(self, handle: MDSConstRecordHandleWrapper) -> Record:
  # mds_ptr<R> from_core(const Record::handle_t &val) const {
  #   if (val == nullptr) {
  #     return nullptr;
  #   }
  #   return from_handle(val);
  # }
        pass

    def to_core(self):
  # core_api_type to_core(const mds_ptr<R> &val) const {
  #   core_api_type tcv = val == nullptr ? core_api_type { } : val->_handle;
  #   return tcv;
  # }

  # core_api_type to_core(const mds_ptr<const R> &val) const {
  #   return val == nullptr ? core_api_type { } : val->_handle;
  # }
        pass

############################################################# RECORD FIELDS

cdef class MDSRecordFieldBase(MDSObject):
    """
    Base class to wrap around the field_handle_types, analog to CAPI::record_field

    There are no const RecordField, const-ness is handled by RecordMembers
    """

    def __getitem__(self, MDSRecordMemberBase member):
        # reference operator[](const mds_ptr<R> &r) const {
        #   R::type_decl().ensure_created();
        #   return reference(*this, *r);
        # }

        # reference operator[](R *r) const {
        #   R::type_decl().ensure_created();
        #   return reference(*this, *r);
        # }

        # const_reference operator[](const mds_ptr<const R> &r) const {
        #   R::type_decl().ensure_created();
        #   return const_reference(*this, *r);
        # }

        # const_reference operator[](const R *r) const {
        #   R::type_decl().ensure_created();
        #   return const_reference(*this, *r);
        # }
        member.record.type_decl.ensure_created()

        # So whether the reference is const or not, surely that'd be on the member's
        # constness, how to pass this through?
        # TODO: Double check this on the CAPI, seems to make sense on a per-meber
        #       granularity, though the CAPI looks like it's at Record
        return self.get_reference_type(make_const=member.is_const)(self, member.record)

    def ensure_type(self):
        """
        TODO: This should only be overridden and utilized for Record fields
        """
        pass

    def declare(self, String name, MDSRecordTypeDeclaration rt):
        pass

    # These two, either use them in generated RecordFields and then Members, or
    # use overloaded calls in Members directly, then delete these.
    @staticmethod
    def from_core(val):
        pass

    @staticmethod
    def to_core(val):
        pass

    @staticmethod
    def get_reference_type(make_const=False) -> type:
        return None

# void declare(const mds_string &name, const api::record_type_handle rt) override {
#     assert(_handle.is_null());
#     const auto &ft = managed_type<T>().handle();
#     _handle = ft.field_in(rt, name.handle(), true);
#   }

# START INJECTION | tmpl_record_field

cdef class MDSBoolRecordField(MDSRecordFieldBase):
    cdef:
        h_rfield_bool_t _handle

    def declare(self, String name, MDSRecordTypeDeclaration rt):
        assert self._handle.is_null()
        print("?> Attempting to get a handle from h_const_mbool_t.field_in")
        self._handle = h_rfield_bool_t(h_const_mbool_t().field_in(rt._declared_type, name._ish, True))

    @staticmethod
    def get_reference_type(make_const=False) -> type:
        if make_const:
            return MDSConstBoolRecordFieldReference

        return MDSBoolRecordFieldReference

cdef class MDSByteRecordField(MDSRecordFieldBase):
    cdef:
        h_rfield_byte_t _handle

    def declare(self, String name, MDSRecordTypeDeclaration rt):
        assert self._handle.is_null()
        print("?> Attempting to get a handle from h_const_mbyte_t.field_in")
        self._handle = h_rfield_byte_t(h_const_mbyte_t().field_in(rt._declared_type, name._ish, True))

    @staticmethod
    def get_reference_type(make_const=False) -> type:
        if make_const:
            return MDSConstByteRecordFieldReference

        return MDSByteRecordFieldReference

cdef class MDSUByteRecordField(MDSRecordFieldBase):
    cdef:
        h_rfield_ubyte_t _handle

    def declare(self, String name, MDSRecordTypeDeclaration rt):
        assert self._handle.is_null()
        print("?> Attempting to get a handle from h_const_mubyte_t.field_in")
        self._handle = h_rfield_ubyte_t(h_const_mubyte_t().field_in(rt._declared_type, name._ish, True))

    @staticmethod
    def get_reference_type(make_const=False) -> type:
        if make_const:
            return MDSConstUByteRecordFieldReference

        return MDSUByteRecordFieldReference

cdef class MDSShortRecordField(MDSRecordFieldBase):
    cdef:
        h_rfield_short_t _handle

    def declare(self, String name, MDSRecordTypeDeclaration rt):
        assert self._handle.is_null()
        print("?> Attempting to get a handle from h_const_mshort_t.field_in")
        self._handle = h_rfield_short_t(h_const_mshort_t().field_in(rt._declared_type, name._ish, True))

    @staticmethod
    def get_reference_type(make_const=False) -> type:
        if make_const:
            return MDSConstShortRecordFieldReference

        return MDSShortRecordFieldReference

cdef class MDSUShortRecordField(MDSRecordFieldBase):
    cdef:
        h_rfield_ushort_t _handle

    def declare(self, String name, MDSRecordTypeDeclaration rt):
        assert self._handle.is_null()
        print("?> Attempting to get a handle from h_const_mushort_t.field_in")
        self._handle = h_rfield_ushort_t(h_const_mushort_t().field_in(rt._declared_type, name._ish, True))

    @staticmethod
    def get_reference_type(make_const=False) -> type:
        if make_const:
            return MDSConstUShortRecordFieldReference

        return MDSUShortRecordFieldReference

cdef class MDSIntRecordField(MDSRecordFieldBase):
    cdef:
        h_rfield_int_t _handle

    def declare(self, String name, MDSRecordTypeDeclaration rt):
        assert self._handle.is_null()
        print("?> Attempting to get a handle from h_const_mint_t.field_in")
        self._handle = h_rfield_int_t(h_const_mint_t().field_in(rt._declared_type, name._ish, True))

    @staticmethod
    def get_reference_type(make_const=False) -> type:
        if make_const:
            return MDSConstIntRecordFieldReference

        return MDSIntRecordFieldReference

cdef class MDSUIntRecordField(MDSRecordFieldBase):
    cdef:
        h_rfield_uint_t _handle

    def declare(self, String name, MDSRecordTypeDeclaration rt):
        assert self._handle.is_null()
        print("?> Attempting to get a handle from h_const_muint_t.field_in")
        self._handle = h_rfield_uint_t(h_const_muint_t().field_in(rt._declared_type, name._ish, True))

    @staticmethod
    def get_reference_type(make_const=False) -> type:
        if make_const:
            return MDSConstUIntRecordFieldReference

        return MDSUIntRecordFieldReference

cdef class MDSLongRecordField(MDSRecordFieldBase):
    cdef:
        h_rfield_long_t _handle

    def declare(self, String name, MDSRecordTypeDeclaration rt):
        assert self._handle.is_null()
        print("?> Attempting to get a handle from h_const_mlong_t.field_in")
        self._handle = h_rfield_long_t(h_const_mlong_t().field_in(rt._declared_type, name._ish, True))

    @staticmethod
    def get_reference_type(make_const=False) -> type:
        if make_const:
            return MDSConstLongRecordFieldReference

        return MDSLongRecordFieldReference

cdef class MDSULongRecordField(MDSRecordFieldBase):
    cdef:
        h_rfield_ulong_t _handle

    def declare(self, String name, MDSRecordTypeDeclaration rt):
        assert self._handle.is_null()
        print("?> Attempting to get a handle from h_const_mulong_t.field_in")
        self._handle = h_rfield_ulong_t(h_const_mulong_t().field_in(rt._declared_type, name._ish, True))

    @staticmethod
    def get_reference_type(make_const=False) -> type:
        if make_const:
            return MDSConstULongRecordFieldReference

        return MDSULongRecordFieldReference

cdef class MDSFloatRecordField(MDSRecordFieldBase):
    cdef:
        h_rfield_float_t _handle

    def declare(self, String name, MDSRecordTypeDeclaration rt):
        assert self._handle.is_null()
        print("?> Attempting to get a handle from h_const_mfloat_t.field_in")
        self._handle = h_rfield_float_t(h_const_mfloat_t().field_in(rt._declared_type, name._ish, True))

    @staticmethod
    def get_reference_type(make_const=False) -> type:
        if make_const:
            return MDSConstFloatRecordFieldReference

        return MDSFloatRecordFieldReference

cdef class MDSDoubleRecordField(MDSRecordFieldBase):
    cdef:
        h_rfield_double_t _handle

    def declare(self, String name, MDSRecordTypeDeclaration rt):
        assert self._handle.is_null()
        print("?> Attempting to get a handle from h_const_mdouble_t.field_in")
        self._handle = h_rfield_double_t(h_const_mdouble_t().field_in(rt._declared_type, name._ish, True))

    @staticmethod
    def get_reference_type(make_const=False) -> type:
        if make_const:
            return MDSConstDoubleRecordFieldReference

        return MDSDoubleRecordFieldReference

# END INJECTION


######################################################################### REFERENCES

cdef class MDSConstRecordFieldReferenceBase(MDSObject):
    cdef:
        managed_record_handle _record_handle

    def read(self):
        pass

    def peek(self):
        pass

    def write(self, value):
        self._throw_const_error()


cdef class MDSRecordFieldReferenceBase(MDSConstRecordFieldReferenceBase):

    def write(self, value):
        pass

  # static value_type from_core(const core_api_type &val) {
  #   return mtype().from_core(val);
  # }

  # /*
  #  * When we're and array field, the API read methods only get it as the base
  #  * array pointer, so we need to downcast.  This should be safe
  #  */
  # template<typename U = T, typename = std::enable_if_t<is_mds_array<U>::value>>
  # static value_type from_core(const api::managed_array_base_handle &handle) {
  #   using elt_type = typename mtype::elt_type;
  #   core_api_type h(handle.pointer()->template downcast<elt_type::kind>(),
  #                   handle.view());
  #   return from_core(h);
  # }

  # static core_api_type to_core(const value_type &val) {
  #   return mtype().to_core(val);
  # }

# START INJECTION | tmpl_record_field_reference

cdef class MDSConstBoolRecordFieldReference(MDSConstRecordFieldReferenceBase):
    cdef:
        h_rfield_bool_t _field_handle
        Record _record

    def __cinit__(self, MDSBoolRecordField field, Record record):
        self._record = record
        self._field_handle = h_rfield_bool_t(field._handle)
        self._record_handle = managed_record_handle(record._handle)

    def read(self):
        cdef bool retval = self._field_handle.frozen_read(self._record_handle)
        return retval

    def peek(self):
        cdef bool retval = self._field_handle.free_read(self._record_handle)
        return retval


cdef class MDSBoolRecordFieldReference(MDSConstBoolRecordFieldReference):
    
    def write(self, value):
        self._field_handle.write(self._record_handle, <bool> (value))

cdef class MDSConstByteRecordFieldReference(MDSConstRecordFieldReferenceBase):
    cdef:
        h_rfield_byte_t _field_handle
        Record _record

    def __cinit__(self, MDSByteRecordField field, Record record):
        self._record = record
        self._field_handle = h_rfield_byte_t(field._handle)
        self._record_handle = managed_record_handle(record._handle)

    def read(self):
        cdef int8_t retval = self._field_handle.frozen_read(self._record_handle)
        return retval

    def peek(self):
        cdef int8_t retval = self._field_handle.free_read(self._record_handle)
        return retval


cdef class MDSByteRecordFieldReference(MDSConstByteRecordFieldReference):
    
    def write(self, value):
        self._field_handle.write(self._record_handle, <int8_t> (value))

    def __iadd__(self, other):
        self._field_handle.add(self._record_handle, <int8_t> (other))

    def __isub__(self, other):
        self._field_handle.sub(self._record_handle, <int8_t> (other))

    def __imul__(self, other):
        self._field_handle.mul(self._record_handle, <int8_t> (other))

    def __idiv__(self, other):
        self._field_handle.div(self._record_handle, <int8_t> (other))

cdef class MDSConstUByteRecordFieldReference(MDSConstRecordFieldReferenceBase):
    cdef:
        h_rfield_ubyte_t _field_handle
        Record _record

    def __cinit__(self, MDSUByteRecordField field, Record record):
        self._record = record
        self._field_handle = h_rfield_ubyte_t(field._handle)
        self._record_handle = managed_record_handle(record._handle)

    def read(self):
        cdef uint8_t retval = self._field_handle.frozen_read(self._record_handle)
        return retval

    def peek(self):
        cdef uint8_t retval = self._field_handle.free_read(self._record_handle)
        return retval


cdef class MDSUByteRecordFieldReference(MDSConstUByteRecordFieldReference):
    
    def write(self, value):
        self._field_handle.write(self._record_handle, <uint8_t> (value))

    def __iadd__(self, other):
        self._field_handle.add(self._record_handle, <uint8_t> (other))

    def __isub__(self, other):
        self._field_handle.sub(self._record_handle, <uint8_t> (other))

    def __imul__(self, other):
        self._field_handle.mul(self._record_handle, <uint8_t> (other))

    def __idiv__(self, other):
        self._field_handle.div(self._record_handle, <uint8_t> (other))

cdef class MDSConstShortRecordFieldReference(MDSConstRecordFieldReferenceBase):
    cdef:
        h_rfield_short_t _field_handle
        Record _record

    def __cinit__(self, MDSShortRecordField field, Record record):
        self._record = record
        self._field_handle = h_rfield_short_t(field._handle)
        self._record_handle = managed_record_handle(record._handle)

    def read(self):
        cdef int16_t retval = self._field_handle.frozen_read(self._record_handle)
        return retval

    def peek(self):
        cdef int16_t retval = self._field_handle.free_read(self._record_handle)
        return retval


cdef class MDSShortRecordFieldReference(MDSConstShortRecordFieldReference):
    
    def write(self, value):
        self._field_handle.write(self._record_handle, <int16_t> (value))

    def __iadd__(self, other):
        self._field_handle.add(self._record_handle, <int16_t> (other))

    def __isub__(self, other):
        self._field_handle.sub(self._record_handle, <int16_t> (other))

    def __imul__(self, other):
        self._field_handle.mul(self._record_handle, <int16_t> (other))

    def __idiv__(self, other):
        self._field_handle.div(self._record_handle, <int16_t> (other))

cdef class MDSConstUShortRecordFieldReference(MDSConstRecordFieldReferenceBase):
    cdef:
        h_rfield_ushort_t _field_handle
        Record _record

    def __cinit__(self, MDSUShortRecordField field, Record record):
        self._record = record
        self._field_handle = h_rfield_ushort_t(field._handle)
        self._record_handle = managed_record_handle(record._handle)

    def read(self):
        cdef uint16_t retval = self._field_handle.frozen_read(self._record_handle)
        return retval

    def peek(self):
        cdef uint16_t retval = self._field_handle.free_read(self._record_handle)
        return retval


cdef class MDSUShortRecordFieldReference(MDSConstUShortRecordFieldReference):
    
    def write(self, value):
        self._field_handle.write(self._record_handle, <uint16_t> (value))

    def __iadd__(self, other):
        self._field_handle.add(self._record_handle, <uint16_t> (other))

    def __isub__(self, other):
        self._field_handle.sub(self._record_handle, <uint16_t> (other))

    def __imul__(self, other):
        self._field_handle.mul(self._record_handle, <uint16_t> (other))

    def __idiv__(self, other):
        self._field_handle.div(self._record_handle, <uint16_t> (other))

cdef class MDSConstIntRecordFieldReference(MDSConstRecordFieldReferenceBase):
    cdef:
        h_rfield_int_t _field_handle
        Record _record

    def __cinit__(self, MDSIntRecordField field, Record record):
        self._record = record
        self._field_handle = h_rfield_int_t(field._handle)
        self._record_handle = managed_record_handle(record._handle)

    def read(self):
        cdef int32_t retval = self._field_handle.frozen_read(self._record_handle)
        return retval

    def peek(self):
        cdef int32_t retval = self._field_handle.free_read(self._record_handle)
        return retval


cdef class MDSIntRecordFieldReference(MDSConstIntRecordFieldReference):
    
    def write(self, value):
        self._field_handle.write(self._record_handle, <int32_t> (value))

    def __iadd__(self, other):
        self._field_handle.add(self._record_handle, <int32_t> (other))

    def __isub__(self, other):
        self._field_handle.sub(self._record_handle, <int32_t> (other))

    def __imul__(self, other):
        self._field_handle.mul(self._record_handle, <int32_t> (other))

    def __idiv__(self, other):
        self._field_handle.div(self._record_handle, <int32_t> (other))

cdef class MDSConstUIntRecordFieldReference(MDSConstRecordFieldReferenceBase):
    cdef:
        h_rfield_uint_t _field_handle
        Record _record

    def __cinit__(self, MDSUIntRecordField field, Record record):
        self._record = record
        self._field_handle = h_rfield_uint_t(field._handle)
        self._record_handle = managed_record_handle(record._handle)

    def read(self):
        cdef uint32_t retval = self._field_handle.frozen_read(self._record_handle)
        return retval

    def peek(self):
        cdef uint32_t retval = self._field_handle.free_read(self._record_handle)
        return retval


cdef class MDSUIntRecordFieldReference(MDSConstUIntRecordFieldReference):
    
    def write(self, value):
        self._field_handle.write(self._record_handle, <uint32_t> (value))

    def __iadd__(self, other):
        self._field_handle.add(self._record_handle, <uint32_t> (other))

    def __isub__(self, other):
        self._field_handle.sub(self._record_handle, <uint32_t> (other))

    def __imul__(self, other):
        self._field_handle.mul(self._record_handle, <uint32_t> (other))

    def __idiv__(self, other):
        self._field_handle.div(self._record_handle, <uint32_t> (other))

cdef class MDSConstLongRecordFieldReference(MDSConstRecordFieldReferenceBase):
    cdef:
        h_rfield_long_t _field_handle
        Record _record

    def __cinit__(self, MDSLongRecordField field, Record record):
        self._record = record
        self._field_handle = h_rfield_long_t(field._handle)
        self._record_handle = managed_record_handle(record._handle)

    def read(self):
        cdef int64_t retval = self._field_handle.frozen_read(self._record_handle)
        return retval

    def peek(self):
        cdef int64_t retval = self._field_handle.free_read(self._record_handle)
        return retval


cdef class MDSLongRecordFieldReference(MDSConstLongRecordFieldReference):
    
    def write(self, value):
        self._field_handle.write(self._record_handle, <int64_t> (value))

    def __iadd__(self, other):
        self._field_handle.add(self._record_handle, <int64_t> (other))

    def __isub__(self, other):
        self._field_handle.sub(self._record_handle, <int64_t> (other))

    def __imul__(self, other):
        self._field_handle.mul(self._record_handle, <int64_t> (other))

    def __idiv__(self, other):
        self._field_handle.div(self._record_handle, <int64_t> (other))

cdef class MDSConstULongRecordFieldReference(MDSConstRecordFieldReferenceBase):
    cdef:
        h_rfield_ulong_t _field_handle
        Record _record

    def __cinit__(self, MDSULongRecordField field, Record record):
        self._record = record
        self._field_handle = h_rfield_ulong_t(field._handle)
        self._record_handle = managed_record_handle(record._handle)

    def read(self):
        cdef uint64_t retval = self._field_handle.frozen_read(self._record_handle)
        return retval

    def peek(self):
        cdef uint64_t retval = self._field_handle.free_read(self._record_handle)
        return retval


cdef class MDSULongRecordFieldReference(MDSConstULongRecordFieldReference):
    
    def write(self, value):
        self._field_handle.write(self._record_handle, <uint64_t> (value))

    def __iadd__(self, other):
        self._field_handle.add(self._record_handle, <uint64_t> (other))

    def __isub__(self, other):
        self._field_handle.sub(self._record_handle, <uint64_t> (other))

    def __imul__(self, other):
        self._field_handle.mul(self._record_handle, <uint64_t> (other))

    def __idiv__(self, other):
        self._field_handle.div(self._record_handle, <uint64_t> (other))

cdef class MDSConstFloatRecordFieldReference(MDSConstRecordFieldReferenceBase):
    cdef:
        h_rfield_float_t _field_handle
        Record _record

    def __cinit__(self, MDSFloatRecordField field, Record record):
        self._record = record
        self._field_handle = h_rfield_float_t(field._handle)
        self._record_handle = managed_record_handle(record._handle)

    def read(self):
        cdef float retval = self._field_handle.frozen_read(self._record_handle)
        return retval

    def peek(self):
        cdef float retval = self._field_handle.free_read(self._record_handle)
        return retval


cdef class MDSFloatRecordFieldReference(MDSConstFloatRecordFieldReference):
    
    def write(self, value):
        self._field_handle.write(self._record_handle, <float> (value))

    def __iadd__(self, other):
        self._field_handle.add(self._record_handle, <float> (other))

    def __isub__(self, other):
        self._field_handle.sub(self._record_handle, <float> (other))

    def __imul__(self, other):
        self._field_handle.mul(self._record_handle, <float> (other))

    def __idiv__(self, other):
        self._field_handle.div(self._record_handle, <float> (other))

cdef class MDSConstDoubleRecordFieldReference(MDSConstRecordFieldReferenceBase):
    cdef:
        h_rfield_double_t _field_handle
        Record _record

    def __cinit__(self, MDSDoubleRecordField field, Record record):
        self._record = record
        self._field_handle = h_rfield_double_t(field._handle)
        self._record_handle = managed_record_handle(record._handle)

    def read(self):
        cdef double retval = self._field_handle.frozen_read(self._record_handle)
        return retval

    def peek(self):
        cdef double retval = self._field_handle.free_read(self._record_handle)
        return retval


cdef class MDSDoubleRecordFieldReference(MDSConstDoubleRecordFieldReference):
    
    def write(self, value):
        self._field_handle.write(self._record_handle, <double> (value))

    def __iadd__(self, other):
        self._field_handle.add(self._record_handle, <double> (other))

    def __isub__(self, other):
        self._field_handle.sub(self._record_handle, <double> (other))

    def __imul__(self, other):
        self._field_handle.mul(self._record_handle, <double> (other))

    def __idiv__(self, other):
        self._field_handle.div(self._record_handle, <double> (other))

# END INJECTION

############################################################# RECORD MEMBERS

cdef class MDSRecordMemberBase(MDSObject):
    cdef:
        Record _enclosing

    # using value_type = typename record_field<R,T>::value_type;

    def __cinit__(self, Record record, initial_value=None):
        self._enclosing = record

        if initial_value is not None:
            self.write(initial_value)

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        """
        Confusingly, in the MDS hierarchy, const_reference is the parent of
        reference, so the return type of this function may look to restrictive.
        It isn't.

        This is the actual RecordField, not Base... Need to think about this
        """
        pass

    def read(self):
        pass

    def peek(self):
        pass

    def write(self, value):
        pass

    property record:
        def __get__(self):
            return self._enclosing


cdef class MDSConstRecordMemberBase(MDSRecordMemberBase):
    cdef:
        bint _is_cached

    def __cinit__(self, Record record, initial_value=None):
        """
        Delegate record upwards, but deal with `initial_value` here,
        as we only want to write at instantiation. @TODO
        """
        super().__init__(record=record, initial_value=None)

        if initial_value is not None:
            pass # TODO: Do something

    def write(self, value):
        self._throw_const_error()


# START INJECTION | tmpl_record_member

cdef class MDSConstBoolRecordMember(MDSConstRecordMemberBase):
    cdef bool _cached_val

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSBoolRecordField()[self]

    def read(self):
        if not self._is_cached:
            field_ref = self._field_ref()
            self._cached_val = field_ref.read()
            self._is_cached = True

        return self._cached_val

    def peek(self):
        return self.read()

cdef class MDSBoolRecordMember(MDSRecordMemberBase):

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSBoolRecordField()[self]

    def read(self):
        return self._field_ref().read()

    def peek(self):
        return self._field_ref().peek()

    def write(self, value) -> None:
        self._field_ref().write(<bool> value);

cdef class MDSConstByteRecordMember(MDSConstRecordMemberBase):
    cdef int8_t _cached_val

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSByteRecordField()[self]

    def read(self):
        if not self._is_cached:
            field_ref = self._field_ref()
            self._cached_val = field_ref.read()
            self._is_cached = True

        return self._cached_val

    def peek(self):
        return self.read()

cdef class MDSByteRecordMember(MDSRecordMemberBase):

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSByteRecordField()[self]

    def read(self):
        return self._field_ref().read()

    def peek(self):
        return self._field_ref().peek()

    def write(self, value) -> None:
        self._field_ref().write(<int8_t> value);

    def __iadd__(self, other):
        ref = self._field_ref()
        ref += other

    def __isub__(self, other):
        ref = self._field_ref()
        ref -= other

    def __imul__(self, other):
        ref = self._field_ref()
        ref *= other

    def __idiv__(self, other):
        ref = self._field_ref()
        ref /= other

cdef class MDSConstUByteRecordMember(MDSConstRecordMemberBase):
    cdef uint8_t _cached_val

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSUByteRecordField()[self]

    def read(self):
        if not self._is_cached:
            field_ref = self._field_ref()
            self._cached_val = field_ref.read()
            self._is_cached = True

        return self._cached_val

    def peek(self):
        return self.read()

cdef class MDSUByteRecordMember(MDSRecordMemberBase):

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSUByteRecordField()[self]

    def read(self):
        return self._field_ref().read()

    def peek(self):
        return self._field_ref().peek()

    def write(self, value) -> None:
        self._field_ref().write(<uint8_t> value);

    def __iadd__(self, other):
        ref = self._field_ref()
        ref += other

    def __isub__(self, other):
        ref = self._field_ref()
        ref -= other

    def __imul__(self, other):
        ref = self._field_ref()
        ref *= other

    def __idiv__(self, other):
        ref = self._field_ref()
        ref /= other

cdef class MDSConstShortRecordMember(MDSConstRecordMemberBase):
    cdef int16_t _cached_val

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSShortRecordField()[self]

    def read(self):
        if not self._is_cached:
            field_ref = self._field_ref()
            self._cached_val = field_ref.read()
            self._is_cached = True

        return self._cached_val

    def peek(self):
        return self.read()

cdef class MDSShortRecordMember(MDSRecordMemberBase):

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSShortRecordField()[self]

    def read(self):
        return self._field_ref().read()

    def peek(self):
        return self._field_ref().peek()

    def write(self, value) -> None:
        self._field_ref().write(<int16_t> value);

    def __iadd__(self, other):
        ref = self._field_ref()
        ref += other

    def __isub__(self, other):
        ref = self._field_ref()
        ref -= other

    def __imul__(self, other):
        ref = self._field_ref()
        ref *= other

    def __idiv__(self, other):
        ref = self._field_ref()
        ref /= other

cdef class MDSConstUShortRecordMember(MDSConstRecordMemberBase):
    cdef uint16_t _cached_val

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSUShortRecordField()[self]

    def read(self):
        if not self._is_cached:
            field_ref = self._field_ref()
            self._cached_val = field_ref.read()
            self._is_cached = True

        return self._cached_val

    def peek(self):
        return self.read()

cdef class MDSUShortRecordMember(MDSRecordMemberBase):

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSUShortRecordField()[self]

    def read(self):
        return self._field_ref().read()

    def peek(self):
        return self._field_ref().peek()

    def write(self, value) -> None:
        self._field_ref().write(<uint16_t> value);

    def __iadd__(self, other):
        ref = self._field_ref()
        ref += other

    def __isub__(self, other):
        ref = self._field_ref()
        ref -= other

    def __imul__(self, other):
        ref = self._field_ref()
        ref *= other

    def __idiv__(self, other):
        ref = self._field_ref()
        ref /= other

cdef class MDSConstIntRecordMember(MDSConstRecordMemberBase):
    cdef int32_t _cached_val

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSIntRecordField()[self]

    def read(self):
        if not self._is_cached:
            field_ref = self._field_ref()
            self._cached_val = field_ref.read()
            self._is_cached = True

        return self._cached_val

    def peek(self):
        return self.read()

cdef class MDSIntRecordMember(MDSRecordMemberBase):

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSIntRecordField()[self]

    def read(self):
        return self._field_ref().read()

    def peek(self):
        return self._field_ref().peek()

    def write(self, value) -> None:
        self._field_ref().write(<int32_t> value);

    def __iadd__(self, other):
        ref = self._field_ref()
        ref += other

    def __isub__(self, other):
        ref = self._field_ref()
        ref -= other

    def __imul__(self, other):
        ref = self._field_ref()
        ref *= other

    def __idiv__(self, other):
        ref = self._field_ref()
        ref /= other

cdef class MDSConstUIntRecordMember(MDSConstRecordMemberBase):
    cdef uint32_t _cached_val

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSUIntRecordField()[self]

    def read(self):
        if not self._is_cached:
            field_ref = self._field_ref()
            self._cached_val = field_ref.read()
            self._is_cached = True

        return self._cached_val

    def peek(self):
        return self.read()

cdef class MDSUIntRecordMember(MDSRecordMemberBase):

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSUIntRecordField()[self]

    def read(self):
        return self._field_ref().read()

    def peek(self):
        return self._field_ref().peek()

    def write(self, value) -> None:
        self._field_ref().write(<uint32_t> value);

    def __iadd__(self, other):
        ref = self._field_ref()
        ref += other

    def __isub__(self, other):
        ref = self._field_ref()
        ref -= other

    def __imul__(self, other):
        ref = self._field_ref()
        ref *= other

    def __idiv__(self, other):
        ref = self._field_ref()
        ref /= other

cdef class MDSConstLongRecordMember(MDSConstRecordMemberBase):
    cdef int64_t _cached_val

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSLongRecordField()[self]

    def read(self):
        if not self._is_cached:
            field_ref = self._field_ref()
            self._cached_val = field_ref.read()
            self._is_cached = True

        return self._cached_val

    def peek(self):
        return self.read()

cdef class MDSLongRecordMember(MDSRecordMemberBase):

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSLongRecordField()[self]

    def read(self):
        return self._field_ref().read()

    def peek(self):
        return self._field_ref().peek()

    def write(self, value) -> None:
        self._field_ref().write(<int64_t> value);

    def __iadd__(self, other):
        ref = self._field_ref()
        ref += other

    def __isub__(self, other):
        ref = self._field_ref()
        ref -= other

    def __imul__(self, other):
        ref = self._field_ref()
        ref *= other

    def __idiv__(self, other):
        ref = self._field_ref()
        ref /= other

cdef class MDSConstULongRecordMember(MDSConstRecordMemberBase):
    cdef uint64_t _cached_val

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSULongRecordField()[self]

    def read(self):
        if not self._is_cached:
            field_ref = self._field_ref()
            self._cached_val = field_ref.read()
            self._is_cached = True

        return self._cached_val

    def peek(self):
        return self.read()

cdef class MDSULongRecordMember(MDSRecordMemberBase):

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSULongRecordField()[self]

    def read(self):
        return self._field_ref().read()

    def peek(self):
        return self._field_ref().peek()

    def write(self, value) -> None:
        self._field_ref().write(<uint64_t> value);

    def __iadd__(self, other):
        ref = self._field_ref()
        ref += other

    def __isub__(self, other):
        ref = self._field_ref()
        ref -= other

    def __imul__(self, other):
        ref = self._field_ref()
        ref *= other

    def __idiv__(self, other):
        ref = self._field_ref()
        ref /= other

cdef class MDSConstFloatRecordMember(MDSConstRecordMemberBase):
    cdef float _cached_val

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSFloatRecordField()[self]

    def read(self):
        if not self._is_cached:
            field_ref = self._field_ref()
            self._cached_val = field_ref.read()
            self._is_cached = True

        return self._cached_val

    def peek(self):
        return self.read()

cdef class MDSFloatRecordMember(MDSRecordMemberBase):

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSFloatRecordField()[self]

    def read(self):
        return self._field_ref().read()

    def peek(self):
        return self._field_ref().peek()

    def write(self, value) -> None:
        self._field_ref().write(<float> value);

    def __iadd__(self, other):
        ref = self._field_ref()
        ref += other

    def __isub__(self, other):
        ref = self._field_ref()
        ref -= other

    def __imul__(self, other):
        ref = self._field_ref()
        ref *= other

    def __idiv__(self, other):
        ref = self._field_ref()
        ref /= other

cdef class MDSConstDoubleRecordMember(MDSConstRecordMemberBase):
    cdef double _cached_val

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSDoubleRecordField()[self]

    def read(self):
        if not self._is_cached:
            field_ref = self._field_ref()
            self._cached_val = field_ref.read()
            self._is_cached = True

        return self._cached_val

    def peek(self):
        return self.read()

cdef class MDSDoubleRecordMember(MDSRecordMemberBase):

    def _field_ref(self) -> MDSConstRecordFieldReferenceBase:
        return MDSDoubleRecordField()[self]

    def read(self):
        return self._field_ref().read()

    def peek(self):
        return self._field_ref().peek()

    def write(self, value) -> None:
        self._field_ref().write(<double> value);

    def __iadd__(self, other):
        ref = self._field_ref()
        ref += other

    def __isub__(self, other):
        ref = self._field_ref()
        ref -= other

    def __imul__(self, other):
        ref = self._field_ref()
        ref *= other

    def __idiv__(self, other):
        ref = self._field_ref()
        ref /= other

# END INJECTION

######################################################### RECORD TYPE DECLARATIONS

class MDSRecordFieldDeclaration(object):
    """
    This could probably be avoided, but it's copying CAPI
    """

    def __init__(self, name: String, field: MDSRecordFieldBase):
        self.name = name
        self.field = field


cdef class MDSRecordHandleWrapper(object):
    cdef:
        record_type_handle _handle


cdef class MDSConstRecordHandleWrapper(object):
    cdef:
        const_record_type_handle _handle


cdef emplace_handle(record_type_handle wrapped):
    wrapper = MDSRecordHandleWrapper()
    wrapper._handle = wrapped
    return wrapper

cdef emplace_const_handle_from_decl(MDSRecordTypeDeclaration decl):
    wrapper = MDSConstRecordHandleWrapper()
    wrapper._handle = decl._created_type
    return wrapper


cdef MDSRecordHandleWrapper declare_mds_record(interned_string_handle ish, MDSConstRecordHandleWrapper wrapper):
    cdef:
        MDSRecordHandleWrapper retval = MDSRecordHandleWrapper()
        const_record_type_handle unwrapped_handle = wrapper._handle
        record_type_handle new_handle = record_type_handle.declare(ish, unwrapped_handle)

    retval._handle = new_handle
    return retval

cdef class MDSRecordTypeDeclaration(object):
    cdef:
        list _field_decls
        dict _field_member_pairs
        record_type_handle _declared_type
        const_record_type_handle _created_type
        type _cls

    def __cinit__(self, cls: type, field_member_pairs: dict):
        # TODO: Get rid of fields, invole cls.schema() directly and delegate here
        # TODO: This assumes singular inheritance path for Record, could probably do getmro...
        cdef MDSRecordHandleWrapper wrapper = self.declare(
            String(__RECORD_IDENTS[cls.__name__]),
            cls.__bases__[0]
        )

        self._declared_type = record_type_handle(wrapper._handle)
        self._cls = cls
        self._field_decls = list()
        self._field_member_pairs = field_member_pairs
        self.note_fields(field_member_pairs)

    def get_field_member_pairs(self) -> dict:
        return self._field_member_pairs

    @staticmethod
    def declare(name: String, parent: type) -> MDSRecordHandleWrapper:
        """
        The logic of this, from the CAPI, is that we want to declare a type
        of name `name`, and we check its ancestor;

        1) If the ancestor is Record, just declare it.
        2) If the direct ancestor is not Record, make sure that
           itself is an instance thereof

        TODO: s should be a parameterized managed_type<R>?
        """
        print(f"?> Declaring {name} with parent {parent.__name__}")
        cdef interned_string_handle ish = extract_ish(name)

        if parent is None or parent is Record:
            return emplace_handle(record_type_handle.declare(ish, const_record_type_handle()))

        assert issubclass(parent, Record), "Super type not a record type"
        print(f" > Passed subclass assertion")
        # As soon as `s` came into scope, it should have registered its type,
        # so this is unnecessary, but left in for posterity.
        sp = parent.type_decl.ensure_created()  # MDSConstRecordHandleWrapper
        print(f" > Ensure created run OK on parent, returned {sp}")
        return declare_mds_record(ish, sp)

    def note_fields(self, fields: dict) -> None:
        for label, field_member_pair in fields.items():
            self._field_decls.append(
                MDSRecordFieldDeclaration(
                    String(label),  # We want to grab the interned_string_handle later
                    field_member_pair.field
                )
            )

    def declare_fields(self) -> None:
        for fd in self._field_decls:
            fd.field.declare(fd.name, self)

    def ensure_field_types(self) -> None:
        for fd in self._field_decls:
            fd.field.ensure_type()

    def ensure_created(self) -> MDSConstRecordHandleWrapper:
        ident = __RECORD_IDENTS[self._cls.__name__]

        if not ident in __RECORD_DECLARED_TYPES:
            with __RECORD_DECLARATION_MUTEX:
                # Ensure no one else has beat us to the punch (call_once)
                if not ident in __RECORD_DECLARED_TYPES:
                    self.declare_fields()
                    self._created_type = const_record_type_handle(self._declared_type.ensure_created())
                    # We want to keep a copy of this alive so we don't have to rebuild it
                    # MDSRecordCreator.register_type(self)
                    self.ensure_field_types()
                    __RECORD_DECLARED_TYPES[ident] = self

        return emplace_const_handle_from_decl(__RECORD_DECLARED_TYPES[ident])


# =========================================================================
#  Strings
# =========================================================================


cdef class String(MDSObject):
    """
    This class provides the functionality expected from the native str type,
    but backed by MDS. As with str, Strings are immutable.
    """

    cdef:
        managed_string_handle _handle
        interned_string_handle _ish
        int __iter_idx

    def __cinit__(self, value=""):
        self._ish = convert_py_to_ish(value) 
        self._handle = managed_string_handle(self._ish)
        self.__iter_idx = 0

    def __len__(self):
        return self._handle.length()

    def __hash__(self):
        return self._handle.hash1()

    def __iter__(self):
        self.__iter_idx = 0
        return self

    def __next__(self):
        if self.__iter_idx < len(self):
            retval = self[self.__iter_idx]
            self.__iter_idx += 1
            return retval
        else:
            raise StopIteration

    def __str__(self):
        return <str> self._handle.utf8().decode("utf-8")

    def __repr__(self):
        return "'{}'".format(str(self))

    def __getitem__(self, item):
        cdef:
            string s
            int i
            char_type c

        if isinstance(item, int):
            c = self._handle.at(item)
            u = chr(c)
            return u
        elif isinstance(item, slice):
            # TODO: Check this
            s.reserve((item.stop - item.start) // item.step)

            for i in range(start=item.start, stop=item.stop, step=item.step):
                s.push_back(self._handle.at(i))

            return String(s)

        raise TypeError(
            "list indices must be integers or slices, not {}".format(
                type(item)
            )
        )

    def __add__(self, other):
        """
        Concatenates this string with another, returns this as a new String
        """
        # TODO: Could probably open this to [str, bytes] too.
        cdef:
            string s
            str c

        if isinstance(other, String):       
            s.reserve(<size_t> (len(self) + len(other)))

            # Chain the iterators to avoid any string copying
            for c in chain(iter(self), iter(other)):
                s.push_back(ord(c))  # Need as an int for char

            return String(s)

        raise TypeError("must be String")

    def __mul__(self, other):
        """
        Internal method to perform String multiplication without overhead
        """
        cdef:
            string s
            str c
            int it, l = len(self)

        if isinstance(other, int):
            s.reserve(l * other)

            for it in range(other):
                for c in self:
                    s.push_back(ord(c))

            return String(<unicode> s.decode("utf-8"))

        raise TypeError(
            "can't multiply sequence by non-int of type 'String'"
        )

    def __rmul__(self, other):
        pass

    def __mod__(self, other):
        pass

    def __rmod__(self, other):
        pass

    def __richcmp__(a, b, op):
        if op == 0:    # <
            return a._handle < b._handle
        elif op == 1:  # <=
            return a._handle <= b._handle
        elif op == 2:  # ==
            return a._handle == b._handle
        elif op == 3:  # !=
            return a._handle != b._handle
        elif op == 4:  # >
            return a._handle > b._handle
        elif op == 5:  # >=
            return a._handle >= b._handle

    def __sizeof__(self):
        return self._handle.size()

    # TODO: Write equivalents that use the MDS-stored data

    def capitalize(self):
        return String(str(self).capitalize())

    def casefold(self):
        return String(str(self).casefold())

    def center(self, *args, **kwargs):
        return String(str(self).center(*args, **kwargs))

    # TODO: encode(encoding="utf-8", errors="strict")

    def endswith(self, *args, **kwargs):
        return str(self).endswith(*args, **kwargs)

    def expandtabs(self, *args, **kwargs):
        return String(str(self).expandtabs(*args, **kwargs))

    def find(self, *args, **kwargs):
        return str(self).find(*args, **kwargs)

    def format(self, *args, **kwargs):
        return String(str(self).format(*args, **kwargs))

    def format_map(self, *args, **kwargs):
        return String(str(self).format_map(*args, **kwargs))

    def index(self, *args, **kwargs):
        return str(self).index(*args, **kwargs)

    def isalnum(self, *args, **kwargs):
        return str(self).isalnum(*args, **kwargs)

    def isalpha(self, *args, **kwargs):
        return str(self).isalpha(*args, **kwargs)

    def isdecimal(self, *args, **kwargs):
        return str(self).isdecimal(*args, **kwargs)

    def isdigit(self, *args, **kwargs):
        return str(self).isdigit(*args, **kwargs)
    
    def isidentifier(self, *args, **kwargs):
        return str(self).isidentifier(*args, **kwargs)
    
    def islower(self, *args, **kwargs):
        return str(self).islower(*args, **kwargs)

    def isnumeric(self, *args, **kwargs):
        return str(self).isnumeric(*args, **kwargs)

    def isprintable(self, *args, **kwargs):
        return str(self).isprintable(*args, **kwargs)

    def isspace(self, *args, **kwargs):
        return str(self).isspace(*args, **kwargs)

    def istitle(self, *args, **kwargs):
        return str(self).istitle(*args, **kwargs)

    def isupper(self, *args, **kwargs):
        return str(self).isupper(*args, **kwargs)

    def join(self, *args, **kwargs):
        return String(str(self).join(*args, **kwargs))

    def ljust(self, *args, **kwargs):
        return String(str(self).ljust(*args, **kwargs))

    def lower(self, *args, **kwargs):
        return String(str(self).lower(*args, **kwargs))

    def lstrip(self, *args, **kwargs):
        return String(str(self).lstrip(*args, **kwargs))

    def partition(self, *args, **kwargs):
        return tuple([String(x) for x in str(self).partition(*args, **kwargs)])

    def replace(self, *args, **kwargs):
        return String(str(self).replace(*args, **kwargs))

    def rfind(self, *args, **kwargs):
        return str(self).rfind(*args, **kwargs)

    def rindex(self, *args, **kwargs):
        return str(self).rindex(*args, **kwargs)

    def rjust(self, *args, **kwargs):
        return String(str(self).rjust(*args, **kwargs))

    def rpartition(self, *args, **kwargs):
        return tuple([String(x) for x in str(self).rpartition(*args, **kwargs)])

    def rsplit(self, *args, **kwargs):
        return [String(x) for x in str(self).rsplit(*args, **kwargs)]

    def rstrip(self, *args, **kwargs):
        return String(str(self).rstrip(*args, **kwargs))

    def split(self, *args, **kwargs):
        return [String(x) for x in str(self).split(*args, **kwargs)]

    def splitlines(self, *args, **kwargs):
        return [String(x) for x in str(self).split(*args, **kwargs)]

    def startswith(self, *args, **kwargs):
        return str(self).startswith(*args, **kwargs)

    def strip(self, *args, **kwargs):
        return String(str(self).strip(*args, **kwargs))
    
    def swapcase(self, *args, **kwargs):
        return String(str(self).swapcase(*args, **kwargs))

    def title(self, *args, **kwargs):
        return String(str(self).title(*args, **kwargs))

    # TODO: translate

    def upper(self, *args, **kwargs):
        return String(str(self).upper(*args, **kwargs))

    def zfill(self, *args, **kwargs):
        return String(str(self).zfill(*args, **kwargs))


cdef inline interned_string_handle extract_ish(String s):
    cdef interned_string_handle retval = s._ish
    return retval

# =========================================================================
#  Namespace
# =========================================================================

PathTypes = Union[str, String, Path]
cdef NAMESPACE_SEPARATOR = "/"

class IllegalPathException(Exception):
    
    def __init__(self, path: Path, *args, **kwargs):
        self._path = path
        super().__init__(*args, **kwargs)


cdef class Path(object):
    cdef:
        Impl _ptr

    def __cinit__(self, impl=None):
        if isinstance(impl, Impl):
            self._ptr = impl
        else:
            self._ptr = Impl()

    @staticmethod
    def of(cpts: List[Path]) -> Path:
        return Path(impl=Impl(cpts))

    def is_absolute(self):
        return self._ptr.is_absolute()

    def resolve(self, cpts: List[Path]) -> Path:
        return Path(impl=self._ptr.resolve(cpts))

    def __str__(self):
        return str(self._ptr)


cdef Impl __copy_Impl(Impl origin):
    cdef impl = Impl()
    impl._names = origin.names.copy()
    impl._initial_ups = origin.initial_ups
    impl._absolutep = origin.absolutep
    return impl


cdef class Impl(object):
    cdef:
        bool _absolutep
        size_t _initial_ups
        list _names

    def __cinit__(self, cpts: List[Path]):
        self._absolutep = False
        self._initial_ups = 0
        self._names = list()

        self.extend(cpts)

    def __str__(self):
        printsep = self._absolutep
        buff = ""

        for i in range(self._initial_ups):
            if printsep:
                buff += NAMESPACE_SEPARATOR

            buff += ".."
            printsep = True

        for s in self._names:
            if printsep:
                buf += NAMESPACE_SEPARATOR

            buf += str(s)
            printsep = True

        return buff

    def up_levels(self, size_t levels) -> None:
        current = len(self._names)

        if not self._absolutep and (levels > current):
            self._initial_ups += levels - current

    def reset_to_root(self) -> None:
        self._names = list()
        self._initial_ups = 0
        self._absolutep = True

    @staticmethod
    def self_cpt() -> String:
        return String(".")

    @staticmethod
    def up_cpt() -> String:
        return String("..")

    def append(self, cpt: String) -> None:
        if cpt == self.self_cpt():
            return
        elif cpt == self.up_cpt():
            self.up_levels(1)
        else:
            self._names.append(cpt)

    def is_absolute(self):
        return <bint> self._absolutep

    def extend(self, cpts: List[Path], absolute=False) -> None:
        if absolute:
            self.reset_to_root()

        for cpt in cpts:
            self.append_cpt(cpt)

    def copy(self) -> Impl:
        return __copy_Impl(self)

    def resolve(self, cpts: List[Path]) -> Impl:
        impl = self.copy()
        impl.extend(cpts)

        return impl

    def append_cpt(self, cpt: Union[Path, String]) -> None:
        cdef:
            Impl impl
            size_t ups

        if isinstance(cpt, Path):
            impl = cpt._ptr

            if impl._absolutep:
                self.reset_to_root()
            else:
                ups = impl._initial_ups

                if ups:
                    self.up_levels(ups)

            self._names.extend(impl._names.copy())
        else:  # TODO: Change this when String supports .split() and __contains__
            delim = NAMESPACE_SEPARATOR
            s = str(cpt)

            if delim in s:
                self.append(cpt)
                return

            if s.startswith(delim):
                self.reset_to_root()

            parts = [String(x) for x in s.split(delim)]

            for name in parts:
                self.append(name)

    property absolutep:
        def __get__(self):
            return self._absolutep

    property names:
        def __get__(self) -> List[String]:
            return self._names

    property initial_ups:
        def __get__(self) -> int:
            return self._initial_ups


ctypedef fused strings:
    str
    String

cdef String __cast_to_mds_string(strings possible_str):
    if isinstance(possible_str, str):
        return String(possible_str)

    return possible_str

cdef __NAMESPACE_ROOT = None

cdef bint __namespaces_equal(Namespace a, Namespace b):
    return a._handle == b._handle


cdef class Namespace(MDSObject):
    cdef:
        namespace_handle _handle
        Namespace _parent
        String _name

    def __cinit__(self, Namespace parent, name):
        cdef:
            String definite = __cast_to_mds_string(name)

        self._parent = parent
        self._name = definite

    def __setitem__(self, path: PathTypes, value: MDSObject):
        binding = self[path]
        binding.bind(value)

    def __getitem__(self, path: PathTypes) -> NameBinding:
        """
        So this is basically an amalgamation of at() and _at() in the CAPI
        """

        if isinstance(path, str) or isinstance(path, String):
            path = Path.of(path)

        if path.is_absolute():
            raise IllegalPathException(path)

        return self.resolve_to_binding(path)

    def resolve(self, p: Path, include_last=True) -> Namespace:
        cdef:
            Impl pi = p._ptr
            Namespace iptr = self

        if p.is_absolute():
            iptr = Namespace.root()

        for i in range(pi.initial_ups):
            if iptr.is_root():
                raise IllegalPathException(p)

            iptr = iptr.parent()

        names = pi.names

        if not names:
            if include_last:
                return iptr
            if iptr.is_root():
                raise IllegalPathException(p)

            return iptr

        n = len(names)

        if not include_last:
            n -= 1

        for i in range(n):
            nb = NameBinding(iptr, names[i])
            iptr = nb.as_namespace()

        return iptr

    def resolve_to_binding(self, p: Path) -> NameBinding:
        cdef:
            Namespace ip = self.resolve(p=p, include_last=False)
            Impl pi = p._ptr
            list names = pi.names
            String name = String() if len(names) == 0 else names[-1]

        return NameBinding(ip, name)

    @staticmethod
    def make(parent: Namespace, name: PathTypes):
        initialize_base_task()  # Orig: ensure_thread_initialized()
        return Namespace(parent=parent, name=name)

    @staticmethod
    def root():
        global __NAMESPACE_ROOT

        if __NAMESPACE_ROOT is None:
            __NAMESPACE_ROOT = Namespace_Init(namespace_handle._global(), None, String())

        return __NAMESPACE_ROOT

    @staticmethod
    def current():
        # TODO: This originally passes back a reference, so it can be updated. See
        #       Where and how this is used.
        return Namespace.root()

    def parent(self) -> Namespace:
        # TODO: Const namespace?
        if self.is_root():
            return Namespace.root()

        return self._parent

    def name(self) -> String:
        return self._name

    def is_root(self):
        return __namespaces_equal(self, Namespace.root()) # TODO Cython 0.27

    @staticmethod
    def from_path(path: PathTypes) -> Namespace:
        p = Path.of(path)
        base = Namespace.root() if p.is_absolute() else Namespace.current()
        return base.resolve(p)

    @staticmethod
    def from_absolute_path(path: PathTypes) -> Namespace:
        p = Path.of(path)
        return Namespace.root().resolve(p)

    # def create_child(self, child_id: PathTypes, create_if_missing=True) -> Optional[Namespace]:
    #     cdef:
    #         interned_string_handle ish
    #         namespace_handle handle
    #         String definite

    #     definite = __cast_to_mds_string(child_id)
    #     ish = definite._ish
    #     handle = self._handle.child_namespace(ish, <bint> create_if_missing)

    #     if handle.is_null():
    #         return None

    #     return Namespace_Init(handle=handle)


    # @staticmethod
    # def get_global() -> Namespace:
    #     return Namespace_Init(handle=namespace_handle._global())

    # @staticmethod
    # def get_current():
    #     # TODO: When is this set? Check the CAPI / JAPI
    #     return Namespace_Init(handle=current_namespace())

    property SEPARATOR:
        def __get__(self):
            return NAMESPACE_SEPARATOR


cdef inline Namespace_Init(namespace_handle handle, Namespace parent, String name):
    initialize_base_task()
    result = Namespace(parent=parent, name=name)
    result._handle = handle
    return result


cdef class NameBindingBase(object):
    cdef:
        Namespace _namespace
        String _name

    def __cinit__(self, Namespace ns, String n):
        self._namespace = ns
        self._name = n

    def is_bound(self):
        return self._namespace._handle.is_bound(self._name._ish)

    def bind(self, *args, **kwargs):
        pass


cdef class NameBinding(NameBindingBase):
    cdef:
        bint _root_binding

    def __cinit__(self, Namespace ns, String n):
        super().__init__(ns, n)
        self._root_binding = False

        if not len(n):
            if ns.is_root():
                self._root_binding = True
                self._namespace = None
            else:
                self._name = ns.name()
                self._namespace = ns.parent()

    def as_type(self, t: TypeInfo) -> TypedNameBinding:
        # TODO: This doesn't take a third param, plus are Primitives the same as ManagedTypes?
        mappings = {
            # START INJECTION | tmpl_namespace_mapping
            mds.typing.bool: BoolNameBinding,
            mds.typing.byte: ByteNameBinding,
            mds.typing.ubyte: UByteNameBinding,
            mds.typing.short: ShortNameBinding,
            mds.typing.ushort: UShortNameBinding,
            mds.typing.int: IntNameBinding,
            mds.typing.uint: UIntNameBinding,
            mds.typing.long: LongNameBinding,
            mds.typing.ulong: ULongNameBinding,
            mds.typing.float: FloatNameBinding,
            mds.typing.double: DoubleNameBinding,

            # END INJECTION
        }

        if t not in mappings:
            raise TypeError(f"No way to cast to type `{t}`")

        return mappings[t](self._namespace, self._name)

    def as_array(self, array_type: TypeInfo, make_const=False) -> MDSArrayBase:
        # TODO: Const isn't set here
        classname = array_type.title_const_array if make_const else array_type.title_array
        klass = globals()[classname]
        return self.as_type(klass)

    def as_namespace(self) -> Namespace:
        cdef:
            interned_string_handle nhandle = self._name._ish
            namespace_handle h = self._namespace._handle
            namespace_handle ch

        if self._root_binding:
            return Namespace.root()

        ch = h.child_namespace(nhandle, True)
        return Namespace_Init(handle=ch, parent=self._namespace, name=self._name)

    def bind(self, value: MDSPrimitiveBase):
        # cdef:
        #     interned_string_handle nhandle = self._name._ish
        #     namespace_handle h = self._namespace._handle
        if not isinstance(value, MDSPrimitiveBase):
            raise TypeError("Can't bind a non `MDSObject`")
        # I can either do an if/elif for every possible wrapper, or just
        # delegate to it. I'll do the latter.
        # h.bind<managed_type<T>::kind>(nhandle, std::forward<T>(val));
        # h.bind(nhandle, value)
        value.bind_to_namespace(namespace=self._namespace, name=self._name)
        

cdef class TypedNameBinding(NameBindingBase):

    def __cinit__(self, Namespace ns, String n):
        super().__init__(ns, n)

    def get(self):
        pass

    def bind(self, val):
        pass

    def check(self):
        # Removed `allow_unbound` param as differentiating between the core
        # exceptions isn't trivial in Cython, also has the benefit of meaning
        # the return value of the function is consistent with its name.
        pass

# START INJECTION | tmpl_namespace_typed_bindings

cdef class BoolNameBinding(TypedNameBinding):
    cdef:
        h_mbool_t _type

    def get(self) -> Optional[object]:
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mbool_t thandle = self._type
            namespace_handle h = self._namespace._handle
        try:
            return <bool> h.lookup_bool(nhandle, thandle) # this was from_core
        except:  # unbound_name_ex
            return None

    def bind(self, bool val) -> None:
        cdef:
            interned_string_handle nhandle = self._name._ish
            namespace_handle h = self._namespace._handle

        h.bind_bool(nhandle, <bool> val)

    def check(self):
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mbool_t thandle = self._type
            namespace_handle h = self._namespace._handle

        try:
            h.lookup_bool(nhandle, thandle)
            return True
        except:
            return False

cdef class ByteNameBinding(TypedNameBinding):
    cdef:
        h_mbyte_t _type

    def get(self) -> Optional[object]:
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mbyte_t thandle = self._type
            namespace_handle h = self._namespace._handle
        try:
            return <int8_t> h.lookup_byte(nhandle, thandle) # this was from_core
        except:  # unbound_name_ex
            return None

    def bind(self, int8_t val) -> None:
        cdef:
            interned_string_handle nhandle = self._name._ish
            namespace_handle h = self._namespace._handle

        h.bind_byte(nhandle, <int8_t> val)

    def check(self):
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mbyte_t thandle = self._type
            namespace_handle h = self._namespace._handle

        try:
            h.lookup_byte(nhandle, thandle)
            return True
        except:
            return False

cdef class UByteNameBinding(TypedNameBinding):
    cdef:
        h_mubyte_t _type

    def get(self) -> Optional[object]:
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mubyte_t thandle = self._type
            namespace_handle h = self._namespace._handle
        try:
            return <uint8_t> h.lookup_ubyte(nhandle, thandle) # this was from_core
        except:  # unbound_name_ex
            return None

    def bind(self, uint8_t val) -> None:
        cdef:
            interned_string_handle nhandle = self._name._ish
            namespace_handle h = self._namespace._handle

        h.bind_ubyte(nhandle, <uint8_t> val)

    def check(self):
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mubyte_t thandle = self._type
            namespace_handle h = self._namespace._handle

        try:
            h.lookup_ubyte(nhandle, thandle)
            return True
        except:
            return False

cdef class ShortNameBinding(TypedNameBinding):
    cdef:
        h_mshort_t _type

    def get(self) -> Optional[object]:
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mshort_t thandle = self._type
            namespace_handle h = self._namespace._handle
        try:
            return <int16_t> h.lookup_short(nhandle, thandle) # this was from_core
        except:  # unbound_name_ex
            return None

    def bind(self, int16_t val) -> None:
        cdef:
            interned_string_handle nhandle = self._name._ish
            namespace_handle h = self._namespace._handle

        h.bind_short(nhandle, <int16_t> val)

    def check(self):
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mshort_t thandle = self._type
            namespace_handle h = self._namespace._handle

        try:
            h.lookup_short(nhandle, thandle)
            return True
        except:
            return False

cdef class UShortNameBinding(TypedNameBinding):
    cdef:
        h_mushort_t _type

    def get(self) -> Optional[object]:
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mushort_t thandle = self._type
            namespace_handle h = self._namespace._handle
        try:
            return <uint16_t> h.lookup_ushort(nhandle, thandle) # this was from_core
        except:  # unbound_name_ex
            return None

    def bind(self, uint16_t val) -> None:
        cdef:
            interned_string_handle nhandle = self._name._ish
            namespace_handle h = self._namespace._handle

        h.bind_ushort(nhandle, <uint16_t> val)

    def check(self):
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mushort_t thandle = self._type
            namespace_handle h = self._namespace._handle

        try:
            h.lookup_ushort(nhandle, thandle)
            return True
        except:
            return False

cdef class IntNameBinding(TypedNameBinding):
    cdef:
        h_mint_t _type

    def get(self) -> Optional[object]:
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mint_t thandle = self._type
            namespace_handle h = self._namespace._handle
        try:
            return <int32_t> h.lookup_int(nhandle, thandle) # this was from_core
        except:  # unbound_name_ex
            return None

    def bind(self, int32_t val) -> None:
        cdef:
            interned_string_handle nhandle = self._name._ish
            namespace_handle h = self._namespace._handle

        h.bind_int(nhandle, <int32_t> val)

    def check(self):
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mint_t thandle = self._type
            namespace_handle h = self._namespace._handle

        try:
            h.lookup_int(nhandle, thandle)
            return True
        except:
            return False

cdef class UIntNameBinding(TypedNameBinding):
    cdef:
        h_muint_t _type

    def get(self) -> Optional[object]:
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_muint_t thandle = self._type
            namespace_handle h = self._namespace._handle
        try:
            return <uint32_t> h.lookup_uint(nhandle, thandle) # this was from_core
        except:  # unbound_name_ex
            return None

    def bind(self, uint32_t val) -> None:
        cdef:
            interned_string_handle nhandle = self._name._ish
            namespace_handle h = self._namespace._handle

        h.bind_uint(nhandle, <uint32_t> val)

    def check(self):
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_muint_t thandle = self._type
            namespace_handle h = self._namespace._handle

        try:
            h.lookup_uint(nhandle, thandle)
            return True
        except:
            return False

cdef class LongNameBinding(TypedNameBinding):
    cdef:
        h_mlong_t _type

    def get(self) -> Optional[object]:
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mlong_t thandle = self._type
            namespace_handle h = self._namespace._handle
        try:
            return <int64_t> h.lookup_long(nhandle, thandle) # this was from_core
        except:  # unbound_name_ex
            return None

    def bind(self, int64_t val) -> None:
        cdef:
            interned_string_handle nhandle = self._name._ish
            namespace_handle h = self._namespace._handle

        h.bind_long(nhandle, <int64_t> val)

    def check(self):
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mlong_t thandle = self._type
            namespace_handle h = self._namespace._handle

        try:
            h.lookup_long(nhandle, thandle)
            return True
        except:
            return False

cdef class ULongNameBinding(TypedNameBinding):
    cdef:
        h_mulong_t _type

    def get(self) -> Optional[object]:
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mulong_t thandle = self._type
            namespace_handle h = self._namespace._handle
        try:
            return <uint64_t> h.lookup_ulong(nhandle, thandle) # this was from_core
        except:  # unbound_name_ex
            return None

    def bind(self, uint64_t val) -> None:
        cdef:
            interned_string_handle nhandle = self._name._ish
            namespace_handle h = self._namespace._handle

        h.bind_ulong(nhandle, <uint64_t> val)

    def check(self):
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mulong_t thandle = self._type
            namespace_handle h = self._namespace._handle

        try:
            h.lookup_ulong(nhandle, thandle)
            return True
        except:
            return False

cdef class FloatNameBinding(TypedNameBinding):
    cdef:
        h_mfloat_t _type

    def get(self) -> Optional[object]:
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mfloat_t thandle = self._type
            namespace_handle h = self._namespace._handle
        try:
            return <float> h.lookup_float(nhandle, thandle) # this was from_core
        except:  # unbound_name_ex
            return None

    def bind(self, float val) -> None:
        cdef:
            interned_string_handle nhandle = self._name._ish
            namespace_handle h = self._namespace._handle

        h.bind_float(nhandle, <float> val)

    def check(self):
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mfloat_t thandle = self._type
            namespace_handle h = self._namespace._handle

        try:
            h.lookup_float(nhandle, thandle)
            return True
        except:
            return False

cdef class DoubleNameBinding(TypedNameBinding):
    cdef:
        h_mdouble_t _type

    def get(self) -> Optional[object]:
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mdouble_t thandle = self._type
            namespace_handle h = self._namespace._handle
        try:
            return <double> h.lookup_double(nhandle, thandle) # this was from_core
        except:  # unbound_name_ex
            return None

    def bind(self, double val) -> None:
        cdef:
            interned_string_handle nhandle = self._name._ish
            namespace_handle h = self._namespace._handle

        h.bind_double(nhandle, <double> val)

    def check(self):
        cdef:
            interned_string_handle nhandle = self._name._ish
            h_mdouble_t thandle = self._type
            namespace_handle h = self._namespace._handle

        try:
            h.lookup_double(nhandle, thandle)
            return True
        except:
            return False

# END INJECTION

# =========================================================================
#  Helpers
# =========================================================================

cpdef inline is_record_type(obj):
    return issubclass(obj, Record)

# =========================================================================
#  Primitives
# =========================================================================

# START INJECTION | tmpl_primitives

cdef class Bool(MDSPrimitiveBase):

    cdef:
        mv_bool _type
        bool _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        self._value = self._sanitize(value, self._value)
        self._type = mv_bool(self._value)

    def _to_python(self):
        return bool_to_core_val(self._type)

    def update_value(self, value) -> None:
        self._value = self._sanitize(value, self._value)
        self._type = mv_bool(self._value)

    def bind_to_namespace(self, Namespace namespace, String name) -> None:
        cdef:
            interned_string_handle nhandle = name._ish
            namespace_handle h = namespace._handle

        h.bind_bool(nhandle, <bool> self._value)
    
cdef class Byte(MDSIntPrimitiveBase):

    cdef:
        mv_byte _type
        int _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        self._value = self._sanitize(value, self._value)
        self._type = mv_byte(self._value)

    def _to_python(self):
        return byte_to_core_val(self._type)

    def update_value(self, value) -> None:
        self._value = self._sanitize(value, self._value)
        self._type = mv_byte(self._value)

    def bind_to_namespace(self, Namespace namespace, String name) -> None:
        cdef:
            interned_string_handle nhandle = name._ish
            namespace_handle h = namespace._handle

        h.bind_byte(nhandle, <int8_t> self._value)
    
    def __int__(self):
        return self._value

    # TODO: Arithmetic ops

    property MIN:
        def __get__(self):
            return -128

    property MAX:
        def __get__(self):
            return 127 

cdef class UByte(MDSIntPrimitiveBase):

    cdef:
        mv_ubyte _type
        int _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        self._value = self._sanitize(value, self._value)
        self._type = mv_ubyte(self._value)

    def _to_python(self):
        return ubyte_to_core_val(self._type)

    def update_value(self, value) -> None:
        self._value = self._sanitize(value, self._value)
        self._type = mv_ubyte(self._value)

    def bind_to_namespace(self, Namespace namespace, String name) -> None:
        cdef:
            interned_string_handle nhandle = name._ish
            namespace_handle h = namespace._handle

        h.bind_ubyte(nhandle, <uint8_t> self._value)
    
    def __int__(self):
        return self._value

    # TODO: Arithmetic ops

    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 255 

cdef class Short(MDSIntPrimitiveBase):

    cdef:
        mv_short _type
        int _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        self._value = self._sanitize(value, self._value)
        self._type = mv_short(self._value)

    def _to_python(self):
        return short_to_core_val(self._type)

    def update_value(self, value) -> None:
        self._value = self._sanitize(value, self._value)
        self._type = mv_short(self._value)

    def bind_to_namespace(self, Namespace namespace, String name) -> None:
        cdef:
            interned_string_handle nhandle = name._ish
            namespace_handle h = namespace._handle

        h.bind_short(nhandle, <int16_t> self._value)
    
    def __int__(self):
        return self._value

    # TODO: Arithmetic ops

    property MIN:
        def __get__(self):
            return -32768

    property MAX:
        def __get__(self):
            return 32767 

cdef class UShort(MDSIntPrimitiveBase):

    cdef:
        mv_ushort _type
        int _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        self._value = self._sanitize(value, self._value)
        self._type = mv_ushort(self._value)

    def _to_python(self):
        return ushort_to_core_val(self._type)

    def update_value(self, value) -> None:
        self._value = self._sanitize(value, self._value)
        self._type = mv_ushort(self._value)

    def bind_to_namespace(self, Namespace namespace, String name) -> None:
        cdef:
            interned_string_handle nhandle = name._ish
            namespace_handle h = namespace._handle

        h.bind_ushort(nhandle, <uint16_t> self._value)
    
    def __int__(self):
        return self._value

    # TODO: Arithmetic ops

    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 65535 

cdef class Int(MDSIntPrimitiveBase):

    cdef:
        mv_int _type
        int _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        self._value = self._sanitize(value, self._value)
        self._type = mv_int(self._value)

    def _to_python(self):
        return int_to_core_val(self._type)

    def update_value(self, value) -> None:
        self._value = self._sanitize(value, self._value)
        self._type = mv_int(self._value)

    def bind_to_namespace(self, Namespace namespace, String name) -> None:
        cdef:
            interned_string_handle nhandle = name._ish
            namespace_handle h = namespace._handle

        h.bind_int(nhandle, <int32_t> self._value)
    
    def __int__(self):
        return self._value

    # TODO: Arithmetic ops

    property MIN:
        def __get__(self):
            return -2147483648

    property MAX:
        def __get__(self):
            return 2147483647 

cdef class UInt(MDSIntPrimitiveBase):

    cdef:
        mv_uint _type
        int _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        self._value = self._sanitize(value, self._value)
        self._type = mv_uint(self._value)

    def _to_python(self):
        return uint_to_core_val(self._type)

    def update_value(self, value) -> None:
        self._value = self._sanitize(value, self._value)
        self._type = mv_uint(self._value)

    def bind_to_namespace(self, Namespace namespace, String name) -> None:
        cdef:
            interned_string_handle nhandle = name._ish
            namespace_handle h = namespace._handle

        h.bind_uint(nhandle, <uint32_t> self._value)
    
    def __int__(self):
        return self._value

    # TODO: Arithmetic ops

    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 4294967295 

cdef class Long(MDSIntPrimitiveBase):

    cdef:
        mv_long _type
        int _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        self._value = self._sanitize(value, self._value)
        self._type = mv_long(self._value)

    def _to_python(self):
        return long_to_core_val(self._type)

    def update_value(self, value) -> None:
        self._value = self._sanitize(value, self._value)
        self._type = mv_long(self._value)

    def bind_to_namespace(self, Namespace namespace, String name) -> None:
        cdef:
            interned_string_handle nhandle = name._ish
            namespace_handle h = namespace._handle

        h.bind_long(nhandle, <int64_t> self._value)
    
    def __int__(self):
        return self._value

    # TODO: Arithmetic ops

    property MIN:
        def __get__(self):
            return -9223372036854775808

    property MAX:
        def __get__(self):
            return 9223372036854775807 

cdef class ULong(MDSIntPrimitiveBase):

    cdef:
        mv_ulong _type
        int _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        self._value = self._sanitize(value, self._value)
        self._type = mv_ulong(self._value)

    def _to_python(self):
        return ulong_to_core_val(self._type)

    def update_value(self, value) -> None:
        self._value = self._sanitize(value, self._value)
        self._type = mv_ulong(self._value)

    def bind_to_namespace(self, Namespace namespace, String name) -> None:
        cdef:
            interned_string_handle nhandle = name._ish
            namespace_handle h = namespace._handle

        h.bind_ulong(nhandle, <uint64_t> self._value)
    
    def __int__(self):
        return self._value

    # TODO: Arithmetic ops

    property MIN:
        def __get__(self):
            return 0

    property MAX:
        def __get__(self):
            return 18446744073709551615 

cdef class Float(MDSFloatPrimitiveBase):

    cdef:
        mv_float _type
        float _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        self._value = self._sanitize(value, self._value)
        self._type = mv_float(self._value)

    def _to_python(self):
        return float_to_core_val(self._type)

    def update_value(self, value) -> None:
        self._value = self._sanitize(value, self._value)
        self._type = mv_float(self._value)

    def bind_to_namespace(self, Namespace namespace, String name) -> None:
        cdef:
            interned_string_handle nhandle = name._ish
            namespace_handle h = namespace._handle

        h.bind_float(nhandle, <float> self._value)
    
cdef class Double(MDSFloatPrimitiveBase):

    cdef:
        mv_double _type
        float _value

    def __cinit__(self, value):  # TODO: Set the value in _value
        self._value = self._sanitize(value, self._value)
        self._type = mv_double(self._value)

    def _to_python(self):
        return double_to_core_val(self._type)

    def update_value(self, value) -> None:
        self._value = self._sanitize(value, self._value)
        self._type = mv_double(self._value)

    def bind_to_namespace(self, Namespace namespace, String name) -> None:
        cdef:
            interned_string_handle nhandle = name._ish
            namespace_handle h = namespace._handle

        h.bind_double(nhandle, <double> self._value)
    
# END INJECTION
