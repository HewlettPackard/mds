# -*- coding: utf-8 -*-
"""
Managed Data Structures
Copyright Â© 2017 Hewlett Packard Enterprise Development Company LP.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

As an exception, the copyright holders of this Library grant you permission
to (i) compile an Application with the Library, and (ii) distribute the
Application containing code generated by the Library and added to the
Application during this compilation process under terms of your choice,
provided you also meet the terms and conditions of the Application license.
"""

from cpython.ref cimport PyObject

from cython.operator cimport dereference as deref
from libcpp.memory cimport unique_ptr, make_unique

from mds.core.api_tasks cimport *
from mds.core.api_isolation_contexts cimport *

from datetime import datetime, timedelta
from threading import local

# =========================================================================
#  Isolation Contexts
# =========================================================================

cdef class IsolationContext(object):
    cdef iso_context_handle _handle

    cdef inline __create_child(self, str kind, bool snapshot):
        cdef:
            iso_context_handle handle
            str k_live = "live"
            str k_read_only = "read_only"
            str k_detached = "detached"

        # Do the sanity checking here
        if self._handle.is_read_only():
            if kind == k_live:
                raise RuntimeError(
                    "Can't create a `live` child from `read_only` parent."
                )

        if snapshot:
            if kind == k_read_only:
                handle = self._handle.new_read_only_snapshot_child()
            elif kind == k_detached:
                handle = self._handle.new_detached_snapshot_child()
            else:
                handle = self._handle.new_snapshot_child()
        else:
            if kind == k_read_only:
                handle = self._handle.new_read_only_nonsnapshot_child()
            elif kind == k_detached:
                handle = self._handle.new_detached_nonsnapshot_child()
            else:
                handle = self._handle.new_nonsnapshot_child()

        return IsolationContext_Init(handle=handle)


cdef inline IsolationContext_Init(iso_context_handle handle):
    initialize_base_task()
    result = IsolationContext()
    result._handle = handle
    return result

cdef inline object _isoctxt_execution_wrapper(_py_callable_wrapper wrapped):
    cdef:
        object fn = <object> wrapped.fn
        object args = <object> wrapped.args
   
    return fn(*args)

cdef inline object in_isoctxt(iso_context_handle ich, object fn, object args):
    return run_in_iso_ctxt(ich, &_isoctxt_execution_wrapper, _wrap(fn, args))

# =========================================================================
#  Tasks
# =========================================================================

cdef class Task(object):
    cdef:
        tuple __args
        object __target
        bint __expired
        task_handle _handle
        iso_context_handle _ctxt


cdef inline Task_Init(task_handle handle):
    # TODO Remove me, DEBUG
    print("Initializing task with hash {}".format(hash_task(handle)))
    result = Task()
    add_task_handle(result, handle)
    return result

cdef inline add_task_handle(Task task, task_handle handle):
    task._handle = handle

cdef inline update_context_handle_in_task(Task task, IsolationContext ctxt):
    task._ctxt = ctxt._handle

cdef inline void _task_execution_wrapper(_py_callable_wrapper wrapped):
    """
    This is the wrapper function that Cython uses to generate the appropriate
    C++ that uses the Py*{Eval,CallObject}(py_callable, py_tuple) boilerplate.
    """
    cdef:
        object fn = <object> wrapped.fn
        object args = <object> wrapped.args
   
    fn(*args)

cdef inline void in_task(task_handle th, object fn, object args):
    """
    Delegate the running of this tasklet through to the compiled library, need
    to wrap things up nicely for Cython to generate the appropriate code.
    """
    cdef TaskWrapper task_wrap = TaskWrapper(th)
    task_wrap.run(&_task_execution_wrapper, _wrap(fn, args))

cdef inline _task_add_dependent(Task first, Task second):
    first._handle.add_dependent(second._handle)
    return first

# =========================================================================
#  Publication Reports & Options
# =========================================================================

cdef class PublicationResult(object):
    cdef publication_attempt_handle _handle


cdef inline PublicationResult_Init(publication_attempt_handle handle):
    initialize_base_task()
    result = PublicationResult()
    result._handle = handle
    return result

# =========================================================================
#  Misc.
# =========================================================================

cdef class Use(object):
    cdef:
        unique_ptr[Establish] _establish
        task_handle _handle

cdef inline _py_callable_wrapper _wrap(object fn, object args):
    cdef _py_callable_wrapper py_wrap
    py_wrap.fn = <PyObject *> fn
    py_wrap.args = <PyObject *> args
    return py_wrap
