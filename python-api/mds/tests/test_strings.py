# -*- coding: utf-8 -*-
"""
Managed Data Structures
Copyright Â© 2017 Hewlett Packard Enterprise Development Company LP.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

As an exception, the copyright holders of this Library grant you permission
to (i) compile an Application with the Library, and (ii) distribute the 
Application containing code generated by the Library and added to the 
Application during this compilation process under terms of your choice, 
provided you also meet the terms and conditions of the Application license.
"""

import sys
import unittest

from functools import reduce
from random import shuffle

from mds.managed import *

class TestString(unittest.TestCase):

    def setUp(self):
        self.unicode = "This is a test string"
        self.bytes = b"This is a test string"
        self.mdsstring = String(self.unicode)

    def test_create_from_bytes(self):
        s = String(self.bytes)

        self.assertEqual(str(s).encode("utf-8"), self.bytes)

    def test_create_from_unicode(self):
        self.assertEqual(str(self.mdsstring), self.unicode)

    def test_len(self):
        self.assertEqual(len(self.mdsstring), len(self.unicode))

    def test_iter(self):
        iter_uni = iter(self.unicode)
        iter_mds = iter(self.mdsstring)

        for c in iter_uni:
            m = next(iter_mds)
            self.assertEqual(c, m)

        # Make sure it's symmetric, nothing hanging off the end of String
        iter_uni = iter(self.unicode)
        iter_mds = iter(self.mdsstring)

        for c in iter_mds:
            m = next(iter_uni)
            self.assertEqual(c, m)

    def test_random_access(self):
        indexes = [x for x in range(len(self.unicode))]
        shuffle(indexes)

        for i in indexes:
            self.assertEqual(self.unicode[i], self.mdsstring[i])

    def test_consistent_hashes(self):
        S = [String(self.unicode) for x in range(50)]
        H = [hash(s) for s in S]

        self.assertEqual(H.count(H[0]), len(H))

    def test_add(self):
        parts = self.unicode.split()
        mdsparts = [String(s) for s in parts]

        recon_uni = reduce(lambda x, y: x + y, parts)
        recon_mds = reduce(lambda x, y: x + y, mdsparts)

        self.assertEqual(recon_uni, str(recon_mds))

        with self.assertRaises(TypeError):
            recon_mds + 1

    def test_mul(self):
        for mul in range(50):
            base = self.unicode * mul
            candidate = self.mdsstring * mul

            self.assertEqual(base, str(candidate))

        with self.assertRaises(TypeError):
            self.mdsstring * 5.7

    def test_subtract(self):
        with self.assertRaises(TypeError):
            self.mdsstring - "test"

        with self.assertRaises(TypeError):
            self.mdsstring - 240

    @unittest.skip("Not Implemented")
    def test_rmul(self):
        pass

    @unittest.skip("Not Implemented")
    def test_mod(self):
        pass

    @unittest.skip("Not Implemented")
    def test_richcmp(self):
        pass

    @unittest.skip("Not Implemented")
    def test_sizeof(self):
        pass

    @unittest.skip("Not Implemented")
    def test_capitalize(self):
        pass

    @unittest.skip("Not Implemented")
    def test_casefold(self):
        pass

    @unittest.skip("Not Implemented")
    def test_center(self):
        pass

    def test_endswith(self):
        self.assertTrue(self.mdsstring.endswith("ing"))
        self.assertFalse(self.mdsstring.endswith("ong"))

    @unittest.skip("Not Implemented")
    def test_expandtabs(self):
        self.assertEqual(self.unicode.expandtabs(), self.mdsstring.expandtabs())

    @unittest.skip("Not Implemented")
    def test_find(self):
        self.assertEqual(self.unicode.find(), self.mdsstring.find())

    @unittest.skip("Not Implemented")
    def test_format(self):
        self.assertEqual(self.unicode.format(), self.mdsstring.format())

    @unittest.skip("Not Implemented")
    def test_format_map(self):
        self.assertEqual(self.unicode.format_map(), self.mdsstring.format_map())

    def test_index(self):
        for i, c in enumerate(self.unicode):
            self.assertEqual(
                self.unicode.index(c, i),
                self.mdsstring.index(c, i)
            )

    def test_isalnum(self):
        self.assertEqual(self.unicode.isalnum(), self.mdsstring.isalnum())

        s2 = "jd28&&^*#@!&^#@"
        mds2 = String(s2)

        self.assertFalse(mds2.isalnum())

    @unittest.skip("Not Implemented")
    def test_isalpha(self):
        self.assertEqual(self.unicode.isalpha(), self.mdsstring.isalpha())

    @unittest.skip("Not Implemented")
    def test_isdecimal(self):
        self.assertEqual(self.unicode.isdecimal(), self.mdsstring.isdecimal())

    @unittest.skip("Not Implemented")
    def test_isdigit(self):
        self.assertEqual(self.unicode.isdigit(), self.mdsstring.isdigit())

    @unittest.skip("Not Implemented")
    def test_isidentifier(self):
        self.assertEqual(self.unicode.isidentifier(), self.mdsstring.isidentifier())

    @unittest.skip("Not Implemented")
    def test_islower(self):
        self.assertEqual(self.unicode.islower(), self.mdsstring.islower())

    @unittest.skip("Not Implemented")
    def test_isnumeric(self):
        self.assertEqual(self.unicode.isnumeric(), self.mdsstring.isnumeric())

    @unittest.skip("Not Implemented")
    def test_isprintable(self):
        self.assertEqual(self.unicode.isprintable(), self.mdsstring.isprintable())

    @unittest.skip("Not Implemented")
    def test_isspace(self):
        self.assertEqual(self.unicode.isspace(), self.mdsstring.isspace())

    @unittest.skip("Not Implemented")
    def test_istitle(self):
        self.assertEqual(self.unicode.istitle(), self.mdsstring.istitle())

    @unittest.skip("Not Implemented")
    def test_isupper(self):
        self.assertEqual(self.unicode.isupper(), self.mdsstring.isupper())

    @unittest.skip("Not Implemented")
    def test_join(self):
        self.assertEqual(self.unicode.join(), self.mdsstring.join())

    @unittest.skip("Not Implemented")
    def test_ljust(self):
        self.assertEqual(self.unicode.ljust(), self.mdsstring.ljust())

    @unittest.skip("Not Implemented")
    def test_lower(self):
        self.assertEqual(self.unicode.lower(), self.mdsstring.lower())

    @unittest.skip("Not Implemented")
    def test_lstrip(self):
        self.assertEqual(self.unicode.lstrip(), self.mdsstring.lstrip())

    @unittest.skip("Not Implemented")
    def test_partition(self):
        self.assertEqual(self.unicode.partition(), self.mdsstring.partition())

    @unittest.skip("Not Implemented")
    def test_replace(self):
        self.assertEqual(self.unicode.replace(), self.mdsstring.replace())

    @unittest.skip("Not Implemented")
    def test_rfind(self):
        self.assertEqual(self.unicode.rfind(), self.mdsstring.rfind())

    @unittest.skip("Not Implemented")
    def test_rindex(self):
        self.assertEqual(self.unicode.rindex(), self.mdsstring.rindex())

    @unittest.skip("Not Implemented")
    def test_rjust(self):
        self.assertEqual(self.unicode.rjust(), self.mdsstring.rjust())

    @unittest.skip("Not Implemented")
    def test_rpartition(self):
        self.assertEqual(self.unicode.rpartition(), self.mdsstring.rpartition())

    @unittest.skip("Not Implemented")
    def test_rsplit(self):
        self.assertEqual(self.unicode.rsplit(), self.mdsstring.rsplit())

    @unittest.skip("Not Implemented")
    def test_rstrip(self):
        self.assertEqual(self.unicode.rstrip(), self.mdsstring.rstrip())

    @unittest.skip("Not Implemented")
    def test_split(self):
        self.assertEqual(self.unicode.split(), self.mdsstring.split())

    @unittest.skip("Not Implemented")
    def test_splitlines(self):
        self.assertEqual(self.unicode.splitlines(), self.mdsstring.splitlines())

    @unittest.skip("Not Implemented")
    def test_startswith(self):
        self.assertEqual(self.unicode.startswith(), self.mdsstring.startswith())

    @unittest.skip("Not Implemented")
    def test_strip(self):
        self.assertEqual(self.unicode.strip(), self.mdsstring.strip())

    @unittest.skip("Not Implemented")
    def test_swapcase(self):
        self.assertEqual(self.unicode.swapcase(), self.mdsstring.swapcase())

    @unittest.skip("Not Implemented")
    def test_title(self):
        self.assertEqual(self.unicode.title(), self.mdsstring.title())

    @unittest.skip("Not Implemented")
    def test_upper(self):
        self.assertEqual(self.unicode.upper(), self.mdsstring.upper())

    @unittest.skip("Not Implemented")
    def test_zfill(self):
        self.assertEqual(self.unicode.zfill(), self.mdsstring.zfill())

    def test_can_subclass(self):
        class MyString(String):

            @property
            def foo(self):
                return str(self) + "foo"

        s = MyString(self.unicode)

        self.assertIsInstance(s, MyString)
        self.assertIsInstance(s, String)
        self.assertEqual(self.unicode + "foo", s.foo)

if __name__ == '__main__':
    unittest.main()
