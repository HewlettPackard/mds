/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.impl;

import com.hpl.mds.*;




public class RecordArrayTypeProxy<R extends ManagedRecord> extends Proxy implements ManagedTypeImpl<ManagedArray<R>>, ManagedArray.Type<R>
{
  private static final NativeLibraryLoader NATIVE_LIB_LOADER = NativeLibraryLoader.getInstance();
  /**
   * @throws UnboundNameException when the name is not bound to anything in this context
   * @throws IncompatibleTypeException when the name is bound to something other than this type
   */
  private static native long lookupHandle(long h, long namespaceHandle, long nameHandle);
  /**
   * @returns false if the name is bound to a sub-namespace in the current context.
   */
  private static native boolean bindHandle(long namespaceHandle, long nameHandle, long valHandle);
  private static native boolean isSameAs(long aHandle, long bHandle);
  private static native long createArray(long h, long size);
  private static native void release(long index);
  private static native long forRecordType(long recHandle);
  private static native long elementTypeHandle(long handle);
  
  private static final Proxy.Table<RecordArrayTypeProxy<?>> 
  proxyTable = new Proxy.Table<>(RecordArrayTypeProxy::release);
  
  private final RecordTypeProxy<R> eltType;
  
  
  public enum FromHandle { FROM_HANDLE};
    
  private RecordArrayTypeProxy(FromHandle fh, long handle, RecordTypeProxy<R> eltType) {
    super(handle, proxyTable);
    this.eltType = eltType;
  }
  
  @Override
  void releaseHandleIndex(long index) {
    proxyTable.release(index);
  }


  @Override
  public RecordTypeProxy<R> eltType() {
    return eltType;
  }

  @Override
  public <RT extends ManagedRecord>
    RecordArrayFieldProxy<RT,R> fieldIn(RecordType<RT> recType, CharSequence name) {
    //    	System.out.println("StringArrayType: fieldIn recType: " + name);
    return RecordArrayFieldProxy.in(recType, name, this);
  }

  @Override
  public <RT extends ManagedRecord>
    RecordArrayFieldProxy<RT,R> findFieldIn(RecordType<RT> recType, CharSequence name) {
    // TODO Auto-generated method stub
    return null;
  }

  @Override
  public ManagedArray<R> construct(Object... ctorParams) {
    return Stub.notImplemented();
  }

  @Override
  public ManagedArray<R> create() {
    return Stub.notImplemented();
  }

  @Override
  public ManagedArray<R> create(long size) {
    long aHndl = createArray(handleIndex_, size);
    return RecordArrayProxy.fromHandle(aHndl, size, this);
  }


  @Override
  public ManagedArray<R> create(R[] arr) {
    ManagedArray<R> a = create(arr.length);
    for (int i=0; i<arr.length; i++) {
      a.set(i, arr[i]);
    }
    return a;
  }

  @Override
  public RecordArrayProxy<R> create(ManagedArray.Usage hints) {
    return Stub.notImplemented();
  }
  @Override
  public RecordArrayProxy<R> create(ManagedOrdered.Usage hints) {
    return Stub.notImplemented();
  }


  @Override
  public ManagedArray.Type<ManagedArray<R>> inArray() {
    return Stub.notImplemented(); 
  }

  @Override
  public ManagedList.Type<ManagedArray<R>> inList() {
    return Stub.notImplemented(); 
  }

  @Override
  public ManagedSet.Type<ManagedArray<R>> inSet() {
    return Stub.notImplemented(); 
  }

  @Override
  public <K extends ManagedObject> ManagedMap.Type<K, ManagedArray<R>> inMapFrom(ManagedType<K> keyType) {
    return Stub.notImplemented(); 
  }

  @Override
  public ManagedMapFromString.Type<ManagedArray<R>> inMapFromString() {
    return inMapFrom(ManagedString.TYPE);
  }

  /**
   * @return null if the name is unbound in this context
   * @throws IncompatibleTypeException when the name is bound to something other than this type
   */
  @Override
  public ManagedArray<R> lookupName(Namespace ns, CharSequence name) {
    NamespaceProxy nsp = (NamespaceProxy)ns;
    ManagedStringProxy msp = ManagedStringProxy.valueOf(name);

    long ah = lookupHandle(handleIndex_, nsp.handleIndex(), msp.handleIndex());
    return RecordArrayProxy.fromHandle(ah, this);
  }

  @Override
  public ManagedArray<R> bindIn(Namespace ns, CharSequence name, ManagedArray<R> val, Prior prior) {
    /*
     * TODO: Prior is unused
     */
    NamespaceProxy nsp = (NamespaceProxy)ns;
    ManagedStringProxy msp = ManagedStringProxy.valueOf(name);
    RecordArrayProxy<R> ap = (RecordArrayProxy<R>)val;

    boolean worked = bindHandle(nsp.handleIndex(), msp.handleIndex(), ap.handleIndex());
    if (!worked) {
      throw new BoundToNamespaceException(ns, name);
    }
    return val;
  }
  
  static <R extends ManagedRecord>
  RecordArrayTypeProxy<R> forType(RecordTypeProxy<R> et) {
    long rth = et.handleIndex();
    long ath = forRecordType(rth);
    return fromHandle(ath, et);
  }
  
  static <R extends ManagedRecord> 
  RecordArrayTypeProxy<R> fromHandle(long handle, RecordTypeProxy<R> eltType) {
    RecordArrayTypeProxy<?> ratp = proxyTable.fromIndex(handle, (i) -> {
      RecordTypeProxy<R> et = eltType;
      if (et == null) {
        et = RecordTypeProxy.fromHandle(elementTypeHandle(handle));
      }
      RecordArrayTypeProxy<R> at = new RecordArrayTypeProxy<>(FromHandle.FROM_HANDLE, i, et);
      if (eltType == null) {
        et.cacheArrayType(at);
      }
      return at;
    });
    @SuppressWarnings("unchecked")
    RecordArrayTypeProxy<R> downcast = (RecordArrayTypeProxy<R>)ratp;
    return downcast;
  }

  static <R extends ManagedRecord>
  RecordArrayTypeProxy<R> fromHandle(long handle) {
    return fromHandle(handle, null);
  }


}
