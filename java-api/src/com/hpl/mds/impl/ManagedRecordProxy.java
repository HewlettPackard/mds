/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.impl;

import com.hpl.mds.*;
import java.lang.ref.WeakReference;
import java.util.function.Consumer;

public abstract class ManagedRecordProxy extends Proxy implements ManagedRecord {
	
  private static final NativeLibraryLoader NATIVE_LIB_LOADER = NativeLibraryLoader.getInstance();
  
  protected final RecordTypeProxy<? extends ManagedRecord> type;
  private ManagedRecordProxy forward_;
  private boolean behavedWhileTypeInferred = false;
  
  private static final Proxy.Table<ManagedRecordProxy> 
  proxyTable = new Proxy.Table.WithLargeCache<>(ManagedRecordProxy::release);
  
  @Override
  protected Object domain() {
    return ManagedRecordProxy.class;
  }

  private static native void release(long index);
  private static native long createRecord(long recTypeHandle);
  private static native boolean isIdentical(long aHandle, long bHandle);
  private static native boolean isSameObject(long aHandle, long bHandle);
  private static native boolean isSameViewOfSameObject(long aHandle, long bHandle);
  private static native long recordTypeIndex(long handle);
  static native long getUUID(long recHandle);
  
  @Override
  void releaseHandleIndex(long index) {
    /*
     * If we have a forward, it's the forward that does the release. 
     * Since we hold a reference to it, it will necessarily outlive 
     * us.
     */
    if (forward_ == null || forward_ == this) {
      //      System.out.format("Releasing record %s%n", this);
      proxyTable.release(index);
    }
  }
  
  public enum FromHandle { FROM_HANDLE};
  public enum Secondary { SECONDARY };

  protected ManagedRecordProxy(FromHandle keyword, long handle, RecordType<? extends ManagedRecord> type) {
    super(handle, proxyTable);
    //    System.out.format("Created a %s with handle %,d%n", type, handle);
    //    Thread.dumpStack();
    RecordTypeProxy<? extends ManagedRecord> rtp = RecordTypeProxy.downcast(type);
    RecordTypeProxy<? extends ManagedRecord> rtpf = rtp.forward();
    if (rtpf == null) {
      forward_ = null;
      this.type = rtp;
    } else {
      forward_ = this;
      this.type = rtpf;
    }
  }
  
  protected ManagedRecordProxy(Secondary keyword, ManagedRecordProxy mrp) {
    super(mrp.handleIndex_, null);
    forward_ = mrp;
    type = mrp.type;
  }

  public ManagedRecordProxy(RecordType<? extends ManagedRecord> type)
  {
    this(FromHandle.FROM_HANDLE, createRecord(type), type);
  }

  private static long createRecord(RecordType<? extends ManagedRecord> type) {
    // System.out.format("Creating a %s%n", type);
    return createRecord(RecordTypeProxy.downcast(type).handleIndex());
  }

  

//  public ManagedRecordProxy(RecordType<? extends ManagedRecord> type) 
//  {
//    this(FromHandle.FROM_HANDLE, 
//         createRecord(RecordTypeProxy.downcast(type).handleIndex(), IsoContextProxy.current().handleIndex()),
//         type);
//  }
  
  protected <R extends ManagedRecord> R forwardsTo() {
    ManagedRecordProxy mrp = forward_;
    if (forward_ == null) {
      synchronized (this) {
        /*
         * It's possible that somebody else might've done it
         * while we were waiting.
         */
        if (forward_ == null) {
          RecordTypeProxy<? extends ManagedRecord> f = type.forward();
          if (f != null) {
            mrp = forward_ = (ManagedRecordProxy) f.createFromRecordHandle(handleIndex_);
            /*
             * Now we need to make sure that it's the one in the table.  fromHandle() checks
             * the forward, but if the original gets collected, we won't be able to find
             * the new one.
             */
            proxyTable.replace(handleIndex_, mrp);
          } else {
            mrp = this;
          }
        } else {
          mrp = forward_;
        }
      }
    }
    @SuppressWarnings("unchecked")
    R mr = (R) mrp;
    return mr;
  }
  
  static <RT extends ManagedRecord> 
  RT fromHandle(long handle, RecordTypeProxy<RT> typeBound) {
    ManagedRecordProxy mrp = proxyTable.fromIndex(handle, (i) -> {
      /*
       * We only get here if the handle wasn't in the table.  Calling
       * RTP.fromHandle will create the type proxy if it doesn't exist
       */
      long rti = recordTypeIndex(handle);
      RecordTypeProxy<? extends ManagedRecord> rt = RecordTypeProxy.fromHandle(rti);
      ManagedRecord mr =  rt.createFromRecordHandle(handle);
      return (ManagedRecordProxy)mr;
    });
    if (mrp == null) {
    	return null;
    }
    /*
     * It's possible it was forwarded.
     */
    if (mrp.forward_ != null) {
      mrp = mrp.forward_;
    }
    /*
     * TODO: Make sure it's compatible with typeBound.  (Maybe 
     * just on creation)
     */
    @SuppressWarnings("unchecked")
    RT downcast = (RT)mrp;
    return downcast;
  }
  

  protected <R extends ManagedRecord> RecordTypeProxy<R> narrowedType(Class<R> clss, R self) {
    /*
     * The notion is that this will only be called as narrowedType(R.class, this), so R is
     * necessarily in the hierarchy. and so the object must have been constructed with a type
     * parameter of RecordTypeProxy<? extends R>.  We're fudging a bit, but it looks as
     * though it should be legal.
     */
    @SuppressWarnings("unchecked")
    RecordTypeProxy<R> t = (RecordTypeProxy<R>)type;
    return t;
  }

  public static <T extends ManagedRecord> RecordType<? extends T> typeOf(T rec) {
	  // By construction, this has to work, since the constructors are required to narrow at each level, so T's constructor
	  // would require a RecordType<? extends T>
	  ManagedRecordProxy mrb = (ManagedRecordProxy)rec;
	  @SuppressWarnings("unchecked")
	  RecordType<? extends T> type = (RecordType<? extends T>)mrb.type;
	  return type;
	}
  
  public static <T extends ManagedRecord> long handleOf(T rec) {
    ManagedRecordProxy mrb = (ManagedRecordProxy)rec;
    return mrb == null ? 0 : mrb.handleIndex();
  }


  @Override
  public boolean isIdentical(ManagedComposite other) {
    if (this == other) { 
      return true; 
    } else if (other == null) { 
      return false; 
    } else if (!(other instanceof ManagedRecordProxy)) { 
      return false; 
    }
    return isIdentical(handleIndex_, ((ManagedRecordProxy)other).handleIndex());
  }
  
  @Override
  public boolean isSameObject(ManagedComposite other) {
    if (this == other) { 
      return true; 
    } else if (other == null) { 
      return false; 
    } else if (!(other instanceof ManagedRecordProxy)) { 
      return false; 
    }
    return isSameObject(handleIndex_, ((ManagedRecordProxy)other).handleIndex());
  }

  @Override
  public boolean isSameViewOfSameObject(ManagedComposite other) {
    if (this == other) { 
      return true; 
    } else if (other == null) { 
      return false; 
    } else if (!(other instanceof ManagedRecordProxy)) { 
      return false; 
    }
    return isSameViewOfSameObject(handleIndex_, ((ManagedRecordProxy)other).handleIndex());
  }
  
  public long getUUID() {
    return getUUID(handleIndex_);
  }

  @Override
  public RecordType<? extends ManagedRecord> type() {
    return type;
  }

  @Override
  public ManagedRecord bindName(Prior prior, Namespace ns, CharSequence name) {
    return narrowedType(ManagedRecord.class, this).bindIn(ns, name, this, prior);
  }

  @Override
  public String toString() {
    return __OBJECT_METHOD_toString();
  }

  final public String defaultToString() {
    return String.format("Record[%,d (%x) %s]",
			 handleIndex_,
			 System.identityHashCode(this),
			 getClass().getCanonicalName());
  }

  @Override
  public int hashCode() {
    return __OBJECT_METHOD_hashCode();
  }

  final public int defaultHashCode() {
    return super.hashCode();
  }

  final public boolean defaultEquals(Object o) {
    if (o == this) {
      return true;
    } else if (o == null) {
      return false;
    } else if (!(o instanceof ManagedComposite)) {
      return false;
    }
    return isSameViewOfSameObject((ManagedComposite)o);
  }

  protected static class __FinalFieldControl {
    final TaskProxy creationTask = TaskProxy.current();
    TaskProxy[] initTasks;
    int nSubtasks = 0;

    public __FinalFieldControl(int nFinalFields) {
      initTasks = new TaskProxy[nFinalFields];
    }

    public 
    <R extends ManagedRecordProxy>
      void afterConstructor(R obj, Consumer<? super R> fn)
    {
      if (nSubtasks == 0) {
        fn.accept(obj);
      } else {
        final WeakReference<R> wr = new WeakReference<>(obj);
        creationTask.getContext().afterSuccessfulPublish(()->{
            R rec = wr.get();
            if (rec != null) {
              fn.accept(rec);
            }
          });
      }
    }

    public void handleGet(int index) {
      TaskProxy initTask = initTasks[index];
      if (initTask != null) {
        TaskProxy currentTask = TaskProxy.current();
        /*
         * If we're reading in the same task that wrote it, we don't
         * have to worry..
         */
        if (currentTask != initTask) {
          currentTask.dependsOn(initTask);
          if (currentTask == creationTask) {
            /*
             * If the creation task depends on the init task for this
             * field, we know we won't redo the init without redoing the
             * creation, so we don't have to worry about it from the
             * outside.
             */
            initTasks[index] = null;
            nSubtasks--;
          }
        }
      }
    }

    private <R extends ManagedRecordProxy>
      void handleRollup(int index, WeakReference<R> wr, Consumer<? super R> reset)
    {
      /*
       * The current task here is the one we were in outside
       * the block.
       */
      TaskProxy currentTask = TaskProxy.current();
      if (currentTask == creationTask) {
        /*
         * We're back to the top.  We can clear the init task.
         */
        initTasks[index] = null;
        nSubtasks--;
      } else {
        addRollupHook(index, currentTask, wr, reset);
      }
    }

    private <R extends ManagedRecordProxy>
      void addRollupHook(int index, TaskProxy currentTask,
                         WeakReference<R> wr, Consumer<? super R> reset)
    {
      /*
       * If we're in a different context, it must be a subcontext in
       * the ctor.  Because of the rules for contexts and final
       * variable initialization, we're required to be in an
       * isolated block (or equivalent), so we need to unwind on
       * publish, but we know we'll get back to the creating context
       * before the constructor ends.
       */
      IsoContextProxy creationContext = creationTask.getContext();
      IsoContextProxy currentContext = currentTask.getContext();
      if (creationContext != currentContext) {
        currentContext.afterSuccessfulPublish(()->{
            handleRollup(index, wr, reset);
          });
        currentContext.afterFailedPublish(()->{
            R rec = wr.get();
            if (rec != null) {
              initTasks[index] = null;
              nSubtasks--;
              reset.accept(rec);
            }
          });
      }
    }

    public <R extends ManagedRecordProxy>
      void handleSet(int index, R obj, Consumer<? super R> reset) {
      TaskProxy currentTask = TaskProxy.current();
      /*
       * If we're in the creation task, we don't have to worry.
       */
      if (currentTask != creationTask) {
        initTasks[index] = currentTask;
        nSubtasks++;
        WeakReference<R> wr = new WeakReference<>(obj);
        addRollupHook(index, currentTask, wr, reset);
        currentTask.onPrepareForRedo(()->{
            R rec = wr.get();
            if (rec != null) {
              initTasks[index] = null;
              nSubtasks--;
              reset.accept(rec);
            }
          });
      }
    }
  }

  protected void __finishConstruction() {}
  
  abstract protected ManagedRecordProxy __GET_IMPL();
  
  public boolean isIdentical (ManagedRecord other) {
    if (this == other) {
      return true;
    }
    if (other == null) {
      return false;
    }
    return __GET_IMPL() == ((ManagedRecordProxy)other).__GET_IMPL();
  }
    
  

}
