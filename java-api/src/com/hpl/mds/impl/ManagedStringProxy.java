/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.impl;

import com.hpl.mds.ManagedObject;
import com.hpl.mds.NativeLibraryLoader;
import com.hpl.mds.naming.Namespace;
import com.hpl.mds.naming.Prior;
import com.hpl.mds.string.ManagedString;

public class ManagedStringProxy extends Proxy implements ManagedString {
	
  private static final NativeLibraryLoader NATIVE_LIB_LOADER = NativeLibraryLoader.getInstance();
  
  private static final Proxy.Table<ManagedStringProxy> 
  proxyTable = new Proxy.Table<>(ManagedStringProxy::release);
  

  private String cachedString_ = null;
  

  private static native boolean release(long hi);
  private static native boolean sameString(long hiA, long hiB);
  private static native long intern(String s);
  private static native String toString(long hi);
  private static native int length(long hi);
  private static native char charAt(long hi, int pos);
  private static native int compareTo(long hiA, long hiB);
  


  	
  private ManagedStringProxy(long hi) {
    super(hi);
  }

  @Override
  public String boxedVal() {
    return asString();
  }
  
  @Override
  public String toString() {
    return asString();
  }
  
  @Override
  public boolean isSameAs(ManagedObject other) {
    return equals(other);
  }
  
  @Override
  public boolean equals(Object other) {
    if (other == this) { return true; }
    if (other == null) { return false; }
    if (other instanceof ManagedStringProxy) {
      return sameString(handleIndex_, ((ManagedStringProxy)other).handleIndex_);
    }
    return false;
  }

  @Override
  public int compareTo(CharSequence other) {
    if (other == this) { return 0; }
    if (other == null) { return 1; }
    return compareTo(handleIndex_, valueOf(other).handleIndex_);
  }

  @Override
  public int compareTo(ManagedString other) {
    if (other == this) { return 0; }
    if (other == null) { return 1; }
    return compareTo(handleIndex_, handleOf(other));
  }
  
  @Override
  public String asString() {
    if (cachedString_ == null) {
      cachedString_ = toString(handleIndex_);
    }
    return cachedString_;
  }
  
  public static ManagedStringProxy fromHandle(long hi) {
    return proxyTable.fromIndex(hi, ManagedStringProxy::new);
  }

  public static long handleOf(ManagedString s) {
    ManagedStringProxy msp = (ManagedStringProxy)s;
    return msp == null ? 0 : msp.handleIndex();
  }
  
  public static long handleOf(CharSequence s) {
    return handleOf(valueOf(s));
  }
  
  public static ManagedStringProxy valueOf(CharSequence val) {
    if (val == null) {
      return null;
    }
    if (val instanceof ManagedStringProxy) {
      return (ManagedStringProxy)val;
    }
    return fromHandle(intern(val.toString()));
  }
  @Override
  public ManagedStringType type() {
    return ManagedStringType.INSTANCE;
  }
  @Override
  public int length() {
    if (cachedString_ != null) {
      return cachedString_.length();
    } else {
      return length(handleIndex_);
    }
  }
  @Override
  public char charAt(int index) {
    if (cachedString_ != null) {
      return cachedString_.charAt(index);
    } else {
      return charAt(handleIndex_, index);
    }
  }
  @Override
  public CharSequence subSequence(int start, int end) {
    return asString().subSequence(start, end);
  }
  
  @Override
  public ManagedString bindName(Prior prior, Namespace ns, CharSequence name) {
    return type().bindIn(ns, name, this, prior);
  }

  @Override
  void releaseHandleIndex(long index) {
    proxyTable.release(index);
  }
}
