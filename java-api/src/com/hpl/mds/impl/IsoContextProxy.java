/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.impl;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.function.Supplier;
import java.util.function.BooleanSupplier;
import java.util.function.Predicate;
import java.util.function.Consumer;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import org.apache.log4j.Logger;

import com.hpl.erk.util.CollUtils;

import com.hpl.mds.*;


public class IsoContextProxy extends Proxy implements IsolationContext {
	
  private static final NativeLibraryLoader NATIVE_LIB_LOADER = NativeLibraryLoader.getInstance();
	
  private static final Logger log = Logger.getLogger(IsoContextProxy.class);

  private static final Proxy.Table<IsoContextProxy> 
    proxyTable = new Proxy.Table<>(IsoContextProxy::release);

  private IsoContextProxy parent_ = null;
  private Boolean isPublishable_ = null;
  private TaskProxy topLevelTask_ = null;
  private TaskProxy creationTask_ = null;
  private List<Consumer<? super IsoContextProxy>> successfulPublishHooks_ = null;
  private List<Consumer<? super IsoContextProxy>> failedPublishHooks_ = null;
  
  /*
   * We increment this on successful publish.  It is used by
   * TaskComputed to determine whether a dependency should be added.
   */
  AtomicInteger successfulPublishCount = new AtomicInteger(0);

  /*
   * We need to hold onto all contexts we may try to publish and all
   * of their potentially redoable tasks.  As soon as we successfully
   * publish or we call giveUp() on a context, we can clear its entry.
   * (If we try to publish again and see any tasks we dropped, we
   * won't be able to do it and will give up the redo.)
   */
  static final ConcurrentMap<IsoContextProxy, ConcurrentMap<TaskProxy, Runnable>>
    redoableTasks = new ConcurrentHashMap<>();
	
  static final IsoContextProxy global_ = fromHandle(globalHandle());
  static IsoContextProxy forProcess_ = null;
	
  private IsoContextProxy(long h) {
    super(h, proxyTable);
  }

  long getHandle() {
    return handleIndex_;
  }

  private static native void release(long h);
  private static native long parentHandle(long h);
  private static native long topLevelTaskHandle(long h);
  private static native long creationTaskHandle(long h);
  private static native long newChild(long h, int viewType, int modType);
  private static native long globalHandle();
  private static native long processHandle();
  private static native boolean isPublishable(long h);
  private static native boolean isSnapshot(long h);
  private static native boolean isReadOnly(long h);
  private static native boolean hasConflicts(long h);
  private static native long publish(long h);
  /*
   * Returns the task handle that's already been established.
   */
  private static native long push(long h);

  public static IsoContextProxy current() {
    return TaskProxy.current().getContext();
  }

  public static IsoContextProxy global() {
    return global_;
  }

  public static IsoContextProxy forProcess() {
    if (forProcess_ == null) {
      forProcess_ = fromHandle(processHandle());
    }
    return forProcess_;
  }

  @Override
  public IsoContextProxy parent() {
    if (parent_ == null) {
      parent_ = fromHandle(parentHandle(handleIndex_));
    }
    return parent_;
  }

  @Override
  public TaskProxy topLevelTask() {
    if (topLevelTask_ == null) {
      topLevelTask_ = TaskProxy.fromHandle(topLevelTaskHandle(handleIndex_));
    }
    return topLevelTask_;
  }

  @Override
  public TaskProxy creationTask() {
    if (creationTask_ == null) {
      creationTask_ = TaskProxy.fromHandle(creationTaskHandle(handleIndex_));
    }
    return creationTask_;
  }

  @Override
  public IsoContextProxy createNested(ViewType vt, ModificationType mt) {
    return fromHandle(newChild(handleIndex_, vt.ordinal(), mt.ordinal()));
  }
  class UseImpl implements Use {
    final TaskProxy task_;

    UseImpl(IsoContextProxy ctxt) {
      long th = push(ctxt.getHandle());
      //      System.out.format("UseImpl got task handle %d%n", th);
      task_ = TaskProxy.fromHandle(th);
      task_.setContext(ctxt);
      TaskProxy.noteCurrent(task_);
    }

    @Override
    public void close() {
      if (TaskProxy.current() != task_) {
        /*
         * We've blown stack discipline!
         */
        throw new ImproperStackDisciplineException();
      }
      TaskProxy.pop();
    }
  }

  @Override
  public Use use() {
    return new UseImpl(this);
  }

  @Override
  public PubResultProxy publish(PubOption options) {
    PubOptionImpl opts = (PubOptionImpl)options;
    PubOptionImpl.Control control = opts.getControl();
    return publish(control.reports(), control.forResolve());
  }

  public PubResultProxy tryPublish() {
    // System.out.format("Calling tryPublish() on %s%n", this);
    long h = publish(handleIndex_);
    PubResultProxy res = PubResultProxy.fromHandle(h);
    if (res.succeeded()) {
      // System.out.format("tryPublish() succeeded%n");
      successfulPublishCount.incrementAndGet();
      giveUp();
    }
    return res;
  }

  public PubResultProxy publish(Collection<PublishReport> reports,
                                Collection<Supplier<Predicate<PubResult>>> resolveControlSup)
  {
    // System.out.format("Trying Java publish%n");
    PubResultProxy pRes = tryPublish();
    if (!pRes.succeeded()) {
      List<Predicate<PubResult>> resolveControl = resolveControlSup.stream()
        .map(Supplier::get)
        .collect(Collectors.toList());
      while (!pRes.succeeded()) {
        // System.out.format("tryPublish() failed%n");
        PubResultProxy pr2 = pRes;
        if (!(resolveControl.stream().allMatch(p -> p.test(pr2))
              && pRes.resolve(reports))) {
          // System.out.format("Resolution failed%n");
          break;
        }
        // System.out.format("Resolution succeeded%n");
        // System.out.format("Calling tryPublish() again%n");
        pRes = tryPublish();
      }
    }
    if (pRes.succeeded()) {
      runSuccessfulPublishHooks();
    } else {
      runFailedPublishHooks();
    }
    return pRes;
  }

  @Override
  public void giveUp() {
    redoableTasks.remove(this);
  }


  @Override
  public <T extends ManagedObject> InContext<T> viewOf(T val) {
    // TODO Auto-generated method stub
    return null;
  }

  @Override
  public <T extends ManagedObject> InContext<T> viewOf(Supplier<? extends T> gen) {
    // TODO Auto-generated method stub
    return null;
  }


  @Override
  public boolean isPublishable() {
    if (isPublishable_ == null) {
      isPublishable_ = isPublishable(handleIndex_);
    }
    return isPublishable_;
  }

  @Override
  public boolean isReadOnly() {
    return isReadOnly(handleIndex_);
  }

  @Override
  public boolean isSnapshot() {
    return isSnapshot(handleIndex_);
  }

  @Override
  public boolean hasConflicts() {
    return hasConflicts(handleIndex_);
  }

  public static IsoContextProxy fromHandle(long handleIndex) {
    return proxyTable.fromIndex(handleIndex, IsoContextProxy::new);
  }

  @Override
  public <R> R callIsolated(PubOption options, Supplier<? extends R> func) {
    // System.out.format("In isolated block.  Context is %s%n", this);
    PubOptionImpl opts = (PubOptionImpl)options;
    PubOptionImpl.Control control = opts.getControl();

    final ViewType vt = control.viewType();
    final ModificationType mt = control.modType();

    if (mt != ModificationType.Full) {
      // System.out.format("Context is not publishable.  Just calling%n");
      IsoContextProxy child = createNested(vt, mt);
      R val = child.call(func);
      return val;
    }

    // System.out.format("Context is publishable.%n");

    Collection<PublishReport> reports = control.reports();

    reports.forEach(PublishReport::reset);

    List<BooleanSupplier> reRunControls = control.forReRun().stream()
      .map(Supplier::get).collect(Collectors.toList());
    Collection<Supplier<Predicate<PubResult>>> resolveControls = control.forResolve();

    PubResult pr;
    boolean cont = true;
    while (cont) {
      IsoContextProxy child = createNested(vt, mt);
      reports.forEach(r -> r.beforeRun(child));
      
      // System.out.format("Child context is %s%n", child);
      R val = child.call(func);
      // System.out.format("Isolated call returned %s%n", val);
      pr = child.publish(reports, resolveControls);
      // System.out.format("Java publish call returned%n");
      if (pr.succeeded()) {
        // System.out.format("Publish succeeded%n");
        reports.forEach(PublishReport::noteSuccess);
        return val;
      }
      // System.out.format("Publish failed%n");
      cont = reRunControls.stream().allMatch(BooleanSupplier::getAsBoolean);
      child.giveUp();
    }
    // System.out.format("Giving up on isolated block.%n");
    reports.forEach(PublishReport::noteFailure);
    throw new FailedTransactionException();
  }

  @Override
  public String toString() {
    return String.format("IsoContext[%,d]",
                         handleIndex_);
  }



  @Override
  void releaseHandleIndex(long index) {
    proxyTable.release(index);
  }

  private void runSuccessfulPublishHooks() {
    runHooks(successfulPublishHooks_);
  }

  private void runFailedPublishHooks() {
    runHooks(failedPublishHooks_);
  }

  private void runHooks(List<Consumer<? super IsoContextProxy>> hooks) {
    if (hooks != null) {
      creationTask().establishAndRun(()->hooks.forEach(hook->hook.accept(this)));
    }
  }

  @Override
  synchronized public void afterSuccessfulPublish(Consumer<? super IsoContextProxy> fn) {
    if (successfulPublishHooks_ == null) {
      successfulPublishHooks_ = new ArrayList<>();
    }
    successfulPublishHooks_.add(fn);
  }

  @Override
  synchronized public void afterFailedPublish(Consumer<? super IsoContextProxy> fn) {
    if (failedPublishHooks_ == null) {
      failedPublishHooks_ = new ArrayList<>();
    }
    failedPublishHooks_.add(fn);
  }




}
