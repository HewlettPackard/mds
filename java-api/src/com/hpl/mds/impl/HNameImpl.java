/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */


package com.hpl.mds.impl;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.Function;
import java.util.regex.Pattern;

import com.hpl.erk.util.ArrayUtils;
import com.hpl.mds.*;


public abstract class HNameImpl implements HName {
  private static final Root ROOT = new Root();
  private static final Self SELF = new Self();
  private static final Up INITIAL_UP = new Up(null);
  private static final String UP_STR = "..";
  private static final String SELF_STR = ".";
  private static final ManagedStringProxy UP_PROXY = ManagedStringProxy.valueOf(UP_STR);
  private static final ManagedStringProxy SELF_PROXY = ManagedStringProxy.valueOf(SELF_STR);
  private static final Pattern defaultSplitPattern = Pattern.compile(String.valueOf(HName.DEFAULT_SEPARATOR), Pattern.LITERAL);
  private static final Map<Character, Pattern> splitPatterns = new HashMap<>();
  private static InheritableThreadLocal<AbsoluteHNI> currentNamespace
  = new InheritableThreadLocal<AbsoluteHNI>() {
    protected AbsoluteHNI childValue(AbsoluteHNI parentValue) {
      return parentValue == null ? ROOT : parentValue;
    };
    protected AbsoluteHNI initialValue() {
    	return ROOT;
    };
  };
  

  
  protected final int depth;
  private ManagedStringProxy path;
  
  static abstract class AbsoluteHNI extends HNameImpl {
    @Override
    protected abstract AbsoluteHNI upLevel();
    
    public AbsoluteHNI(int depth) {
      super(depth);
    }

    @Override
    public boolean isAbsolute() {
      return true;
    }
    
    @Override
    protected NonRoot append(ManagedStringProxy childName) {
      return new NonRoot(this, childName);
    }
    
    @Override
    protected AbsoluteHNI appendTo(AbsoluteHNI prefix) {
      return this;
    }
    
    class DirUseImpl implements DirUse {
      final AbsoluteHNI prior;

      DirUseImpl() {
        prior = currentNamespace.get();
        currentNamespace.set(AbsoluteHNI.this);
      }

      @Override
      public void close() throws Exception {
        if (currentNamespace.get() == AbsoluteHNI.this) {
          /*
           * We only pop if we were actually there.
           * TODO: Do we need to make sure we don't have an ABA problem?
           */
          currentNamespace.set(prior);
        }
      }
      
    }
  }
  
  static class Root extends AbsoluteHNI {
    
    Root() {
      super(0);
    }

    @Override
    public ManagedStringProxy getName() {
      return null;
    }

    @Override
    public HNameImpl getParent() {
      return null;
    }

    @Override
    public boolean isRoot() {
      return true;
    }

    @Override
    protected Root upLevel() {
      // Should this throw?
      return this;
    }

    @Override
    public Namespace asNamespace() {
      return Namespace.root();
    }
  }
  
  static class NonRoot extends AbsoluteHNI {
    private final AbsoluteHNI parent;
    private final ManagedStringProxy name;
    private Namespace namespace;

    private NonRoot(AbsoluteHNI parent, ManagedStringProxy name) {
      super(parent.depth+1);
      this.parent = parent;
      this.name = name;
    }

    @Override
    public ManagedStringProxy getName() {
      return name;
    }

    @Override
    public HNameImpl getParent() {
      return parent;
    }

    @Override
    protected AbsoluteHNI upLevel() {
      return parent;
    }

    @Override
    public Namespace asNamespace() {
      if (namespace == null) {
    	  namespace = parent.asNamespace().childNamespace(name);
      }
      return namespace;
    }

  }
  
  static abstract class RelativeHNI extends HNameImpl {
    public RelativeHNI(int depth) {
      super(depth);
    }

    @Override
    public boolean isAbsolute() {
      return false;
    }
    
    @Override
    protected HNameImpl append(ManagedStringProxy childName) {
      return new RelPath(this, childName);
    }
    
    @Override
    public Namespace asNamespace() {
    	AbsoluteHNI abs = appendTo(getCurrent());
    	return abs.asNamespace();
    }
  }
  
  static class Up extends RelativeHNI {
    private final Up parent;
    
    Up(Up parent) {
      super(parent == null ? 1 : parent.depth+1);
      this.parent = parent;
    }

    @Override
    public ManagedStringProxy getName() {
      return UP_PROXY;
    }

    @Override
    public HNameImpl getParent() {
      return parent;
    }

    @Override
    protected AbsoluteHNI appendTo(AbsoluteHNI prefix) {
      return prefix.upLevel();
    }

    @Override
    protected Up upLevel() {
      return new Up(this);
    }
    
  }
  
  static class RelPath extends RelativeHNI {
    private final RelativeHNI parent;
    private final ManagedStringProxy name;
    
    RelPath(RelativeHNI parent, ManagedStringProxy name) {
      super(parent == SELF ? 1 : parent.depth+1);
      this.parent = parent;
      this.name = name;
    }

    @Override
    public ManagedStringProxy getName() {
      return name;
    }

    @Override
    public HNameImpl getParent() {
      return parent;
    }

    @Override
    protected AbsoluteHNI appendTo(AbsoluteHNI prefix) {
      if (parent != null) {
        prefix = parent.appendTo(prefix);
      }
      return prefix.append(name);
    }

    @Override
    protected RelativeHNI upLevel() {
      return parent;
    }

  }
  
  static class Self extends RelativeHNI {
    
    public Self() {
      super(1);
    }

    @Override
    public ManagedStringProxy getName() {
      return SELF_PROXY;
    }

    @Override
    public HNameImpl getParent() {
      return null;
    }

    @Override
    protected AbsoluteHNI appendTo(AbsoluteHNI prefix) {
      return prefix;
    }

    @Override
    protected HNameImpl append(ManagedStringProxy childName) {
      return new RelPath(this, childName);
    }

    @Override
    protected Up upLevel() {
      /*
       * The only time this should happen is at the beginning of a parse
       */
      return INITIAL_UP;
    }

    
  }
  
  protected abstract AbsoluteHNI appendTo(AbsoluteHNI prefix);
  protected abstract HNameImpl append(ManagedStringProxy childName);
  protected abstract HNameImpl upLevel();
  
  public HNameImpl(int depth) {
    this.depth = depth;
  }
  
  @Override
  public boolean isRoot() {
    return false;
  }
  
  @Override
  public abstract ManagedStringProxy getName();
  
  @Override
  public abstract HNameImpl getParent();
  
  private <T> T[] fillArray(Class<T> cls, Function<? super HNameImpl, ? extends T> func, boolean includeRoot) {
    int len = (includeRoot && isAbsolute()) ? depth+1 : depth;
    T[] array = ArrayUtils.newArray(cls, len);
    HNameImpl n = this;
    for (int i = len-1; i>=0; i--,n=n.getParent()) {
      array[i] = func.apply(n);
    }
    return array;
  }
  
  private <T> T[] fillArray(Class<T> cls, Function<? super HNameImpl, ? extends T> func) {
    return fillArray(cls, func, false);
  }
  

  @Override
  public Iterator<ManagedString> iterator() {
    return segments().iterator();
  }

  @Override
  public int length() {
    return depth;
  }

  @Override
  public List<ManagedString> segments() {
    return Arrays.asList(fillArray(ManagedString.class, HName::getName));
  }

  @Override
  public List<String> stringSegments() {
    return Arrays.asList(ArrayUtils.map(implSegments(), ManagedStringProxy::asString, String.class));
  }

  @Override
  public List<HName> prefixes(boolean includeRoot) {
    return Arrays.asList(fillArray(HName.class, Function.identity(), true));
  }

  
  @Override
  public ManagedStringProxy asManagedString(char sep) {
    if (sep == DEFAULT_SEPARATOR) {
      if (path == null) {
        path = computePath(sep);
      }
      return path;
    } else {
      return computePath(sep);
    }
  }
  private ManagedStringProxy computePath(char sep) {
    String s = String.join(String.valueOf(sep), implSegments());
    return ManagedStringProxy.valueOf(s);
  }

  @Override
  public String asString(char sep) {
    return path.asString();
  }
  
  @Override
  public String toString() {
    return asString();
  }

  private ManagedStringProxy[] implSegments() {
    return fillArray(ManagedStringProxy.class, HNameImpl::getName);
  }
  
  private HNameImpl resolve(ManagedStringProxy[] continuation) {
    HNameImpl n = this;
    for (ManagedStringProxy s : continuation) {
      n = n.addSeg(s);
    }
    return n;
  }
  private HNameImpl addSeg(ManagedStringProxy s) {
    switch (s.toString()) {
    case SELF_STR:
      return this;
    case UP_STR:
      return upLevel();
    default:
      return append(s);
    }
  }
  
  @Override
  public HNameImpl resolve(HName continuation) {
    HNameImpl hni = (HNameImpl)continuation;
    return resolve(hni.implSegments());
  }


  @Override
  public boolean alias(HName... aliases) {
    // TODO
    return Stub.notImplemented();
  }

  @Override
  public boolean alias(Collection<? extends HName> aliases) {
    // TODO
    return Stub.notImplemented();
  }
  
  private static Pattern splitPattern(char sep) {
    if (sep == HName.DEFAULT_SEPARATOR) {
      return defaultSplitPattern;
    }
    synchronized (splitPatterns) {
      Character key = sep;
      Pattern p = splitPatterns.get(key);
      if (p == null) {
        p = Pattern.compile(String.valueOf(sep), Pattern.LITERAL);
        splitPatterns.put(key, p);
      }
      return p;
    }
  }

  public static HNameImpl from(char separator, List<? extends CharSequence> segments) {
    HNameImpl n = null;
    Pattern p = splitPattern(separator);

    for (CharSequence seg : segments) {
      final String segStr = seg.toString();
      if (n == null) {
        // To be absolute, the first segment has to start with the separator or be the separator.
        n = segStr.startsWith(String.valueOf(separator)) ? ROOT : SELF;
      }
      for (String s : p.split(segStr)) {
        if (!s.isEmpty()) {
          n = n.addSeg(ManagedStringProxy.valueOf(s));
        }
      }
    }
    // If there was nothing, we just use "."
    return n == null ? SELF : n;
  }

  public static HNameImpl root() {
    return ROOT;
  }
  public static AbsoluteHNI getCurrent() {
    return currentNamespace.get();
  }
  
  
  @Override
  public DirUse makeCurrent() {
    AbsoluteHNI newDir = appendTo(getCurrent());
    // By construction, anthing appended to an absolute path is an absolute path.
    return newDir.new DirUseImpl();
  }
  

}
 
