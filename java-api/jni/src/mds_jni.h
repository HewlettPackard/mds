/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef _MDS_JNI_H_
#define _MDS_JNI_H_

#include <jni.h>
#include "mds_core_api.h"

#include <iostream>
#include <typeinfo>
#include <sstream>

namespace mds {
  namespace jni {

    enum class ARITH_OP {add, sub, mul, div};

    size_t
    get_handle_index(JNIEnv *jEnv, 
      jobject jProxyObj, const char *indexFieldName);


    void
    set_handle_index(JNIEnv *jEnv,
      jobject jProxyObj, const char *indexFieldName, size_t index);


    api::record_type_handle
    get_record_type_handle(JNIEnv *jEnv, jobject jRecordTypeProxyObj);


    api::managed_record_handle
    get_managed_record_handle(JNIEnv *jEnv, jobject jManagedRecordObj);

    void
    set_managed_record_handle(JNIEnv *jEnv, jobject jManagedRecordObj, 
        api::managed_record_handle mr);

    void
    set_interned_string_handle(JNIEnv *jEnv, jobject jManagedStringObj,
    	api::interned_string_handle is);

    void throwUnboundNameEx(JNIEnv *jEnv);
    void throwIncompatibleTypeEx(JNIEnv *jEnv);
    void throwIncompatibleRecordTypeEx(JNIEnv *jEnv);
    void throwIncompatibleSuperClassEx(JNIEnv *jEnv);
    void throwUnmodifiableRecordTypeEx(JNIEnv *jEnv);
    void throwReadOnlyContextEx(JNIEnv *jEnv);
    void throwUnpublishableContextEx(JNIEnv *jEnv);
    void throwUnimplementedEx(JNIEnv *jEnv);
    void throwUnknownEx(JNIEnv *jEnv);
    void throwUnknownEx(JNIEnv *jEnv, const std::string &desc);
    void stubNotImplemented(JNIEnv *jEnv);
    void exception_converter(JNIEnv *jEnv);

    void initialize_thread(JNIEnv *jEnv);
    
    inline void ensure_thread_initialized(JNIEnv *jEnv) {
      static thread_local bool initialized = false;
      if (!initialized) {
        initialize_thread(jEnv);
        initialized = true;
      }
    }

    template<typename Callable, typename ... Args>
      inline auto
      exception_handler_wr (JNIEnv *jEnv, Callable&& func, Args&&... args)
      -> typename std::result_of<Callable(Args...)>::type
      {
        try
      	  {
      	    return func (std::forward<Args>(args)...);
      	  }
      	catch (...)
      	  {
      	    exception_converter(jEnv);
      	  }
      	return typename std::result_of<Callable(Args...)>::type{};
      }

    template<typename Callable, typename ... Args>
      void
      exception_handler (JNIEnv *jEnv, Callable&& func, Args&&... args)
      {
	try
	  {
	    func (std::forward<Args>(args)...);
	  }
	catch (...)
	  {
	    exception_converter(jEnv);
	  }
      }

    template<core::kind KIND>
      struct str_to_long
      {
	using type = typename std::conditional<
	    KIND == core::kind::STRING,
	    mds::api::api_type<core::kind::LONG>,
	    mds::api::api_type<KIND>
	>::type;
      };

    template <typename T, typename ...Formals, typename...Args>
    inline T as_global_ref(JNIEnv *env, T (JNIEnv::*f)(Formals...), Args&&...args) {
      T local = (env->*f)(std::forward<Args>(args)...);
      if (local == nullptr) {
        return nullptr;
      }
      T global = static_cast<T>(env->NewGlobalRef(local));
      if (global == nullptr) {
        return nullptr;
      }
      return global;
    }

    inline jclass find_class(JNIEnv *env, const char *name) {
      return as_global_ref(env, &JNIEnv::FindClass, name);
    }

    inline jmethodID find_method(JNIEnv *env, jclass cls,
                                 const char *name, const char *sig) {
      return env->GetMethodID(cls, name, sig);
    }

    inline jmethodID find_ctor(JNIEnv *env, jclass cls, const char *sig) {
      return find_method(env, cls, "<init>", sig);
    }

    inline jmethodID find_static_method(JNIEnv *env, jclass cls,
                                        const char *name, const char *sig) {
      return env->GetStaticMethodID(cls, name, sig);
    }

    class java_ex {
      const jclass clss;
      jmethodID ctor;
    public:
      java_ex(JNIEnv *env, const char *name, const char *sig = "()V")
        : clss(find_class(env, name)),
          ctor(clss==nullptr ? nullptr : find_ctor(env, clss, sig))
      {}
      template <typename ...Args>
      jint raise(JNIEnv *env, Args...args) {
        if (clss != nullptr && ctor != nullptr) {
          jobject ex = env->NewObject(clss, ctor, std::forward<Args>(args)...);
          return env->Throw(static_cast<jthrowable>(ex));
        } else {
          return -1;
        }
      }
               
    };

    template <typename T>
    inline bool handle_to_same(jlong aHIndex, jlong bHIndex) {
      T a = api::handle_store<T>::get(aHIndex);
      T b = api::handle_store<T>::get(bHIndex);
      return a == b;
    }


    template <typename H>
    struct handle_store_traits {
    	using storage_type = typename H::non_const_type;
    	static auto to_storage_type(const H &val) {
    		return val.ignore_const();
    	}
    };

    /*
     * The logic here is that if we are created with a jlong, then
     * that was a parameter passed down from a Java native method
     * invocation and it's a handleIndex held by a proxy.  Therefore,
     * we don't increment the number of refs in the handle store and
     * we count on the slot remaining valid as long as the object is
     * live (since its finalize method will be needed to decrement).
     * On the other hand, if we're created with an object, then
     * store() has incremented the ref count.  Unless steal_index()
     * has been called, our dtor will, therefore, call release() to
     * decrement.  This can happen if this is just a temporary created
     * in the middle of a JNI.
     */

    template <typename H>
    class indexed {
      jlong index;
      mutable H value;
      bool holds_reference;
      using traits_type = handle_store_traits<H>;
      using hs_type = mds::api::unique_handle_store<typename traits_type::storage_type>;

    public:

      H *operator ->() const {
        return &value;
      }

      H operator *() const {
    	  return value;
      }

      explicit indexed(jlong i)
	: index(i),
	  value(hs_type::get(i)),
	  holds_reference(false)
      {}
      explicit indexed(const H &v)
	: index(static_cast<jlong>(hs_type::store(traits_type::to_storage_type(v)))),
	  value(v),
	  holds_reference(index != 0)
      {}

      indexed(const indexed &other)
	: index(other.index),
	  value(other.value),
	  holds_reference(index != 0)
      {
	hs_type::add_ref(index);
      }

      indexed(indexed &&other)
	: index(other.index),
	  value(std::move(other.value)),
	  holds_reference(other.holds_reference)
      {
	other.index = 0;
	other.holds_reference = false;
      }

      indexed &operator =(const indexed &other) {
	if (holds_reference) {
	  hs_type::free(index);
	}
	index = other.index;
	value = other.value;
	if (index = 0) {
	  holds_reference = false;
	} else {
	  hs_type::add_ref(index);
	  holds_reference = true;
	}
	return *this;
      }

      indexed &operator =(indexed &&other) {
	if (holds_reference) {
	  hs_type::free(index);
	}
	index = other.index;
	value = std::move(other.value);
	holds_reference = other.holds_reference;
	other.index = 0;
	other.holds_reference = false;
      }
      

      ~indexed() {
	if (holds_reference) {
	  hs_type::free(index);
	}
      }

      bool operator==(const indexed<H> &other) const {
        return value == other.value;
      }
      bool operator==(const H &v) const {
        return value == v;
      }

      void release() {
	// This should only be called on a handle passed down.
	assert(!holds_reference);
	hs_type::free(index);
	index = 0;
	value = H{};
	holds_reference = false;
      }

      jlong return_index() {
	if (holds_reference) {
	  holds_reference = false;
	} else if (index != 0) {
	  hs_type::add_ref(index);
	}
	return index;
      }

      jlong peek_index() const {
	return index;
      }

      jstring to_string(JNIEnv *jEnv) const {
        using namespace std;
        if (index == 0)
          {
            return nullptr;
          }
        return exception_handler_wr(jEnv, [=]
                                    {
                                      std::ostringstream ss;
                                      ss << *this;
                                      auto ssstr = ss.str();
                                      std::basic_string<jchar> s{ssstr.begin(), ssstr.end()};
                                      return jEnv->NewString(s.c_str(), s.length());
                                    });
      }
    };

  }
}

namespace std {
  template <typename C, typename Tr, typename H>
  basic_ostream<C,Tr> &
  operator <<(basic_ostream<C,Tr> &os, const mds::jni::indexed<H> &h) {
    return os << typeid(H).name() << " #" << h.peek_index() << ": " << *h;
  }

}

#endif /* _MDS_JNI_H_ */
