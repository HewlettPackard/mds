/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include "mds-debug.h"
#include "mds_core_api.h"                           // MDS Core API
#include "mds_jni.h"

using namespace mds;
using namespace mds::api;
using namespace mds::jni;

namespace mds
{
  namespace jni
  {
    namespace field_proxy
    {

      template<kind KIND>
	inline void
	release (api_type<kind::LONG> hIndex)
	{
	  indexed<record_field_handle<KIND>> self
	    { hIndex };
	  self.release ();
	}

      template<kind KIND>
	inline api_type<kind::LONG>
	get_name_handle (api_type<kind::LONG> hIndex)
	{
	  indexed<record_field_handle<KIND>> h
	    { hIndex };
	  indexed<interned_string_handle> name
	    { h->name () };
	  return name.return_index ();
	}

      template<kind KIND>
	inline api_type<kind::LONG>
	get_rec_type_handle (api_type<kind::LONG> hIndex)
	{
	  /*
	   * Not handling caching or defaults yet
	   */
	  indexed<record_field_handle<KIND>> h
	    { hIndex };
	  indexed<const_record_type_handle> rt
	    { h->rec_type () };
	  return rt.return_index ();
	}

      template<kind KIND>
	inline api_type<kind::LONG>
	create_field_in (api_type<kind::LONG> recTypeHIndex,
			 api_type<kind::LONG> nameHIndex)
	{
	  indexed<record_type_handle> rec_type
	    { recTypeHIndex };
	  indexed<interned_string_handle> name
	    { nameHIndex };
          // std::cout << "Looking for field '" << *name << "'"
          //           << " in " << rec_type->name()
          //           << std::endl;
            
	  indexed<record_field_handle<KIND>> h
	    { managed_handle_by_kind<KIND> ().field_in (*rec_type, *name, true) };
	  return h.return_index ();
	}

      template<kind KIND>
	api_type<kind::LONG>
	create_array_field_in (api_type<kind::LONG> recTypeHIndex,
			       api_type<kind::LONG> nameHIndex)
	{
	  indexed<record_type_handle> rec_type
	    { recTypeHIndex };
	  indexed<interned_string_handle> name
	    { nameHIndex };
	  indexed<record_field_handle<kind::ARRAY>> h
	    { managed_array_handle_by_kind<KIND> ().field_in (*rec_type, *name,
	    true) };
	  return h.return_index ();
	}

      template<kind KIND>
	api_type<kind::LONG>
	get_array_value_handle (api_type<kind::LONG> hIndex,
				api_type<kind::LONG> recHIndex)
	{
	  /*
	   * Not handling caching or defaults yet
	   */
	  indexed<record_field_handle<kind::ARRAY>> h
	    { hIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  indexed<managed_array_base_handle> baseval
          { h->frozen_read(*rec) };
	  indexed<managed_array_handle<KIND>> val
	    { managed_array_handle<KIND> (
		baseval->pointer ()->template downcast<KIND> (),
		baseval->view ()) };
	  return val.return_index ();
	}

      template<kind KIND>
	api_type<kind::LONG>
	peek_array_value_handle (api_type<kind::LONG> hIndex,
                                 api_type<kind::LONG> recHIndex)
	{
	  /*
	   * Not handling caching or defaults yet
	   */
	  indexed<record_field_handle<kind::ARRAY>> h
	    { hIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  indexed<managed_array_base_handle> baseval
          { h->free_read(*rec) };
	  indexed<managed_array_handle<KIND>> val
	    { managed_array_handle<KIND> (
		baseval->pointer ()->template downcast<KIND> (),
		baseval->view ()) };
	  return val.return_index ();
	}

      template<kind KIND>
	inline typename str_to_long<KIND>::type
	get_value (api_type<kind::LONG> hIndex,
                   api_type<kind::LONG> recHIndex)
	{
	  indexed<record_field_handle<KIND> > h
	    { hIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  return h->frozen_read(*rec);
	}
      template<kind KIND>
	inline typename str_to_long<KIND>::type
	peek_value (api_type<kind::LONG> hIndex,
                    api_type<kind::LONG> recHIndex)
	{
	  indexed<record_field_handle<KIND> > h
	    { hIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  return h->free_read(*rec);
	}

      template<>
	inline typename str_to_long<kind::STRING>::type
	get_value<kind::STRING> (api_type<kind::LONG> hIndex,
				 api_type<kind::LONG> recHIndex)
	{
	  indexed<record_field_handle<kind::STRING> > h
	    { hIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  api_type<kind::STRING> val = h->frozen_read(*rec);
	  indexed<interned_string_handle> s
	    { val };
	  return s.return_index ();
	}
      template<>
	inline typename str_to_long<kind::STRING>::type
	peek_value<kind::STRING> (api_type<kind::LONG> hIndex,
                                  api_type<kind::LONG> recHIndex)
	{
	  indexed<record_field_handle<kind::STRING> > h
	    { hIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  api_type<kind::STRING> val =
            h->free_read(*rec);
	  indexed<interned_string_handle> s
	    { val };
	  return s.return_index ();
	}

      template<kind KIND>
	inline typename str_to_long<KIND>::type
	set_value (api_type<kind::LONG> hIndex,
                   api_type<kind::LONG> recHIndex,
		   typename str_to_long<KIND>::type valArg,
                   ret_mode returning = ret_mode::resulting_val)
	{
	  indexed<record_field_handle<KIND>> h
	    { hIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  return h->write (*rec, valArg, returning);
	}

      template<>
	inline typename str_to_long<kind::STRING>::type
	set_value<kind::STRING> (api_type<kind::LONG> hIndex,
				 api_type<kind::LONG> recHIndex,
				 typename str_to_long<kind::STRING>::type valArg,
                                 ret_mode returning)
	{
	  indexed<record_field_handle<kind::STRING>> h
	    { hIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  indexed<interned_string_handle> s
	    { valArg };
	  api_type<kind::STRING> val
	    { *s };
	  indexed<interned_string_handle> old
          { h->write (*rec, val, returning) };
	  return old.return_index ();
	}

      template<kind KIND>
	inline bool
	init_final (api_type<kind::LONG> hIndex,
                    api_type<kind::LONG> recHIndex,
                    typename str_to_long<KIND>::type valArg)
	{
	  indexed<record_field_handle<KIND>> h
	    { hIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  return h->write_initial(*rec, valArg);
	}

      template<>
	inline bool
      init_final<kind::STRING> (api_type<kind::LONG> hIndex,
                                api_type<kind::LONG> recHIndex,
                                typename str_to_long<kind::STRING>::type valArg)
	{
	  indexed<record_field_handle<kind::STRING>> h
	    { hIndex };
	  indexed<managed_record_handle> rec
          { recHIndex };
	  indexed<interned_string_handle> s
          { valArg };
	  api_type<kind::STRING> val
          { *s };
	  return h->write_initial(*rec, val);
	}

      template<kind KIND>
	inline api_type<kind::LONG>
	set_array_value_handle (api_type<kind::LONG> hIndex,
				api_type<kind::LONG> recHIndex,
				api_type<kind::LONG> valArg,
                                ret_mode returning = ret_mode::resulting_val)
	{
	  indexed<record_field_handle<kind::ARRAY>> h
	    { hIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  indexed<managed_array_handle<KIND>> val
	    { valArg };
	  auto v = h->write (*rec, *val, returning);
	  managed_array_handle<KIND> vdc;
	  if (v != nullptr)
	    {
	      managed_array_handle<KIND> vdc2 (
		  v.pointer ()->template downcast<KIND> (), v.view ());
	      vdc = vdc2;
	    }
	  indexed<managed_array_handle<KIND>> old (vdc);
	  return old.return_index ();
	}

      template<kind KIND>
	inline api_type<kind::LONG>
	init_final_array (api_type<kind::LONG> hIndex,
                          api_type<kind::LONG> recHIndex,
                          api_type<kind::LONG> valArg)
	{
	  indexed<record_field_handle<kind::ARRAY>> h
	    { hIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  indexed<managed_array_handle<KIND>> val
	    { valArg };
	  return h->write_initial(*rec, *val);
	}


      template<kind KIND, ARITH_OP OP>
	inline api_type<kind::BOOL>
	modify_value (api_type<kind::LONG> hIndex,
		      api_type<kind::LONG> recHIndex,
                      api_type<KIND> val,
                      ret_mode returning = ret_mode::resulting_val)
	{
	  // Check if OP is supported by the field proxy type :)
	  static_assert(OP == ARITH_OP::add || OP == ARITH_OP::sub ||
	      OP == ARITH_OP::mul || OP == ARITH_OP::div,
	      "Not supported arithmetic operation, please add "
	      "the new operation into the switch block bellow");

	  indexed<record_field_handle<KIND>> h
	    { hIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  switch (OP)
	    {
	    case ARITH_OP::add:
	      return h->add (*rec, val, returning);
	    case ARITH_OP::sub:
	      return h->sub (*rec, val, returning);
	    case ARITH_OP::mul:
	      return h->mul (*rec, val, returning);
	    case ARITH_OP::div:
	      return h->div (*rec, val, returning);
	    }
	}
    }
  }
}
