/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include "mds-debug.h"
#include "mds_core_api.h"                           // MDS Core API
#include "mds_jni.h"

using namespace mds;
using namespace mds::api;
using namespace mds::jni;

namespace mds
{
  namespace jni
  {
    namespace field_proxy
    {

      template<kind KIND>
	inline void
	release (api_type<kind::LONG> hIndex)
	{
	  indexed<record_field_handle<KIND>> self
	    { hIndex };
	  self.release ();
	}

      template<kind KIND>
	inline api_type<kind::LONG>
	get_name_handle (api_type<kind::LONG> hIndex)
	{
	  indexed<record_field_handle<KIND>> h
	    { hIndex };
	  indexed<interned_string_handle> name
	    { h->name () };
	  return name.return_index ();
	}

      template<kind KIND>
	inline api_type<kind::LONG>
	get_rec_type_handle (api_type<kind::LONG> hIndex)
	{
	  /*
	   * Not handling caching or defaults yet
	   */
	  indexed<record_field_handle<KIND>> h
	    { hIndex };
	  indexed<const_record_type_handle> rt
	    { h->rec_type () };
	  return rt.return_index ();
	}

      template<kind KIND>
	inline api_type<kind::LONG>
	create_field_in (api_type<kind::LONG> recTypeHIndex,
			 api_type<kind::LONG> nameHIndex)
	{
	  indexed<record_type_handle> rec_type
	    { recTypeHIndex };
	  indexed<interned_string_handle> name
	    { nameHIndex };
	  indexed<record_field_handle<KIND>> h
	    { managed_handle_by_kind<KIND> ().field_in (*rec_type, *name, true) };
	  return h.return_index ();
	}

      template<kind KIND>
	api_type<kind::LONG>
	create_array_field_in (api_type<kind::LONG> recTypeHIndex,
			       api_type<kind::LONG> nameHIndex)
	{
	  indexed<record_type_handle> rec_type
	    { recTypeHIndex };
	  indexed<interned_string_handle> name
	    { nameHIndex };
	  indexed<record_field_handle<kind::ARRAY>> h
	    { managed_array_handle_by_kind<KIND> ().field_in (*rec_type, *name,
	    true) };
	  return h.return_index ();
	}

      template<kind KIND>
	api_type<kind::LONG>
	get_array_value_handle (api_type<kind::LONG> hIndex,
				api_type<kind::LONG> ctxtHIndex,
				api_type<kind::LONG> recHIndex)
	{
	  indexed<record_field_handle<kind::ARRAY>> h
	    { hIndex };
	  indexed<iso_context_handle> ctxt
	    { ctxtHIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  indexed<managed_array_base_handle> baseval
	    { h->read_frozen(*ctxt, *rec) };
	  indexed<managed_array_handle<KIND>> val
	    { managed_array_handle<KIND> (
		baseval->pointer ()->template downcast<KIND> (),
		baseval->branch ()) };
	  return val.return_index ();
	}

      template<kind KIND>
	api_type<kind::LONG>
	peek_array_value_handle (api_type<kind::LONG> hIndex,
				api_type<kind::LONG> ctxtHIndex,
				api_type<kind::LONG> recHIndex)
	{
	  indexed<record_field_handle<kind::ARRAY>> h
	    { hIndex };
	  indexed<iso_context_handle> ctxt
	    { ctxtHIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  indexed<managed_array_base_handle> baseval
	    { h->read(*ctxt, *rec) };
	  indexed<managed_array_handle<KIND>> val
	    { managed_array_handle<KIND> (
		baseval->pointer ()->template downcast<KIND> (),
		baseval->branch ()) };
	  return val.return_index ();
	}

      template<kind KIND>
	inline typename str_to_long<KIND>::type
	get_value (api_type<kind::LONG> hIndex, api_type<kind::LONG> ctxtHIndex,
		   api_type<kind::LONG> recHIndex)
	{
	  indexed<record_field_handle<KIND> > h
	    { hIndex };
	  indexed<iso_context_handle> ctxt
	    { ctxtHIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  return h->read_frozen(*ctxt, *rec);
	}

      template<kind KIND>
	inline typename str_to_long<KIND>::type
	peek_value (api_type<kind::LONG> hIndex, api_type<kind::LONG> ctxtHIndex,
                    api_type<kind::LONG> recHIndex)
	{
	  indexed<record_field_handle<KIND> > h
	    { hIndex };
	  indexed<iso_context_handle> ctxt
	    { ctxtHIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  return h->read(*ctxt, *rec);
	}

      template<>
	inline typename str_to_long<kind::STRING>::type
	get_value<kind::STRING> (api_type<kind::LONG> hIndex,
				 api_type<kind::LONG> ctxtHIndex,
				 api_type<kind::LONG> recHIndex)
	{
	  indexed<record_field_handle<kind::STRING> > h
	    { hIndex };
	  indexed<iso_context_handle> ctxt
	    { ctxtHIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  api_type<kind::STRING> val = h->read_frozen(*ctxt, *rec);
	  indexed<interned_string_handle> s
	    { val };
	  return s.return_index ();
	}

      template<>
	inline typename str_to_long<kind::STRING>::type
	peek_value<kind::STRING> (api_type<kind::LONG> hIndex,
                                  api_type<kind::LONG> ctxtHIndex,
                                  api_type<kind::LONG> recHIndex)
	{
	  indexed<record_field_handle<kind::STRING> > h
	    { hIndex };
	  indexed<iso_context_handle> ctxt
	    { ctxtHIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  api_type<kind::STRING> val = h->read(*ctxt, *rec);
	  indexed<interned_string_handle> s
	    { val };
	  return s.return_index ();
	}

      template<kind KIND>
	inline typename str_to_long<KIND>::type
	set_value (api_type<kind::LONG> hIndex, api_type<kind::LONG> ctxtHIndex,
		   api_type<kind::LONG> recHIndex,
		   typename str_to_long<KIND>::type valArg)
	{
	  indexed<record_field_handle<KIND>> h
	    { hIndex };
	  indexed<iso_context_handle> ctxt
	    { ctxtHIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  return h->write (*ctxt, *rec, valArg);
	}

      template<>
	inline typename str_to_long<kind::STRING>::type
	set_value<kind::STRING> (api_type<kind::LONG> hIndex,
				 api_type<kind::LONG> ctxtHIndex,
				 api_type<kind::LONG> recHIndex,
				 typename str_to_long<kind::STRING>::type valArg)
	{
	  indexed<record_field_handle<kind::STRING>> h
	    { hIndex };
	  indexed<iso_context_handle> ctxt
	    { ctxtHIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  indexed<interned_string_handle> s
	    { valArg };
	  api_type<kind::STRING> val
	    { *s };
	  indexed<interned_string_handle> old
	    { h->write (*ctxt, *rec, val) };
	  return old.return_index ();
	}

      template<kind KIND>
	inline api_type<kind::LONG>
	set_array_value_handle (api_type<kind::LONG> hIndex,
				api_type<kind::LONG> ctxtHIndex,
				api_type<kind::LONG> recHIndex,
				api_type<kind::LONG> valArg)
	{
	  indexed<record_field_handle<kind::ARRAY>> h
	    { hIndex };
	  indexed<iso_context_handle> ctxt
	    { ctxtHIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  indexed<managed_array_handle<KIND>> val
	    { valArg };
	  auto v = h->write (*ctxt, *rec, *val);
	  managed_array_handle<KIND> vdc;
	  if (v != nullptr)
	    {
	      managed_array_handle<KIND> vdc2 (
		  v.pointer ()->template downcast<KIND> (), v.branch ());
	      vdc = vdc2;
	    }
	  indexed<managed_array_handle<KIND>> old (vdc);
	  return old.return_index ();
	}

      template<kind KIND>
	inline void
	set_to_parent (api_type<kind::LONG> hIndex,
		       api_type<kind::LONG> ctxtHIndex,
		       api_type<kind::LONG> recHIndex)
	{
	  indexed<record_field_handle<KIND>> h
	    { hIndex };
	  indexed<iso_context_handle> ctxt
	    { ctxtHIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };

	  // setToParent with resolving set, so conflict is cleared before rerun
	  h->set_to_parent (*ctxt, *rec, res_mode::resolving);
	}

      template<kind KIND>
	inline void
	rollback (api_type<kind::LONG> hIndex, api_type<kind::LONG> ctxtHIndex,
		  api_type<kind::LONG> recHIndex)
	{
	  indexed<record_field_handle<KIND>> h
	    { hIndex };
	  indexed<iso_context_handle> ctxt
	    { ctxtHIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };

	  // rollback - resolving not set - since this resets state for rerun,
	  // not resolving any existing conflict
	  h->roll_back (*ctxt, *rec);
	}

      template<kind KIND, ARITH_OP OP>
	inline api_type<kind::BOOL>
	modify_value (api_type<kind::LONG> hIndex,
		      api_type<kind::LONG> ctxtHIndex,
		      api_type<kind::LONG> recHIndex, api_type<KIND> val)
	{
	  // Check if OP is supported by the field proxy type :)
	  static_assert(OP == ARITH_OP::add || OP == ARITH_OP::sub ||
	      OP == ARITH_OP::mul || OP == ARITH_OP::div,
	      "Not supported arithmetic operation, please add "
	      "the new operation into the switch block bellow");

	  indexed<record_field_handle<KIND>> h
	    { hIndex };
	  indexed<iso_context_handle> ctxt
	    { ctxtHIndex };
	  indexed<managed_record_handle> rec
	    { recHIndex };
	  switch (OP)
	    {
	    case ARITH_OP::add:
	      return h->add (*ctxt, *rec, val);
	    case ARITH_OP::sub:
	      return h->sub (*ctxt, *rec, val);
	    case ARITH_OP::mul:
	      return h->mul (*ctxt, *rec, val);
	    case ARITH_OP::div:
	      return h->div (*ctxt, *rec, val);
	    }
	}
    }
  }
}
