/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */




// - get_field_index (generalise beyond recordtype specifically?)
//   - takes jEnv, jProxyObj, const char* index_field_name
//   - return size_t handle_index
//     - get proxyClass
//     - get fieldID
//     - getLongField
//     - cast long to size_t index
//     - return size_t index
// 
// set_field_index (generalise beyond recordtype specifically?)
//   - given a handle index to be stored in a Java proxy
//     find the field in the proxy and write the handle index to it
//   - takes jEnv, jobject jProxyObj, const char* index_field_name, size_t handle_i
// ndex
//     - get proxyClass
//     - get fieldID
//     - cast index to jlong
//     - setLongField
//     - return success
// 
// - record_type_handle_get
//   - given a record_type_handle index
//   - returns record_type_handle
//     - invoke get_field_index on record type (?)
//     - invoke handle_store<record_type_handle>::get(rt_index)
//     - return record_type_handle



#include "mds_core_api.h"
#include "mds-debug.h"
#include "mds_jni.h"

using namespace mds;
using namespace mds::api;
using namespace std;
//using namespace mds::jni;


size_t
mds::jni::get_handle_index(JNIEnv *jEnv,
          jobject jProxyObj, const char *indexFieldName)
{
    // get handle index field
    jclass proxyClass = jEnv->GetObjectClass(jProxyObj);
    jfieldID indexField = jEnv->GetFieldID(proxyClass, indexFieldName, "J");  //"J" is type signature for long
    dout << "indexField = " << indexField << endl;

    // get handle index
    jlong index_long = jEnv->GetLongField(jProxyObj, indexField);
    dout << "index_long = " << index_long << endl;
    size_t index = (size_t)index_long;
    dout << "index = " << index << endl;
    return index;
}


void
mds::jni::set_handle_index(JNIEnv *jEnv,
          jobject jProxyObj, const char *indexFieldName, size_t index)
{
    // get handle index field
    jclass proxyClass = jEnv->GetObjectClass(jProxyObj);
    jfieldID indexField = jEnv->GetFieldID(proxyClass, indexFieldName, "J");  //"J" is type signature for long
    dout << "indexField = " << indexField << endl    ;
    
    // set index field to given index
    jlong index_long = (long)index;
    jEnv->SetLongField(jProxyObj, indexField, index_long);
}


record_type_handle
mds::jni::get_record_type_handle(JNIEnv *jEnv, jobject jRecordTypeProxyObj)
{
    // get record type handle index
    size_t rt_index = 
        get_handle_index(jEnv, jRecordTypeProxyObj, "recordTypeHandle_");
    
    // get record type handle from handle store
    return handle_store<record_type_handle>::get(rt_index);
}


managed_record_handle
mds::jni::get_managed_record_handle(JNIEnv *jEnv, jobject jManagedRecordObj)
{
    // get managed record handle index
    size_t mr_index = 
        get_handle_index(jEnv, jManagedRecordObj, "managedRecordHandle_");

    // get managed record handle from handle store
    return handle_store<managed_record_handle>::get(mr_index);
}



void
mds::jni::set_managed_record_handle(JNIEnv *jEnv, 
        jobject jManagedRecordObj, managed_record_handle mr)
{
    size_t mr_index = handle_store<managed_record_handle>::store(mr);
    dout << "mr_index = " << mr_index << endl;

    set_handle_index(jEnv, jManagedRecordObj, "managedRecordHandle_", mr_index);
}


void
mds::jni::set_interned_string_handle(JNIEnv *jEnv,
	jobject jManagedStringObj, interned_string_handle is)
{
    size_t is_index = handle_store<interned_string_handle>::store(is);
    dout << "is_index = " << is_index << endl;

    set_handle_index(jEnv, jManagedStringObj, "internedStringHandle_", is_index);
}


void
mds::jni::throwUnboundNameEx(JNIEnv *env) {
  static java_ex jex(env,"com/hpl/mds/UnboundNameException");
  jex.raise(env);
  //  std::cout << "Raised UnboundNameException: " << res << std::endl;
  //  std::cout << "Pending exception: " << env->ExceptionOccurred() << std::endl;
}

void
mds::jni::exception_converter(JNIEnv *jEnv){
  try
    {
      throw;
    }
  catch (core::unbound_name_ex &)
    {
      throwUnboundNameEx (jEnv);
    }
  catch (core::incompatible_type_ex &)
    {
      throwIncompatibleTypeEx (jEnv);
    }
  catch (core::incompatible_record_type_ex &)
    {
      throwIncompatibleRecordTypeEx (jEnv);
    }
  catch (core::incompatible_superclass_ex &)
    {
      throwIncompatibleSuperClassEx (jEnv);
    }
  catch (core::unmodifiable_record_type_ex &)
    {
      throwUnmodifiableRecordTypeEx (jEnv);
    }
  catch (core::read_only_context_ex &)
    {
      throwReadOnlyContextEx (jEnv);
    }
  catch (core::unpublishable_context_ex &)
    {
      throwUnpublishableContextEx (jEnv);
    }
  catch (core::unimplemented &)
    {
      throwUnimplementedEx (jEnv);
    }
  catch (core::thread_base_task_unset_ex &)
    {
      throwUnknownEx (jEnv, "Core base task not set");
    }
  catch (...)
    {
      // throwUnknownEx (jEnv);
    }
}

void
mds::jni::throwIncompatibleTypeEx(JNIEnv *env) {
  static java_ex jex(env,"com/hpl/mds/IncompatibleTypeException");
  jex.raise(env);
}

void
mds::jni::throwIncompatibleRecordTypeEx(JNIEnv *env) {
  static java_ex jex(env,"com/hpl/mds/IncompatibleRecordTypeException");
  jex.raise(env);
}

void
mds::jni::throwIncompatibleSuperClassEx(JNIEnv *env) {
  static java_ex jex(env,"com/hpl/mds/IncompatibleSupertypeException");
  jex.raise(env);
}

void
mds::jni::throwUnmodifiableRecordTypeEx(JNIEnv *env) {
  static java_ex jex(env,"com/hpl/mds/UnmodifiableRecordTypeException");
  jex.raise(env);
}

void
mds::jni::throwReadOnlyContextEx(JNIEnv *env) {
  static java_ex jex(env,"com/hpl/mds/ReadOnlyContextException");
  jex.raise(env);
}

void
mds::jni::throwUnpublishableContextEx(JNIEnv *env) {
  static java_ex jex(env,"com/hpl/mds/UnpublishableContextException");
  jex.raise(env);
}

void
mds::jni::throwUnimplementedEx(JNIEnv *env) {
  static java_ex jex(env,"com/hpl/mds/UnimplementedException");
  jex.raise(env);
}

void
mds::jni::throwUnknownEx(JNIEnv *env) {
  static java_ex jex(env,"com/hpl/mds/InternalException");
  jex.raise(env);
}

void
mds::jni::throwUnknownEx(JNIEnv *env, const std::string &desc) {
  static java_ex jex(env,"com/hpl/mds/InternalException",
                     "(Ljava/lang/String;)V");
  jstring msg = env->NewStringUTF(desc.data());
  jex.raise(env, msg);
}

void
mds::jni::stubNotImplemented(JNIEnv *env) {
  static jclass c = find_class(env, "com/hpl/mds/impl/Stub");
  if (c == nullptr) {
    return; // exception thrown
  }
  static jmethodID m = find_static_method(env, c, "notImplemented", "()V");
  if (m == nullptr) {
    return; // exception thrown
  }
  env->CallStaticObjectMethod(c, m);
}


void
mds::jni::initialize_thread(JNIEnv *env) {
  static jclass taskImplClass = find_class(env, "com/hpl/mds/impl/TaskProxy");
  if (taskImplClass == nullptr) {
    return; // exception thrown
  }
  static jmethodID setBaseTaskMethod =
    find_static_method(env, taskImplClass, "current", "()Lcom/hpl/mds/impl/TaskProxy;");
  if (setBaseTaskMethod == nullptr) {
    return; // exception thrown
  }
  static jmethodID getHandleMethod = find_method(env, taskImplClass, "getHandle", "()J");
  if (getHandleMethod == nullptr) {
    return; // exception thrown
  }

  task_handle::init_thread_base_task([&]() {
      jobject jt = env->CallStaticObjectMethod(taskImplClass, setBaseTaskMethod);
      long h = env->CallLongMethod(jt, getHandleMethod);
      indexed<task_handle> t{h};
      return t->pointer();
    });
}
