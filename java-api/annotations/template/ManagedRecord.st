/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

ManagedRecord(
	pkg, 
	simple_name, 
	type_name,
        fq_name,
	parent,
	superInterfaces, 
	fields,
	declaredFields,
	protectedFields,
	privateFields,
	publicFields,
        constructingMethods,
	privateMethods,
	protectedMethods,
	publicMethods,
        methodImpls,
	userConstructors,
	creationMethodsImpl,
	publicCreationMethods,
	protectedCreationMethods,
	privateCreationMethods, 
	implModifier,
	publicStaticMethods,
	protectedStaticMethods,
	privateStaticMethods,
	ambiguousMethods,
        finalFields,
        superInitMethods) ::= <<
$if(pkg)$package $pkg$;$endif$

/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */
 
public interface $simple_name$ extends $if(parent)$$parent$$else$com.hpl.mds.ManagedRecord$endif$ $superInterfaces:{s |, $s$}$ {
	interface TypeDef {
		static final com.hpl.mds.RecordType<$simple_name$> TYPE
			= com.hpl.mds.RecordType.declare("$type_name$", Impl.class$if(parent)$, $parent$.TypeDef.TYPE$endif$);
		// field creation
		$fields$
		
		static final boolean created = TypeDef.TYPE.ensureCreated();
	}

	interface SMDefs $if(parent)$extends $parent$.SMDefs$endif$ {
		// public static method and field accessors declarations
		$publicStaticMethods$
		
		interface AsProtected extends SMDefs $if(parent)$, $parent$.SMDefs.AsProtected$endif$ {
			// protected static method and field accessor declarations
			$protectedStaticMethods$
		}
		interface AsPrivate extends AsProtected {
			// public, protected, and private static method and field accessor defaults
			$privateStaticMethods$
		}
	}
	
	class StaticMethod$if(parent)$ extends $parent$.StaticMethod$endif$ implements SMDefs.AsPrivate {
                static final StaticMethod instance = new StaticMethod();
        // definitions for diamond-ambiguous methods
    }

	final class Statics {
		// static members and init blocks, in order
		$declaredFields$
	}

	final class Create {
		// static public creation methods
	}

	interface Creator {
		// public creation method declarations
		$publicCreationMethods$
		
		interface AsProtected extends Creator {
			$protectedCreationMethods$
			// public and protected creation method declarations
		}
		interface AsPrivate extends AsProtected {
			$privateCreationMethods$
			// public, protected, and private creation method declarations
		}
		default Creator as(com.hpl.mds.ManagedRecord self) {
			return this;
		}
		default Creator as(com.hpl.mds.ManagedRecord.StaticAccess self) {
			return this;
		}

		AsProtected as($simple_name$.Protected self);
		AsProtected as($simple_name$.SMDefs.AsProtected access);
		AsPrivate as($simple_name$.Private self);
		AsPrivate as($simple_name$.SMDefs.AsPrivate access);

		class Instance implements Creator.AsPrivate {
			// creation method definitions
			$creationMethodsImpl$

			public AsProtected as($simple_name$.Protected self) {
				return this;
			}
			public AsProtected as($simple_name$.SMDefs.AsProtected access) {
				return this;
			}
			public AsPrivate as($simple_name$.Private self) {
				return this;
			}
			public AsPrivate as($simple_name$.SMDefs.AsPrivate access) {
				return this;
			}
		}
	}

	// public constant copies
	// public fields and accessors
	// public static member accessors
	// public methods
	// public static methods
	// public creation methods
	
	$publicFields$
	
	$publicMethods$
	
	public com.hpl.mds.RecordType<? extends $simple_name$> type();
	
        $simple_name$.Impl __GET_IMPL();

        default $fq_name$__PrivateImpl __PRIVATE_$fq_name$() {
          return __GET_IMPL().__PRIVATE_$fq_name$();
        }

	static final com.hpl.mds.RecordType<$simple_name$> TYPE = TypeDef.TYPE;
	static final Creator create = new Creator.Instance();
	
	$simple_name$ bindName(com.hpl.mds.HName name);
	$simple_name$ bindName(CharSequence... segments);
	$simple_name$ bindName(com.hpl.mds.Namespace namespace, CharSequence name);
	$simple_name$ bindName(char sep, CharSequence... segments);
	$simple_name$ bindName(java.util.List<? extends CharSequence> segments);
	$simple_name$ bindName(char sep, java.util.List<? extends CharSequence> segments);

	default public $simple_name$ objAs(com.hpl.mds.ManagedRecord access) {
          return __GET_IMPL().objAs(access);
        }
	default public $simple_name$ objAs(com.hpl.mds.ManagedRecord.StaticAccess access) {
          return __GET_IMPL().objAs(access);
        }
	default public $simple_name$.Protected objAs($simple_name$.Protected access) {
          return __GET_IMPL().objAs(access);
        }
	default public $simple_name$.Protected objAs($simple_name$.SMDefs.AsProtected access) {
          return __GET_IMPL().objAs(access);
        }
	default public $simple_name$.Private objAs($simple_name$.Private access) {
          return __GET_IMPL().objAs(access);
        }
	default public $simple_name$.Private objAs($simple_name$.SMDefs.AsPrivate access) {
          return __GET_IMPL().objAs(access);
        }
	
	public static SMDefs classAs($simple_name$ access) {
                return StaticMethod.instance;
        }
	public static SMDefs classAs(com.hpl.mds.ManagedRecord.StaticAccess access) {
                return StaticMethod.instance;
        }
        public static SMDefs.AsProtected classAs($simple_name$.Protected access) {
                return StaticMethod.instance;
        }
        public static SMDefs.AsProtected classAs($simple_name$.SMDefs.AsProtected access) {
                return StaticMethod.instance;
        }
        public static SMDefs.AsPrivate classAs($simple_name$.Private access) {
                return StaticMethod.instance;
        }
        public static SMDefs.AsPrivate classAs($simple_name$.SMDefs.AsPrivate access) {
                return StaticMethod.instance;
        }

	interface Protected extends $simple_name$ $if(parent)$, $parent$.Protected $endif${
		// protected constant copies
		// protected fields and accessors
		// protected static member accessors
		// protected methods
		// protected static methods
		// protected creation methods
		
		$protectedFields$
		
		$protectedMethods$
		
		public com.hpl.mds.RecordType<? extends $simple_name$> type();
		
		$simple_name$ bindName(com.hpl.mds.HName name);
		$simple_name$ bindName(CharSequence... segments);
		$simple_name$ bindName(com.hpl.mds.Namespace namespace, CharSequence name);
		$simple_name$ bindName(char sep, CharSequence... segments);
		$simple_name$ bindName(java.util.List<? extends CharSequence> segments);
		$simple_name$ bindName(char sep, java.util.List<? extends CharSequence> segments);
	} 

	interface Private extends Protected {
		// private constant copies
		// private fields and accessors
		// private static member accessors
		// private methods and defaults for public, protected:
		// private static methods
		// private creation methods
		// subclass init methods
		// super init methods
		$privateFields$
		
		$privateMethods$
		
		$simple_name$ bindName(com.hpl.mds.HName name);
		$simple_name$ bindName(CharSequence... segments);
		$simple_name$ bindName(com.hpl.mds.Namespace namespace, CharSequence name);
		$simple_name$ bindName(char sep, CharSequence... segments);
		$simple_name$ bindName(java.util.List<? extends CharSequence> segments);
		$simple_name$ bindName(char sep, java.util.List<? extends CharSequence> segments);

		default public $simple_name$.Protected objAs($simple_name$.Protected access) {
			return this;
		}

		default public $simple_name$.Protected objAs($simple_name$.SMDefs.AsProtected access) {
			return this;
		}

		default public $simple_name$.Private objAs($simple_name$.Private access) {
			return this;
		}

		default public $simple_name$.Private objAs($simple_name$.SMDefs.AsPrivate access) {
			return this;
		}
	}

        interface MethodImpls extends Protected$if(parent)$, $parent$.MethodImpls $endif$ {
          // public and private method impls
          $methodImpls$
        }

        interface Constructing extends Private$if(parent)$, $parent$.Derived$endif$ {
          // constructor-visible methods
          $constructingMethods$
        }

        interface Derived extends $simple_name$ {
          // superInit methods
          $superInitMethods$
        }


        class $fq_name$__PrivateImpl extends com.hpl.mds.impl.ManagedRecordProxy implements Constructing {
                final $simple_name$.Impl _impl;
                public $simple_name$.Impl __GET_IMPL() {
                  return _impl;
                }
                public $fq_name$__PrivateImpl __PRIVATE_$fq_name$() {
                  return this;
                }

                // final fields
                $finalFields$

                $fq_name$__PrivateImpl($simple_name$.Impl impl) {
                  super(Secondary.SECONDARY, impl);
                  _impl = impl;
                }

		public com.hpl.mds.RecordType<? extends $simple_name$> type() {
			return _impl.type();
		}

                public String toString() {
                  return _impl.toString();
                }

                public int hashCode() {
                  return _impl.hashCode();
                }

                public boolean equals(Object other) {
                  return _impl.equals(other);
                }
		
		public $packageFormat(pkg)$$simple_name$.Impl bindName(com.hpl.mds.HName name) {
			return _impl.bindName(name);
		}
		public $packageFormat(pkg)$$simple_name$.Impl bindName(CharSequence... segments) {
			return _impl.bindName(segments);
		}
		public $packageFormat(pkg)$$simple_name$.Impl bindName(com.hpl.mds.Namespace namespace, CharSequence name) {
                        return _impl.bindName(namespace, name);
                }
		public $packageFormat(pkg)$$simple_name$.Impl bindName(char sep, CharSequence... segments) {
			return _impl.bindName(sep, segments);
		}
		public $packageFormat(pkg)$$simple_name$.Impl bindName(java.util.List<? extends CharSequence> segments) {
			return _impl.bindName(segments);
		}
		public $packageFormat(pkg)$$simple_name$.Impl bindName(char sep, java.util.List<? extends CharSequence> segments) {
			return _impl.bindName(sep, segments);
		}

		public $simple_name$ objAs(com.hpl.mds.ManagedRecord access) {
			return this;
		}
		public $simple_name$ objAs(com.hpl.mds.ManagedRecord.StaticAccess access) {
			return this;
		}

		public $simple_name$.Protected objAs($simple_name$.Protected access) {
			return this;
		}

		public $simple_name$.Protected objAs($simple_name$.SMDefs.AsProtected access) {
			return this;
		}

		public $simple_name$.Private objAs($simple_name$.Private access) {
			return this;
		}

		public $simple_name$.Private objAs($simple_name$.SMDefs.AsPrivate access) {
			return this;
		}
        }

	$implModifier$ class Impl extends $if(parent)$$parent$.Impl$else$com.hpl.mds.impl.ManagedRecordProxy$endif$ implements MethodImpls {
                final $fq_name$__PrivateImpl _privateImpl;

                public $simple_name$.Impl __GET_IMPL() {
                  return this;
                }

                public final $fq_name$__PrivateImpl __PRIVATE_$fq_name$() {
                  return _privateImpl;
                }
        
		public Impl(com.hpl.mds.RecordType<? extends $simple_name$> type) {
			super(type);
                        _privateImpl = new $fq_name$__PrivateImpl(this);
		}
		public Impl(FromHandle fh, long handle,
					com.hpl.mds.RecordType<? extends $simple_name$> type) {
			super(fh, handle, type);
                        _privateImpl = new $fq_name$__PrivateImpl(this);
		}
		public Impl(FromHandle fh, long handle) {
			this(fh, handle, $simple_name$.TYPE);
		}
	
		// user-defined constructors
		$userConstructors$

		// definitions for diamond-ambiguous methods
                $ambiguousMethods$

		public com.hpl.mds.RecordType<? extends $simple_name$> type() {
			return typeOf(this);
		}
		
		public $packageFormat(pkg)$$simple_name$.Impl bindName(com.hpl.mds.HName name) {
			return name.bind(this);
		}
		public $packageFormat(pkg)$$simple_name$.Impl bindName(CharSequence... segments) {
			return bindName(com.hpl.mds.HName.from(segments));
		}
		public $packageFormat(pkg)$$simple_name$.Impl bindName(com.hpl.mds.Namespace namespace, CharSequence name) {
            return namespace.bind(name, this);
        }
		public $packageFormat(pkg)$$simple_name$.Impl bindName(char sep, CharSequence... segments) {
			return bindName(com.hpl.mds.HName.from(sep, segments));
		}
		public $packageFormat(pkg)$$simple_name$.Impl bindName(java.util.List<? extends CharSequence> segments) {
			return bindName(com.hpl.mds.HName.from(segments));
		}
		public $packageFormat(pkg)$$simple_name$.Impl bindName(char sep, java.util.List<? extends CharSequence> segments) {
			return bindName(com.hpl.mds.HName.from(sep, segments));
		}

		public $simple_name$ objAs(com.hpl.mds.ManagedRecord access) {
			return _privateImpl;
		}
		public $simple_name$ objAs(com.hpl.mds.ManagedRecord.StaticAccess access) {
			return _privateImpl;
		}

		public $simple_name$.Protected objAs($simple_name$.Protected access) {
			return _privateImpl;
		}

		public $simple_name$.Protected objAs($simple_name$.SMDefs.AsProtected access) {
			return _privateImpl;
		}

		public $simple_name$.Private objAs($simple_name$.Private access) {
			return _privateImpl;
		}

		public $simple_name$.Private objAs($simple_name$.SMDefs.AsPrivate access) {
			return _privateImpl;
		}
	}
}
>>
