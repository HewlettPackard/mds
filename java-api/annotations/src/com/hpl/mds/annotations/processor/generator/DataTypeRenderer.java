/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processor.generator;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.function.Function;

import com.hpl.mds.annotations.processor.RecordInfo.DataType;
import com.hpl.mds.annotations.processor.RecordInfo.ParameterType;
import com.hpl.mds.annotations.processor.generator.TypeProp.Properties;

/**
 * Generates the code related to data types
 * 
 * @author Abraham Alcantara
 */
public class DataTypeRenderer {

    /**
     * Generates source code of a type with parameters, for example:
     * List&lt;Integer&gt;
     * 
     * @param typeName
     *            the main data type
     * @param params
     *            the list of data types that are used as parameters
     * @return source code rendered
     */
    public String renderTypeWithParams(final String typeName, List<ParameterType> params) {
      return renderTypeWithParameters(typeName, getTypes(params));
    }

    /**
     * @param type
     *            the type name
     * @param parameterTypes
     *            the list of data type names that are used as parameters
     * @return the source code render of the data type including its parameters
     */
    public String renderTypeWithParameters(String type, List<String> parameterTypes) {
      if (parameterTypes.isEmpty()) {
        return type;
      }
      return type+"<"+String.join(",", parameterTypes)+">";
    }

    /**
     * Transforms a list of {@link DataType} to a list of their corresponding
     * managed data types
     * 
     * @param parameterTypes
     *            parameter data types of the collection
     * @return the simple names of the managed data types
     */
  public List<String> getTypes(List<ParameterType> parameterTypes,
                               Function<Properties, Class<?>> classFn)
  {
    return parameterTypes.stream()
      .map(parameterType -> {
          String complexType = parameterType.getComplexType();
          if (complexType != null) {
            return complexType;
          } else {
            Class<?> class1 = classFn.apply(getProperties(parameterType.getType()));
            return class1.getCanonicalName();
          }
        })
      .collect(Collectors.toList());
  }

  public List<String> getTypes(List<ParameterType> parameterTypes) {
    return getTypes(parameterTypes, Properties::getMngType);
  }

    /**
     * @param dataType
     * @return the properties associated with the given {@link DataType}
     */
    public Properties getProperties(DataType dataType) {
        switch (dataType) {
        case BOOLEAN:
            return TypeProp.BOOLEAN;
        case BYTE:
            return TypeProp.BYTE;
        case DOUBLE:
            return TypeProp.DOUBLE;
        case FLOAT:
            return TypeProp.FLOAT;
        case INT:
            return TypeProp.INT;
        case LONG:
            return TypeProp.LONG;
        case SHORT:
            return TypeProp.SHORT;
        case STRING:
            return TypeProp.STRING;
        case LIST:
            return TypeProp.LIST;
        case MAP:
            return TypeProp.MAP;
        case SET:
            return TypeProp.SET;
        case RECORD:
            return TypeProp.RECORD;
        case ARRAY:
            return TypeProp.ARRAY_GENERIC;
        default:
            throw new IllegalStateException("Unsupported data type: " + dataType);
        }
    }

    /**
     * @param dataType
     *            data type parameter of the array
     * @return {@link Properties} related to the non-generic array data type,
     *         null if not supported
     */
    public Properties getArrayProperties(DataType dataType) {
        if (dataType == null) {
            return null;
        }
        switch (dataType) {
        case BOOLEAN:
            return TypeProp.ARRAY_BOOLEAN;
        case BYTE:
            return TypeProp.ARRAY_BYTE;
        case DOUBLE:
            return TypeProp.ARRAY_DOUBLE;
        case FLOAT:
            return TypeProp.ARRAY_FLOAT;
        case INT:
            return TypeProp.ARRAY_INT;
        case LONG:
            return TypeProp.ARRAY_LONG;
        case SHORT:
            return TypeProp.ARRAY_SHORT;
        case STRING:
            return TypeProp.ARRAY_STRING;
        default:
            return null;
        }
    }

}
