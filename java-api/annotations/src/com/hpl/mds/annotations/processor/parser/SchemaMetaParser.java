/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processor.parser;

import java.io.IOException;
import java.util.HashSet;
import java.util.IllegalFormatException;
import java.util.List;
import java.util.Set;

import javax.annotation.processing.Messager;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Types;
import javax.tools.Diagnostic.Kind;

import com.hpl.mds.annotations.RecordSchema;

/**
 * Parser for schemas' metadata, including parents, paradigms and name.
 * 
 * @author Abraham Alcantara
 */
public class SchemaMetaParser {

    private static final String SCHEMA_SUFFIX = "Schema";
    private static final String PKG_DELIMITER = ".";

    /*
     * names that cannot be used for managed records
     */
    private static final Set<String> RESERVED_NAMES;

    static {
        RESERVED_NAMES = new HashSet<>();
        RESERVED_NAMES.add("TypeDef");
        RESERVED_NAMES.add("SMDefs");
        RESERVED_NAMES.add("AsProtected");
        RESERVED_NAMES.add("AsPrivate");
        RESERVED_NAMES.add("StaticMethod");
        RESERVED_NAMES.add("Statics");
        RESERVED_NAMES.add("Create");
        RESERVED_NAMES.add("Creator");
        RESERVED_NAMES.add("Instance");
        RESERVED_NAMES.add("Protected");
        RESERVED_NAMES.add("Private");
        RESERVED_NAMES.add("Impl");
    }

    /**
     * To display localized messages to the user
     */
    private final Messager messager;

    /**
     * Data types utility to find super types of a schema
     */
    private final Types typeUtil;

    /**
     * 
     * @param messager
     *            To display localized messages to the user
     * @param typeUtil
     *            Data types utility to find super types of a schema
     */
    public SchemaMetaParser(Messager messager, Types typeUtil) {
        this.messager = messager;
        this.typeUtil = typeUtil;
    }

    /**
     * @param schema
     * @return the parent name of the given schema
     */
    public String parseParentSchema(Element schema) {
        List<? extends TypeMirror> directSupertypes = typeUtil.directSupertypes(schema.asType());
        for (TypeMirror typeMirror : directSupertypes) {
            if ("java.lang.Object".equals(typeMirror.toString())) {
                continue;
            }
            Element element = typeUtil.asElement(typeMirror);
            if (element.getAnnotation(RecordSchema.class) != null) {
                return element.toString();
            } else {
                messager.printMessage(Kind.WARNING, "non-record-schema type: " + typeMirror.toString(), schema);
            }
        }
        return null;
    }

    /**
     * Generates the interface name from the given schema
     * 
     * @param schema
     *            schema element to parse
     * @param recordNames
     *            to store the class names for the new record
     * @param log
     *            to log error messages
     * @throws IOException
     */
    public void parseRecordName(List<String> recordNames, Element schema, StringBuilder log) {
        if (invalidRecordSchema(schema, log)) {
            return;
        }
        String schemaName = ((TypeElement) schema).getQualifiedName().toString();
        // Verify nested type
        String notNestedRecord = parseNotNestedRecordName(schema, schemaName, log);
        String defaultRecordName = parseDefaultRecordName(schema, notNestedRecord, log);
        final String formattedName = formatRecordName(schema, defaultRecordName, log);
        // we add formatted first, so it by tried first
        if (isValidRecordName(schemaName, formattedName, log) && !formattedName.equals(defaultRecordName)) {
            recordNames.add(formattedName);
        }
        // default name should be second
        if (isValidRecordName(schemaName, defaultRecordName, log)) {
            recordNames.add(defaultRecordName);
        }
    }

    /**
     * Validates a record name
     * 
     * @param schemaName
     *            schema name of the record
     * @param recordName
     *            name to validate
     * @param log
     *            for error messages
     * @return true if the given record name is valid, false otherwise
     */
    private boolean isValidRecordName(String schemaName, String recordName, StringBuilder log) {
        if (schemaName.equals(recordName)) {
            log.append("Illegal record name, is equals to the schema\n");
            return false;
        }
        int lastIndexOf = recordName.lastIndexOf(PKG_DELIMITER);
        if (lastIndexOf > 0 && recordName.length() > lastIndexOf + 1
                && RESERVED_NAMES.contains(recordName.substring(lastIndexOf + 1))) {
            log.append("Illegal record name: " + recordName + ", name is recerved\n");
            return false;
        }
        return true;
    }

    /**
     * @param schema
     *            schema element to parse
     * @param defaultRecordName
     *            default qualified name of the record
     * @param log
     *            to log error messages
     * @return formatted record name or default if no or invalid format
     */
    private String formatRecordName(Element schema, String defaultRecordName, StringBuilder log) {
        String format = schema.getAnnotation(RecordSchema.class).name().trim();
        assert format != null;
        if (format.isEmpty()) {
            return defaultRecordName;
        } else {
            try {
                return String.format(format, defaultRecordName);
            } catch (IllegalFormatException e) {
                log.append("Invalid format for record name: ").append(format).append(" - ").append(e.getMessage())
                        .append("\n");
                return defaultRecordName;
            }
        }
    }

    /**
     * @param schema
     *            schema element to parse
     * @param schemaName
     *            the schema's qualified name
     * @param log
     *            to log error messages
     * @return default qualified name of the record
     * @throws IOException
     */
    private String parseDefaultRecordName(Element schema, String schemaName, StringBuilder log) {
        String schemaSimpleName = schema.getSimpleName().toString();
        // interface name should have a "Schema" suffix
        if (!schemaSimpleName.endsWith(SCHEMA_SUFFIX)) {
            log.append("Schema interface without \"").append(SCHEMA_SUFFIX).append("\" suffix: ")
                    .append(schemaSimpleName).append("\n");
            return schemaName;
        } else {
            return schemaName.substring(0, schemaName.length() - SCHEMA_SUFFIX.length());
        }
    }

    /**
     * @param schema
     *            schema element to parse
     * @param schemaName
     *            the schema's qualified name
     * @param log
     *            to log error messages
     * @return qualified name of the record without parent types
     */
    private String parseNotNestedRecordName(Element schema, String schemaName, StringBuilder log) {
        if (schema.getEnclosingElement().getKind() != ElementKind.PACKAGE) {
            log.append("Nested record schemas are not supported, parent type: ")
                    .append(schema.getEnclosingElement().getKind().toString()).append("\n");
            return getPkg(schema) + PKG_DELIMITER + schema.getSimpleName();
        }
        return schemaName;
    }

    /**
     * Recursively retrieves the package of the given element
     * 
     * @param element
     *            element to parse
     * @return the package name of the element
     */
    private String getPkg(Element element) {
        Element enclosingElement = element.getEnclosingElement();
        if (enclosingElement.getKind() == ElementKind.PACKAGE) {
            return enclosingElement.toString();
        }
        return getPkg(enclosingElement);
    }

    /**
     * Validates the given schema
     * 
     * @param schema
     *            schema element to validate
     * @param log
     *            to log error messages
     * @return true if the element is valid
     */
    private boolean invalidRecordSchema(Element schema, StringBuilder log) {
        // Verify is an interface
        if (schema.getKind() != ElementKind.INTERFACE) {
            log.append("only interfaces can be annotated with ").append(RecordSchema.class.getSimpleName());
            return true;
        }
        return false;
    }

}
