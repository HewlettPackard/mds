/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processor;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.LogManager;
import java.util.logging.Logger;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;
import javax.tools.Diagnostic.Kind;
import javax.tools.JavaFileObject;

import com.hpl.mds.annotations.RecordSchema;
import com.hpl.mds.annotations.processor.generator.RecordGenerator;
import com.hpl.mds.annotations.processor.parser.GetterNameParser;
import com.hpl.mds.annotations.processor.parser.SchemaMetaParser;
import com.hpl.mds.annotations.processor.parser.SchemaParser;
import com.hpl.mds.annotations.processor.parser.VisibilitiesParser;

/**
 * Main entry point for MDS annotation processing, accepting all classes
 * annotated as RecordSchemas
 * 
 * @author Abraham Alcantara
 */
@SupportedSourceVersion(SourceVersion.RELEASE_8)
@SupportedAnnotationTypes({ "com.hpl.mds.annotations.RecordSchema" })
public class AnnotationProcessor extends AbstractProcessor {

    static {
        // disabling all log messages
        LogManager.getLogManager().reset();
    }

    /**
     * Stores information related to a RecordSchema
     * 
     * @author Abraham Alcantara
     */
    private static class SchemaInfo {

        /**
         * file reference to store the generated managed record
         */
        private JavaFileObject javaFileObject;

        /**
         * fully qualified name of the schema class
         */
        private String schema;

        /**
         * fully qualified name of the managed record class
         */
        private String recordName;

        /**
         * 
         * @param javaFileObject
         *            file reference to store the generated managed record
         * @param schema
         *            fully qualified name of the schema class
         * @param recordName
         *            fully qualified name of the managed record class
         */
        public SchemaInfo(JavaFileObject javaFileObject, String schema, String recordName) {
            super();
            this.javaFileObject = javaFileObject;
            this.schema = schema;
            this.recordName = recordName;
        }

        /**
         * file reference to store the generated managed record
         */
        public JavaFileObject getJavaFileObject() {
            return javaFileObject;
        }

        /**
         * @return fully qualified name of the managed record class
         */
        public String getRecordName() {
            return recordName;
        }

        /**
         * @return fully qualified name of the schema class
         */
        public String getSchema() {
            return schema;
        }

    }

    /*
     * To log messages for debugging purposes
     */
    private static final Logger LOGGER = Logger.getLogger(AnnotationProcessor.class.getName());

    /**
     * Reference display localized messages to the end user
     */
    private Messager messager;

    /**
     * Reference to create source files
     */
    private Filer filer;

    /**
     * Reference to utilities for source code elements
     */
    private Elements elementUtils;

    /**
     * Reference to schemas parser
     */
    private SchemaParser schemaParser;

    /**
     * Reference to schema meta-parser
     */
    private SchemaMetaParser metaParser;

    /**
     * Reference to code generator for managed records
     */
    private RecordGenerator recordGenerator;

    /**
     * Stores all the information related to the schemas received from the
     * scanner, the information is used until the last round when the records
     * are generated.
     */
    private List<SchemaInfo> schemasInfo = new ArrayList<>();

    /**
     * Stores all class qualified names of the managed records corresponding
     * with the schemas received from the scanner in all rounds.
     */
    private Set<String> managedRecords = new HashSet<>();

    /**
     * Mapping of schema class qualified name to its corresponding information,
     * only for parent schemas.
     */
    private Map<String, SchemaInfo> parentsSchemaInfo = new HashMap<>();

    /**
     * Mapping of schema class qualified name to its corresponding RecordInfo,
     * only for parent schemas. RecordInfo cache to avoid re-parsing of parent
     * schemas.
     */
    private Map<String, RecordInfo> parentsRecordInfo = new HashMap<>();

    /**
     * @see Processor#init(ProcessingEnvironment)
     */
    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        LOGGER.info("---------------------------------------------------------");
        super.init(processingEnv);
        messager = processingEnv.getMessager();
        filer = processingEnv.getFiler();
        elementUtils = processingEnv.getElementUtils();
        initParsers(processingEnv);
        recordGenerator = new RecordGenerator(messager);
    }

    /**
     * Initializes all parsers
     * 
     * @param processingEnv
     */
    private void initParsers(ProcessingEnvironment processingEnv) {
        GetterNameParser getterNameParser = new GetterNameParser(processingEnv.getMessager());
        VisibilitiesParser visibilitiesParser = new VisibilitiesParser(processingEnv.getMessager());
        schemaParser = new SchemaParser(processingEnv.getMessager(), processingEnv.getElementUtils(),
                processingEnv.getTypeUtils(), visibilitiesParser, getterNameParser, managedRecords);
        metaParser = new SchemaMetaParser(processingEnv.getMessager(),
                                          processingEnv.getTypeUtils(),
                                          processingEnv.getElementUtils());
    }

    /**
     * @see Processor#process(Set, RoundEnvironment)
     */
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // retrieve all record schemas
        Set<? extends Element> schemas = roundEnv.getElementsAnnotatedWith(RecordSchema.class);

        // fix for eclipse failing to refresh
        if (recordGenerator.noTemplates()) {
            for (Element element : schemas) {
                messager.printMessage(Kind.WARNING, "Please refresh schema", element);
            }
            return true;
        }

        for (Element schema : schemas) {
            LOGGER.info("schema: " + schema.toString());
        }

        // process the schemas of this round
        createSchemaInfos(schemas);

        // The record generation is left to the last round, to know all schemas
        // first
        if (roundEnv.processingOver()) {
            generateManagedRecords();
        }

        LOGGER.info(">>> end of round >>>");
        return true;
    }

    /**
     * Extracts the information of the schemas
     * 
     * @param schemas
     *            schemas to process
     */
    private void createSchemaInfos(Collection<? extends Element> schemas) {
        Set<String> parents = new HashSet<>();

        for (Element schema : schemas) {

            // parse parent name
            String parent = metaParser.parseParentSchema(schema);
            if (parent != null) {
                parents.add(parent);
            }

            // create the corresponding schemaInfo
            SchemaInfo schemaInfo = createSchemaInfo(schema);
            if (schemaInfo != null) {
                schemasInfo.add(schemaInfo);
            }
        }

        addParentSchemaInfos(parents);
    }

    /**
     * adds the {@link SchemaInfo} of each of the parents
     * 
     * @param parents
     *            qualified names of the parent schemas
     */
    private void addParentSchemaInfos(Set<String> parents) {

        // first find existent schemaInfos of the parents
        for (SchemaInfo schemaInfo : schemasInfo) {
            String schemaName = schemaInfo.getSchema();
            if (parents.contains(schemaName)) {
                parentsSchemaInfo.put(schemaName, schemaInfo);
                parents.remove(schemaName);
            }
        }

        // create the schemaInfos for the ones left
        for (String parent : parents) {
            TypeElement parentSchema = elementUtils.getTypeElement(parent);
            SchemaInfo parentSchemaInfo = createSchemaInfo(parentSchema);
            if (parentSchemaInfo != null) {
                parentsSchemaInfo.put(parent, parentSchemaInfo);
            }
        }
    }

    /**
     * Generates the {@link SchemaInfo} of the given schema
     * 
     * @param schema
     *            the schema element to parse
     * @return {@link SchemaInfo}
     */
    private SchemaInfo createSchemaInfo(Element schema) {
        StringBuilder log = new StringBuilder();

        // parse possible record names
        List<String> recordNames = new ArrayList<>(2);
        metaParser.parseRecordName(recordNames, schema, log);

        // tries to create the file with the given names
        for (String recordName : recordNames) {
            JavaFileObject fileObject = createRecordSrcFile(log, recordName);
            if (fileObject != null) {
                displayLogError(schema, log);
                return new SchemaInfo(fileObject, schema.toString(), recordName);
            }
        }
        displayLogError(schema, log);
        return null;
    }

    /**
     * Displays the log message if existent in the given element
     * 
     * @param element
     *            element to display the log
     * @param log
     *            log message
     */
    private void displayLogError(Element element, StringBuilder log) {
        if (log.length() > 0) {
            log.append(". Ignoring Schema");
            messager.printMessage(Kind.ERROR, log.toString(), element);
        }
    }

    /**
     * @param log
     *            for error messages
     * @param recordName
     *            the desired qualified name of the record
     * @return the source file of the record, null in case of error
     */
    private JavaFileObject createRecordSrcFile(StringBuilder log, String recordName) {
        if (!managedRecords.add(recordName)) {
            log.append("record name already exists: ").append(recordName).append(" ");
            return null;
        }
        try {
            return filer.createSourceFile(recordName);
        } catch (IOException e) {
            log.append("illegal record name: ").append(e.getMessage()).append('\n');
            managedRecords.remove(recordName);
        }
        return null;
    }

    /**
     * Generates the managed records from the existent schemaInfos
     */
    private void generateManagedRecords() {
        for (SchemaInfo schemaInfo : schemasInfo) {

            // use the context to find the actual object of the schema
            TypeElement schema = elementUtils.getTypeElement(schemaInfo.getSchema());

            // Look for parent schemas
            RecordInfo parent = getParentRecordInfo(schema);

            // parse the schema and generate the corresponding RecordInfo object
            RecordInfo recordInfo = schemaParser.parse(schema, schemaInfo.getRecordName(), parent);

            // generate the managed record from the RecordInfo object
            generateManagedRecord(schemaInfo, schema, recordInfo);
            LOGGER.info("generating: " + schemaInfo.getRecordName());
        }
        schemasInfo.clear();
    }

    /**
     * @param schema
     * @return the parent's {@link RecordInfo} of the given schema
     */
    private RecordInfo getParentRecordInfo(Element schema) {

        String parentName = metaParser.parseParentSchema(schema);

        // return if no parent
        if (parentName == null) {
            return null;
        }

        // return the parent info if it has been parsed before
        RecordInfo parentRecordInfo = parentsRecordInfo.get(parentName);
        if (parentRecordInfo != null) {
            return parentRecordInfo;
        }

        // return with error if the parent don't have a schema
        SchemaInfo parentSchemaInfo = parentsSchemaInfo.get(parentName);
        if (parentSchemaInfo == null) {
            messager.printMessage(Kind.ERROR, "errors exists in parent schema: " + parentName, schema);
            return null;
        }

        // parse the parent schema
        Element parentSchema = elementUtils.getTypeElement(parentSchemaInfo.getSchema());
        RecordInfo grandParentRecordInfo = getParentRecordInfo(parentSchema);
        RecordInfo recordInfo = schemaParser.parse(parentSchema, parentSchemaInfo.getRecordName(),
                grandParentRecordInfo);
        parentsRecordInfo.put(parentName, recordInfo);
        return recordInfo;
    }

    /**
     * Generates the record information and the source file from the given
     * {@link SchemaInfo}
     * 
     * @param schemaInfo
     *            information of the schema
     * @param schema
     * @param recordInfo
     *            information of the record
     * @return {@link RecordInfo} with the parsed record information of the
     *         schema
     */
    private RecordInfo generateManagedRecord(SchemaInfo schemaInfo, Element schema, RecordInfo recordInfo) {
        // output file creation
        try (Writer writer = schemaInfo.getJavaFileObject().openWriter()) {
            recordGenerator.generate(writer, recordInfo);
            return recordInfo;
        } catch (Exception e) {
            LOGGER.severe(e.getMessage());
            messager.printMessage(Kind.ERROR, getExceptionMsg(e, schemaInfo.getRecordName()), schema);
        }
        return null;
    }

    /**
     * Transforms the {@link Exception} information to a format suited for the {@link Messager} 
     * @param e
     * @param recordName
     *            fully qualified name of the managed record
     * @return a {@link String} with the error message of the given
     *         {@link Exception}
     */
    private String getExceptionMsg(Exception e, String recordName) {
        StringBuilder sb = new StringBuilder();
        sb.append("Ignoring Schema, error while creating record: ");
        sb.append(recordName);
        sb.append('\n');
        String localizedMessage = e.getLocalizedMessage();
        if (localizedMessage != null) {
            sb.append(localizedMessage);
        }
        String message = e.getMessage();
        if (message != null) {
            sb.append(message);
        }
        Class<? extends Exception> class1 = e.getClass();
        if (class1 != null) {
            sb.append(" " + class1);
        }
        StackTraceElement[] stackTrace = e.getStackTrace();
        if (stackTrace != null) {
            for (StackTraceElement stackTraceElement : stackTrace) {
                sb.append('\n');
                sb.append(stackTraceElement);
                sb.append(" - ");
                sb.append(stackTraceElement.getLineNumber());
            }
        }
        return sb.toString();
    }

}
