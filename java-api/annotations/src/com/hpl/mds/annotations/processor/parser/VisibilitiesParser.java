/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processor.parser;

import java.lang.annotation.Annotation;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

import javax.annotation.processing.Messager;
import javax.lang.model.element.Element;
import javax.tools.Diagnostic.Kind;

import com.hpl.mds.annotations.Emitted;
import com.hpl.mds.annotations.No;
import com.hpl.mds.annotations.Private;
import com.hpl.mds.annotations.Protected;
import com.hpl.mds.annotations.Public;
import com.hpl.mds.annotations.processor.RecordInfo.Visibility;

/**
 * Parser of {@link Private}, {@link Protected} and {@link Private} annotations
 * in a record schema, identifies the visibility level of the different members
 * of a managed record according to the inherited annotations
 * 
 * @author Abraham Alcantara
 */
public class VisibilitiesParser {

    /**
     * To display localized messages to the user
     */
    private final Messager messager;

    /**
     * Default visibilities for all schemas
     */
    private final Map<Emitted, Visibility> defaultVisibilities = new HashMap<>();;

    /**
     * @param messager
     *            To display localized messages to the user
     */
    public VisibilitiesParser(Messager messager) {
        this.messager = messager;
        initDefaultVisibilities();
    }

    private void initDefaultVisibilities() {
        defaultVisibilities.put(Emitted.ALL, Visibility.PUBLIC);
        defaultVisibilities.put(Emitted.FIELD, Visibility.PROTECTED);
        populate(defaultVisibilities, Collections.emptyList(), Collections.emptyMap());
    }

    /**
     * @return The default visibilities of all schemas
     */
    public Map<Emitted, Visibility> getDefaultVisibilities() {
        return defaultVisibilities;
    }

    /**
     * @param element
     * @param emittedLevel
     * @return the annotated visibilities in the given element
     */
    public Map<Emitted, Visibility> parse(Element element, Emitted emittedLevel) {
        Map<Emitted, Visibility> visibilities = new HashMap<>();

        // parse each visibility annotation
        parserVisibilityValues(Public::value, element, Public.class, Visibility.PUBLIC, visibilities, emittedLevel);
        parserVisibilityValues(Protected::value, element, Protected.class, Visibility.PROTECTED, visibilities,
                emittedLevel);
        parserVisibilityValues(Private::value, element, Private.class, Visibility.PRIVATE, visibilities, emittedLevel);
        parserVisibilityValues(No::value, element, No.class, Visibility.NO, visibilities, emittedLevel);

        return visibilities;
    }

    /**
     * Parses the visibility values of the annotations
     * 
     * @param parser
     *            parser which retrieves the values of the annotation
     * @param element
     *            element with the annotations
     * @param annotationType
     *            annotation type
     * @param visibility
     *            visibility associated with the given annotation
     * @param visibilities
     *            results of the parsing process
     * @param emittedLevel
     *            the current emitted level being parsed
     */
    private <A extends Annotation> void parserVisibilityValues(Function<A, Emitted[]> parser, Element element,
            Class<A> annotationType, Visibility visibility, Map<Emitted, Visibility> visibilities,
            Emitted emittedLevel) {
        A[] annotations = element.getAnnotationsByType(annotationType);
        Set<Emitted> invalids = visibility.getInvalids();
        for (A annotation : annotations) {
            Emitted[] emitteds = parser.apply(annotation);
            for (Emitted emitted : emitteds) {
                if (Emitted.DEFAULT.equals(emitted)) {
                    emitted = emittedLevel;
                }
                if (isValidVisibility(element, visibilities, invalids, annotation, emitted)) {
                    visibilities.put(emitted, visibility);
                }
            }
        }
    }

    /**
     * Verifies the visibility level
     * 
     * @param element
     *            element with the annotation
     * @param visibilities
     *            already set visibilities
     * @param invalids
     *            invalid values for the current visibility level
     * @param annotation
     *            annotation with the visibility value
     * @param emitted
     *            value to test
     * @return true if the visibility level is valid
     */
    private <A extends Annotation> boolean isValidVisibility(Element element, Map<Emitted, Visibility> visibilities,
            Set<Emitted> invalids, A annotation, Emitted emitted) {
        if (invalids.contains(emitted)) {
            messager.printMessage(Kind.ERROR, "Ignoring annotation. illegal visibility value: " + annotation, element);
            return false;
        } else if (visibilities.get(emitted) != null) {
            messager.printMessage(Kind.WARNING, "Ignoring annotation. Visibility value already set: " + emitted,
                    element);
            return false;
        }
        return true;
    }

    /**
     * Loads all visibility values, uses the given default values if not already
     * set.
     * 
     * @param visibilities
     *            to store visibility values
     * @param inheritedVisibilities
     *            visibilities of the parent element
     * @param defaultVisibilities
     *            default visibility values
     */
    public void populate(Map<Emitted, Visibility> visibilities, List<Map<Emitted, Visibility>> inheritedVisibilities,
            Map<Emitted, Visibility> defaultVisibilities) {
        setVisibilityRecursively(Emitted.ALL, visibilities, inheritedVisibilities, defaultVisibilities, null);
    }

    /**
     * Sets the visibility of the given element and all it's children as defined
     * in {@link Emitted}.
     * 
     * @param currentNode
     *            the current {@link Emitted} tree node
     * @param visibilities
     *            to store the visibilities
     * @param inheritedVisibilities
     *            visibilities of the parent element
     * @param defaultVisibilities
     *            default visibilities, that will be used if not set.
     * @param parentNodeVisibility
     *            {@link Visibility} value for the parent of the current node
     */
    private static void setVisibilityRecursively(Emitted currentNode, Map<Emitted, Visibility> visibilities,
            List<Map<Emitted, Visibility>> inheritedVisibilities, Map<Emitted, Visibility> defaultVisibilities,
            Visibility parentNodeVisibility) {

        // sets the visibility of current node
        Visibility currentNodeVisibility = setVisibility(currentNode, visibilities, inheritedVisibilities,
                defaultVisibilities, parentNodeVisibility);

        // sets visibilities of children nodes
        Emitted[] children = currentNode.getChildren();
        if (children != null) {
            for (Emitted childNode : children) {
                setVisibilityRecursively(childNode, visibilities, inheritedVisibilities, defaultVisibilities,
                        currentNodeVisibility);
            }
        }
    }

    /**
     * Sets the visibility for the given emitted value
     * 
     * @param currentNode
     *            emitted value to set its visibility
     * @param visibilities
     *            to set the required visibility
     * @param inheritedVisibilities
     *            visibilities of the parent element
     * @param defaultVisibilities
     *            default visibilities of the element
     * @param parentNodeVisibility
     *            {@link Visibility} value for the parent of the current node
     * @return the dominant {@link Visibility} value, null if default
     */
    private static Visibility setVisibility(Emitted currentNode, Map<Emitted, Visibility> visibilities,
            List<Map<Emitted, Visibility>> inheritedVisibilities, Map<Emitted, Visibility> defaultVisibilities,
            Visibility parentNodeVisibility) {

        // if this is already set
        Visibility visibility = visibilities.get(currentNode);
        if (visibility != null) {
            // nothing to do
            return visibility;
        }

        // if a dominant parent annotation exists
        if (parentNodeVisibility != null) {
            // set the parent as the new value
            visibilities.put(currentNode, parentNodeVisibility);
            return parentNodeVisibility;
        }

        // look for a dominant inherited annotation
        for (Map<Emitted, Visibility> inherited : inheritedVisibilities) {
            Visibility visibility3 = inherited.get(currentNode);
            if (visibility3 != null) {
                // set inherited value
                visibilities.put(currentNode, visibility3);
                return visibility3;
            }
        }

        // set the default value
        visibilities.put(currentNode, defaultVisibilities.get(currentNode));

        // no dominant value
        return null;
    }
}
