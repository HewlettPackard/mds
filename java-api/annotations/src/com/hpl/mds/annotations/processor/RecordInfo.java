/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processor;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.lang.model.element.ExecutableElement;

import com.hpl.mds.annotations.Emitted;

/**
 * The intermediate representation of a managed record. All information declared
 * in a schema and its paradigms is aggregated in an instance of this class, so
 * it can be used to generate a managed record
 * 
 * @author Abraham Alcantara
 */
public class RecordInfo {

    /**
     * Stores format for getter methods
     * 
     * @author Abraham Alcantara
     */
    public static class GetterFormatInfo {

        private String booleanFormat;
        private String nonBooleanFormat;

        public GetterFormatInfo(String booleanFormat, String nonBooleanFormat) {
            this.booleanFormat = booleanFormat;
            this.nonBooleanFormat = nonBooleanFormat;
        }

        public String getBooleanFormat() {
            return booleanFormat;
        }

        public String getNonBooleanFormat() {
            return nonBooleanFormat;
        }
    }

    /**
     * Data types representation
     * 
     * @author Abraham Alcantara
     */
    public static enum DataType {
        INT, BOOLEAN, BYTE, DOUBLE, FLOAT, LONG, SHORT, STRING, LIST, SET, MAP, RECORD, VOID, ARRAY;

        /**
         * true if a managed version of the data type is supported
         */
        private boolean twoVersions = false;

        /**
         * number of data type parameters required used for collection types,
         * for example: {@link List}&lt;Integer&gt;. -1 if no parameters are
         * required
         */
        private int requiredParams = -1;

        static {
            INT.twoVersions = true;
            BOOLEAN.twoVersions = true;
            BYTE.twoVersions = true;
            DOUBLE.twoVersions = true;
            FLOAT.twoVersions = true;
            LONG.twoVersions = true;
            SHORT.twoVersions = true;
            STRING.twoVersions = true;
            LIST.requiredParams = 1;
            SET.requiredParams = 1;
            MAP.requiredParams = 2;
        }

        /**
         * @return true if a managed version of the data type is supported,
         *         false otherwise
         */
        public boolean twoVersions() {
            return twoVersions;
        }

        /**
         * @return number of data type parameters required used for collection
         *         types, for example: {@link List}&lt;Integer&gt;. -1 if no
         *         parameters are required
         */
        public int getRequiredParams() {
            return requiredParams;
        }
    }

    /**
     * Data type represantation of a method parameter
     * 
     * @author Abraham Alcantara
     */
    public static class ParameterType {

        /**
         * Stores the equivalent data type if it exists
         */
        private DataType type;

        /**
         * Stores unknown data types as full qualified name of the class
         */
        private String complexType;

        public ParameterType(DataType type) {
            this.type = type;
        }

        public void setComplexType(String complexType) {
            this.complexType = complexType;
        }

        public String getComplexType() {
            return complexType;
        }

        public DataType getType() {
            return type;
        }
    }

  /**
   * Representation of a static final constant
   */
  public static class ConstantInfo {
    private String name;
    private String type;
    private Visibility visibility;

    public ConstantInfo(String name, String type, Visibility visibility) {
      this.name = name;
      this.type = type;
      this.visibility = visibility;
    }

    public String getName() {
      return name;
    }

    public String getType() {
      return type;
    }

    public Visibility getVisibility() {
      return visibility;
    }
  }
                        

    /**
     * Field representation of a managed record, stores all information related
     * to a field.
     * 
     * @author Abraham Alcantara
     */
    public static class FieldInfo {

        /**
         * Stores the information of the field as a variable
         */
        private VarInfo varInfo;

        /**
         * The corresponding name as found in the MDS
         */
        private String mdsName;

        /**
         * The format of the getter of this field
         */
        private String getterNameFormat;

      private boolean isFinal;

        // visibilities
        private Visibility fieldVisibility;
        private Visibility getterVisibility;
        private Visibility setterVisibility;
        private Visibility modifiersVisibility;
        private Visibility incVisibility;
        private Visibility decVisibility;
        private Visibility mulVisibility;
        private Visibility divVisibility;

      public FieldInfo(VarInfo varInfo, String mdsName, String getterNameFormat,
                       boolean isFinal)
      {
        this.varInfo = varInfo;
        this.mdsName = mdsName;
        this.getterNameFormat = getterNameFormat;
        this.isFinal = isFinal;
      }

      public FieldInfo(VarInfo varInfo) {
        this.varInfo = varInfo;
      }

        public void setFieldVisibility(Visibility fieldVisibility) {
            this.fieldVisibility = fieldVisibility;
        }

        public Visibility getFieldVisibility() {
            return fieldVisibility;
        }

        public void setGetterVisibility(Visibility getterVisibility) {
            this.getterVisibility = getterVisibility;
        }

        public Visibility getGetterVisibility() {
            return getterVisibility;
        }

        public void setSetterVisibility(Visibility setterVisibility) {
            this.setterVisibility = setterVisibility;
        }

        public Visibility getSetterVisibility() {
            return setterVisibility;
        }

        public void setDecVisibility(Visibility decVisibility) {
            this.decVisibility = decVisibility;
        }

        public Visibility getDecVisibility() {
            return decVisibility;
        }

        public void setIncVisibility(Visibility incVisibility) {
            this.incVisibility = incVisibility;
        }

        public Visibility getIncVisibility() {
            return incVisibility;
        }

        public void setMulVisibility(Visibility mulVisibility) {
            this.mulVisibility = mulVisibility;
        }

        public Visibility getMulVisibility() {
            return mulVisibility;
        }

        public void setDivVisibility(Visibility divVisibility) {
            this.divVisibility = divVisibility;
        }

        public Visibility getDivVisibility() {
            return divVisibility;
        }

        public void setModifiersVisibility(Visibility modifiersVisibility) {
            this.modifiersVisibility = modifiersVisibility;
        }

        public Visibility getModifiersVisibility() {
            return modifiersVisibility;
        }

      public boolean isFinal() {
        return isFinal;
      }

        /**
         * @return The corresponding name as found in the MDS
         */
        public String getMdsName() {
            return mdsName;
        }

        /**
         * @return Information of the field as a variable
         */
        public VarInfo getVarInfo() {
            return varInfo;
        }

        /**
         * @return The format of the getter of this field
         */
        public String getGetterNameFormat() {
            return getterNameFormat;
        }
    }

    /**
     * Stores the information of a variable
     * 
     * @author Abraham Alcantara
     */
    public static class VarInfo {

        /**
         * True if the element declaring the variable should be emitted twice,
         * with the two version of the data type, false otherwise
         */
        private boolean emittedTwice = false;

        /**
         * True if the variable was declared as managed
         */
        private boolean managed = false;

        /**
         * data type of the variable
         */
        private DataType type;

        /**
         * name of the variable
         */
        private String name;

        /**
         * full qualified name of the data type, in case of complex type
         */
        private String complexType;

        /**
         * data type parameters, used for collections
         */
        private List<ParameterType> typeParams = Collections.emptyList();

        /**
         * @return True if a {@link VarInfo} with the same data type, false
         *         otherwise
         */
        @Override
        public boolean equals(Object obj) {
            if (obj instanceof VarInfo) {
                VarInfo varInfo = (VarInfo) obj;
                if (complexType != null) {
                    return complexType.equals(varInfo.complexType);
                }
                if (type != null) {
                    return type.equals(varInfo.type);
                }
            }
            return false;
        }

        public VarInfo(String name) {
            this.name = name;
        }

        /**
         * @return name of the variable
         */
        public String getName() {
            return name;
        }

        public void setComplexType(String complexType) {
            this.complexType = complexType;
        }

        /**
         * @return full qualified name of the data type, in case of complex type
         */
        public String getComplexType() {
            return complexType;
        }

        public void setType(DataType type) {
            this.type = type;
        }

        /**
         * @return data type of the variable
         */
        public DataType getType() {
            return type;
        }

        public void setEmittedTwice() {
            this.emittedTwice = true;
        }

        /**
         * @return True if the element declaring the variable should be emitted
         *         twice, with the two version of the data type, false otherwise
         */
        public boolean isEmittedTwice() {
            return emittedTwice;
        }

        public void setManaged(boolean managed) {
            this.managed = managed;
        }

        /**
         * @return true if the variable was declared as managed, false otherwise
         */
        public boolean isManaged() {
            return managed;
        }

        public void setTypeParams(List<ParameterType> typeParams) {
            this.typeParams = typeParams;
        }

        /**
         * @return data type parameters, used for collections
         */
        public List<ParameterType> getTypeParams() {
            return typeParams;
        }
    }

    /**
     * Stores the information of a declared method for a managed record
     * 
     * @author Abraham Alcantara
     */
    public static class MethodInfo {

        /**
         * mane of the method
         */
        private String name;

        /**
         * parameters received by the method
         */
        private List<VarInfo> parameters;

        /**
         * method return value
         */
        private VarInfo returnType;

        /**
         * method visibility
         */
        private Visibility visibility;

        /**
         * true if the method was declared as abstract, false otherwise
         */
        private boolean abstract2;

        /**
         * true if the first parameter of this method was omitted and has to be
         * generated, false otherwise, only for static methods
         */
        private boolean omitFirstParam = false;

        /**
         * true if the parent managed record also has a method with the same
         * signature, false otherwise
         */
        private boolean ambiguous = false;

        /**
         * Reference to the original method is used only to localize error
         * messages
         */
        private ExecutableElement method;

        public void setName(String name) {
            this.name = name;
        }

        /**
         * @return mane of the method
         */
        public String getName() {
            return name;
        }

        public void setParameters(List<VarInfo> parameters) {
            this.parameters = parameters;
        }

        /**
         * @return parameters received by the method
         */
        public List<VarInfo> getParameters() {
            return parameters;
        }

        public void setReturnType(VarInfo returnType) {
            this.returnType = returnType;
        }

        /**
         * @return method return value
         */
        public VarInfo getReturnType() {
            return returnType;
        }

        public void setVisibility(Visibility visibility) {
            this.visibility = visibility;
        }

        /**
         * @return method visibility
         */
        public Visibility getVisibility() {
            return visibility;
        }

        public void setMethod(ExecutableElement method) {
            this.method = method;
        }

        public ExecutableElement getMethod() {
            return method;
        }

        public void setAbstract(boolean abstract2) {
            this.abstract2 = abstract2;
        }

        /**
         * @return true if the method was declared as abstract, false otherwise
         */
        public boolean isAbstract() {
            return abstract2;
        }

        public void setOmitFirstParam(boolean omitFirstParam) {
            this.omitFirstParam = omitFirstParam;
        }

        /**
         * @return true if the first parameter of this method was omitted and
         *         has to be generated, false otherwise, only for static methods
         */
        public boolean omitFirstParam() {
            return omitFirstParam;
        }

        public void setAmbiguous(boolean ambiguous) {
            this.ambiguous = ambiguous;
        }

        /**
         * @return true if the parent managed record also has a method with the
         *         same signature, false otherwise
         */
        public boolean isAmbiguous() {
            return ambiguous;
        }
    }

    /**
     * Representation of a visibility level
     * 
     * @author Abraham Alcantara
     */
    public static enum Visibility {

        PROTECTED, PRIVATE, PUBLIC, NO;

        /**
         * Invalid {@link Emitted} values for the visibility level
         */
        private Set<Emitted> invalids;

        static {
            PROTECTED.invalids = Collections.emptySet();
            PRIVATE.invalids = Collections.emptySet();
            PUBLIC.invalids = Collections.emptySet();
            NO.invalids = new HashSet<Emitted>(
                    Arrays.asList(Emitted.DEFAULT, Emitted.ALL, Emitted.FIELD, Emitted.FIELD_AND_ACCESSORS));
        }

        /**
         * @return Invalid {@link Emitted} values for the visibility level
         */
        public Set<Emitted> getInvalids() {
            return invalids;
        }

    }

    /**
     * fully qualified name of the schema
     */
    private String schema;
    private String pkg;
    private String simpleName;

    /**
     * MDS type name of new record
     */
    private String typeName;

    /**
     * fully qualified name of the parent record
     */
    private String parent;

    // methods and fields
    private List<String> superInterfaces = Collections.emptyList();
    private List<FieldInfo> fields = Collections.emptyList();
    private List<MethodInfo> methods = Collections.emptyList();
    private List<MethodInfo> userConstructor = Collections.emptyList();
    private List<MethodInfo> staticMethods = Collections.emptyList();
    private Set<String> fieldNames = Collections.emptySet();
  private List<ConstantInfo> constants = Collections.emptyList();

    /**
     * If this managed record was declared as abstract
     */
    private boolean abstract1;

    public String getPkg() {
        return pkg;
    }

    public void setPkg(String pkg) {
        this.pkg = pkg;
    }

    public String getSimpleName() {
        return simpleName;
    }

    public void setSimpleName(String simpleName) {
        this.simpleName = simpleName;
    }

  public String getFQName() {
    if (pkg == null || pkg.isEmpty()) {
      return simpleName;
    }
    return String.format("%s_%s", pkg.replace('.','_'), simpleName);
  }

    public String getTypeName() {
        return typeName;
    }

    public void setTypeName(String typeName) {
        this.typeName = typeName;
    }

    /**
     * @return fully qualified name of the parent record
     */
    public String getParent() {
        return parent;
    }

    public void setParent(String parent) {
        this.parent = parent;
    }

    public void addSuperInterface(String superInterface) {
        if (superInterfaces.isEmpty()) {
            superInterfaces = new ArrayList<>();
        }
        superInterfaces.add(superInterface);
    }

    public List<String> getSuperInterfaces() {
        return superInterfaces;
    }

    public List<FieldInfo> getFields() {
        return fields;
    }

    public void addField(FieldInfo fieldInfo) {
        if (fields.isEmpty()) {
            fields = new ArrayList<>();
        }
        fields.add(fieldInfo);
    }

    public List<ConstantInfo> getConstants() {
        return constants;
    }

    public void addConstant(ConstantInfo fieldInfo) {
        if (constants.isEmpty()) {
            constants = new ArrayList<>();
        }
        constants.add(fieldInfo);
    }

    public void addInstanceMethod(MethodInfo methodInfo) {
        if (methods.isEmpty()) {
            methods = new ArrayList<>();
        }
        methods.add(methodInfo);
    }

    public List<MethodInfo> getMethods() {
        return methods;
    }

    public void setSchema(String schema) {
        this.schema = schema;
    }

    /**
     * @return fully qualified name of the schema
     */
    public String getSchema() {
        return schema;
    }

    public void addUserConstructor(MethodInfo methodInfo) {
        if (userConstructor.isEmpty()) {
            userConstructor = new ArrayList<>();
        }
        userConstructor.add(methodInfo);
    }

    public List<MethodInfo> getUserConstructor() {
        return userConstructor;
    }

    public void setAbstract(boolean abstract1) {
        this.abstract1 = abstract1;
    }

    /**
     * @return true if this managed record was declared as abstract, false
     *         otherwise
     */
    public boolean isAbstract() {
        return abstract1;
    }

    public void addStaticMethod(MethodInfo methodInfo) {
        if (staticMethods.isEmpty()) {
            staticMethods = new ArrayList<>();
        }
        staticMethods.add(methodInfo);
    }

    public List<MethodInfo> getStaticMethods() {
        return staticMethods;
    }

    public Set<String> getFieldNames() {
        return fieldNames;
    }

    public void addFieldName(String fieldName) {
        if (fieldNames.isEmpty()) {
            fieldNames = new HashSet<>();
        }
        fieldNames.add(fieldName);
    }

}
