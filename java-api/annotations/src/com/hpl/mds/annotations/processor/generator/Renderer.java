	/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processor.generator;

import com.hpl.erk.util.CollUtils;
import com.hpl.erk.func.NullaryFunc;

import java.util.Collections;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import javax.annotation.processing.Messager;

import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STGroup;

import com.hpl.mds.annotations.processor.RecordInfo;
import com.hpl.mds.annotations.processor.RecordInfo.Visibility;

public abstract class Renderer {
  private final STGroup stGroup;
  private final ST recordTemplate;
  protected final String recordSimpleName;
  protected final RecordInfo recordInfo;
  protected final DataTypeRenderer dataTypeRenderer;
  protected final Messager messager;

  private List<String> privateMethods;
  private List<String> protectedMethods;
  private List<String> publicMethods;
  private List<String> constructingMethods;
  private List<String> methodImpls;
  private List<String> privateStaticMethods;
  private List<String> protectedStaticMethods;
  private List<String> publicStaticMethods;
  
  abstract public void render();
  abstract protected void addCodeToManagedRecord(ST recordTemplate);

  protected Renderer(RecordInfo recordInfo,
                     DataTypeRenderer dataTypeRenderer,
                     STGroup stGroup, ST recordTemplate,
                     Messager messager)
  {
    this.recordSimpleName = recordInfo.getSimpleName();
    this.recordInfo = recordInfo;
    this.dataTypeRenderer = dataTypeRenderer;
    this.stGroup = stGroup;
    this.recordTemplate = recordTemplate;
    this.messager = messager;
  }

  protected List<String> getList(List<String> list) {
    return CollUtils.maybeNullList(list);
  }

  private static NullaryFunc<ArrayList<String>> listAdder = CollUtils.<String>arrayListCreator();
  protected List<String> addTo(List<String> list, String val) {
    return CollUtils.addTo(list, val, listAdder);
  }

  protected void addCodeToManagedRecord() {
    addCodeToManagedRecord(recordTemplate);
  }
  
  protected String renderTemplate(ST template,
                                  Consumer<ST> argFunc)
  {
    if (argFunc != null) {
      argFunc.accept(template);
    }
    return template.render();
  }

  protected String renderTemplate(String name,
                                  Consumer<ST> argFunc)
  {
    ST template = stGroup.getInstanceOf(name);
    if (template == null) {
      return String.format("[No template '%s']", name);
      //      throw new RuntimeException(String.format("No template '%s'", name));
    }
    assert template != null;
    return renderTemplate(template, argFunc);
  }

  protected void addCode(Consumer<? super String> addFunc, String code) {
    addFunc.accept(code);
  }

  protected void addCode(Visibility vis, String code) {
    Consumer<String> addFunc = adder(vis);
    if (addFunc != null) {
      addCode(addFunc, code);
    }
  }

  protected void addCode(Visibility vis, String decl, String impl) {
    Consumer<String> addFunc = adder(vis);
    if (addFunc != null) {
      if (vis == Visibility.PRIVATE) {
        addCode(addFunc, impl);
      } else {
        addCode(addFunc, decl);
        addCode(this::addMethodImpl, impl);
      }
    }
  }
  
  protected void addConstructingMethod(String render) {
    constructingMethods = addTo(constructingMethods, render);
  }

  protected void addPrivateMethod(String render) {
    privateMethods = addTo(privateMethods, render);
  }

  protected void addProtectedMethod(String render) {
    protectedMethods = addTo(protectedMethods, render);
  }
  
  protected void addPublicMethod(String render) {
    publicMethods = addTo(publicMethods, render);
  }

  protected void addPrivateStaticMethod(String render) {
    privateStaticMethods = addTo(privateStaticMethods, render);
  }

  protected void addProtectedStaticMethod(String render) {
    protectedStaticMethods = addTo(protectedStaticMethods, render);
  }
  
  protected void addPublicStaticMethod(String render) {
    publicStaticMethods = addTo(publicStaticMethods, render);
  }

  protected void addMethodImpl(String render) {
    methodImpls = addTo(methodImpls, render);
  }

  public List<String> getPublicMethods() {
    return getList(publicMethods);
  }

  public List<String> getProtectedMethods() {
    return getList(protectedMethods);
  }

  public List<String> getPrivateMethods() {
    return getList(privateMethods);
  }

  public List<String> getPublicStaticMethods() {
    return getList(publicStaticMethods);
  }

  public List<String> getProtectedStaticMethods() {
    return getList(protectedStaticMethods);
  }

  public List<String> getPrivateStaticMethods() {
    return getList(privateStaticMethods);
  }

  public List<String> getConstructingMethods() {
    return getList(constructingMethods);
  }

  public List<String> getMethodImpls() {
    return getList(methodImpls);
  }

  protected Consumer<String> adder(Visibility vis) {
    switch (vis) {
    case NO:
      return null;
    case PUBLIC:
      return this::addPublicMethod;
    case PROTECTED:
      return this::addProtectedMethod;
    case PRIVATE:
      return this::addPrivateMethod;
    default:
      throw new IllegalStateException(String.format("Unsupported visibility type: %s", vis));
    }
  }
  protected Consumer<String> staticAdder(Visibility vis) {
    switch (vis) {
    case NO:
      return null;
    case PUBLIC:
      return this::addPublicStaticMethod;
    case PROTECTED:
      return this::addProtectedStaticMethod;
    case PRIVATE:
      return this::addPrivateStaticMethod;
    default:
      throw new IllegalStateException(String.format("Unsupported visibility type: %s", vis));
    }
  }
  
}
