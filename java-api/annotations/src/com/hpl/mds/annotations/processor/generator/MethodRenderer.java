/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processor.generator;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.tools.Diagnostic.Kind;
import javax.annotation.processing.Messager;

import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STGroup;

import com.hpl.mds.annotations.processor.RecordInfo;
import com.hpl.mds.annotations.processor.RecordInfo.DataType;
import com.hpl.mds.annotations.processor.RecordInfo.MethodInfo;
import com.hpl.mds.annotations.processor.RecordInfo.VarInfo;
import com.hpl.mds.annotations.processor.RecordInfo.Visibility;
import com.hpl.mds.annotations.processor.generator.TypeProp.Properties;

/**
 * Generates all source code related to methods in managed records including
 * instance methods, static methods, constructors and creation methods
 * 
 * @author Abraham Alcantara
 */
public class MethodRenderer extends Renderer {

    /**
     * Renders a method at the required visibility level
     * 
     * @param parameters
     *            parameters of the method
     * @param arguments
     *            arguments for the call to the schema method
     * @param renders
     *            the render of the elements: method name, return type and cast
     *            operations before and after schema method invocation
     * @param methodInfo
     *            information of the method to render
     * 
     * @author Abraham Alcantara
     */
    private interface Renderer {
        void render(String parameters,
                    String[] paramNames,
                    List<String> arguments, String[] renders, MethodInfo methodInfo);
    }

    private static final String VOID = "void";
    private static final String EMPTY = "";
    private static final char SIGNATURE_SEPARATOR = '#';
    private static final String PRIVATE = "Private";
    private static final String PROTECTED = "Protected";
    private static final String RETURN = "return ";

    private static final String ERROR_METHODS_SIGNATURE = "A method with the same signature has already been generated";

    private static final String TEMPLATE_METHOD_IMPL = "methodImplementation";
    private static final String TEMPLATE_METHOD_DECLARATION = "methodDeclaration";
    private static final String TEMPLATE_USER_CONSTRUCTOR = "userConstructor";
    private static final String TEMPLATE_DEFAULT_CONSTRUCTOR = "defaultConstructor";
    private static final String TEMPLATE_CREATION_METHOD_IMPL = "creationMethodImpl";
    private static final String TEMPLATE_CREATION_METHOD_DEC = "creationMethodDec";
    private static final String TEMPLATE_AMBIGUOUS_METHOD = "ambiguousMethod";
    private static final String TEMPLATE_STATIC_METHOD = "staticMethod";
    private static final String TEMPLATE_STATIC_METHOD_DECLARATION = "staticMethodDeclaration";
    private static final String TEMPLATE_SUPER_INIT_METHOD = "superInitMethod";
    private static final String TEMPLATE_DEFAULT_SUPER_INIT_METHOD = "defaultSuperInitMethod";
    private static final String TEMPLATE_THIS_INIT_METHOD = "thisInitMethod";

    private static final int PRIM = 0;
    private static final int MNG = 1;
    private static final int METHOD_NAME = 0;
    private static final int RETURN_TYPE = 1;
    private static final int CAST_START = 2;
    private static final int CAST_END = 3;


    /*
     * All rendered methods
     */
  private List<String> userConstructors;
  private List<String> creationMethodsImpl;
  private List<String> publicCreationMethods;
  private List<String> protectedCreationMethods;
  private List<String> privateCreationMethods;
  private List<String> ambiguousMethods;
  private List<String> superInitMethods;

    /**
     * 
     * @param messager
     *            to display error messages to the user
     * @param dataTypeRenderer
     *            render for data types
     * @param recordInfo
     *            information of the managed record to render
     * @param stGroup
     *            string template group
     * @param recordTemplate
     *            string template for a managed record
     */
    public MethodRenderer(Messager messager, DataTypeRenderer dataTypeRenderer, RecordInfo recordInfo, STGroup stGroup,
            ST recordTemplate) {
      super(recordInfo, dataTypeRenderer, stGroup, recordTemplate, messager);
    }

    private void addUserConstructor(String render) {
      userConstructors = addTo(userConstructors, render);
    }

    private void addCreationMethodsImpl(String render) {
      creationMethodsImpl = addTo(creationMethodsImpl, render);
    }

    private void addPublicCreationMethod(String render) {
      publicCreationMethods = addTo(publicCreationMethods, render);
    }

    private void addProtectedCreationMethod(String render) {
      protectedCreationMethods = addTo(protectedCreationMethods, render);
    }

    private void addPrivateCreationMethod(String render) {
      privateCreationMethods = addTo(privateCreationMethods, render);
    }

    private void addAmbiguousMethod(String render) {
      ambiguousMethods = addTo(ambiguousMethods, render);
    }

    private void addSuperInitMethod(String render) {
      superInitMethods = addTo(superInitMethods, render);
    }

    /**
     * Renders all instance methods, constructors and creation methods
     */
  @Override
    public void render() {
        Set<String> signatures = new HashSet<>();
        List<MethodInfo> methods = recordInfo.getMethods();
        if (!methods.isEmpty()) {
            for (MethodInfo methodInfo : methods) {
              Visibility vis = methodInfo.getVisibility();
              String selfArg = vis == Visibility.PRIVATE ? "this"
                : String.format("__PRIVATE_%s()", recordInfo.getFQName());
              renderMethodMembers(methodInfo, signatures, this::renderInstanceMethodMembers,
                                  selfArg);
            }
        }
        List<MethodInfo> staticMethods = recordInfo.getStaticMethods();
        if (!staticMethods.isEmpty()) {
            String firstArgRender = recordInfo.getSimpleName() + ".StaticMethod.instance";
            for (MethodInfo methodInfo : staticMethods) {
                String firstArg = null;
                if (methodInfo.omitFirstParam()) {
                    firstArg = firstArgRender;
                }
                renderMethodMembers(methodInfo, signatures, this::renderStaticMethodMembers, firstArg);
            }
        }
        List<MethodInfo> constructors = recordInfo.getUserConstructor();
        if (!constructors.isEmpty()) {
            for (MethodInfo methodInfo : constructors) {
                renderConstructor(methodInfo, signatures);
            }
        }
        if (getList(userConstructors).isEmpty()) {
            renderDefaultConstructor();
        } else if (recordInfo.getParent() == null) {
            addConstructingMethod(renderDefaultSuperInitMethod());
        }

        addCodeToManagedRecord();
    }

  @Override
  protected void addCodeToManagedRecord(ST recordTemplate) {
    recordTemplate.add("userConstructors", getList(userConstructors));
    recordTemplate.add("ambiguousMethods", getList(ambiguousMethods));
    recordTemplate.add("creationMethodsImpl", getList(creationMethodsImpl));
    recordTemplate.add("publicCreationMethods", getList(publicCreationMethods));
    recordTemplate.add("protectedCreationMethods", getList(protectedCreationMethods));
    recordTemplate.add("privateCreationMethods", getList(privateCreationMethods));
    recordTemplate.add("superInitMethods", getList(superInitMethods));
  }

    /**
     * Renders all class members of an instance method
     * 
     * @param methodInfo
     *            information of the method to render
     * @param signatures
     *            schema's full qualified name
     */
    private void renderMethodMembers(MethodInfo methodInfo, Set<String> signatures, Renderer renderer,
            String firstArg) {

        List<VarInfo> parameters = methodInfo.getParameters();
        String[] paramNames = parameters.stream().map(VarInfo::getName).toArray(String[]::new);
        int[] renderIndex = new int[parameters.size()];
        boolean[] emittedTwiceIndex = new boolean[parameters.size()];
        String[][] paramTypes = new String[parameters.size()][2];
        String[][] rendersArguments = new String[parameters.size()][2];
        for (int i = 0; i < parameters.size(); i++) {
            VarInfo varInfo = parameters.get(i);
            emittedTwiceIndex[i] = varInfo.isEmittedTwice();
            renderArgumentAndParameterType(varInfo, paramTypes, rendersArguments, i);
        }

        StringBuilder methodSignature = new StringBuilder();
        List<String> argsSelected = new ArrayList<>(parameters.size() + 1);
        StringBuilder parametersRender = new StringBuilder();

        String[][] renderMethod = renderMethodProperties(methodInfo);
        do {
            argsSelected.clear();
            if (firstArg != null) {
                argsSelected.add(firstArg);
            }
            renderArgumentsAndParameters(methodInfo, parameters, renderIndex, paramTypes, rendersArguments,
                    methodSignature, argsSelected, parametersRender);
            if (signatures.add(methodSignature.toString())) {
                for (String[] renders : renderMethod) {
                  renderer.render(parametersRender.toString(), paramNames, argsSelected, renders, methodInfo);
                }
            } else {
                messager.printMessage(Kind.ERROR, ERROR_METHODS_SIGNATURE, methodInfo.getMethod());
            }
        } while (increment(renderIndex, emittedTwiceIndex));
    }

    /**
     * Renders a parameter of an instance method
     * 
     * @param varInfo
     *            parameter to render
     * @param rendersParams
     *            to store the render of the parameter
     * @param rendersArguments
     *            to store the arguments related to this parameter
     * @param index
     *            the position to store the parameter in the given arrays
     */
  private void renderArgumentAndParameterType(VarInfo varInfo, String[][] rendersParams, String[][] rendersArguments,
            int index) {
        String name = varInfo.getName();
        if (varInfo.isEmittedTwice()) {
            DataType dataType = varInfo.getType();
            if (DataType.RECORD.equals(dataType)) {
                String complexType = varInfo.getComplexType();
                String record = complexType.substring(0, complexType.lastIndexOf('.'));
                rendersParams[index][0] = record;
                rendersParams[index][1] = complexType;
                rendersArguments[index][0] = "(" + complexType + ")" + name;
                rendersArguments[index][1] = name;
            } else {
                Properties properties = dataTypeRenderer.getProperties(dataType);
                Class<?> mngType = properties.getMngType();
                rendersParams[index][0] = properties.getPrimitiveType();
                rendersParams[index][1] = mngType.getCanonicalName();
                if (varInfo.isManaged()) {
                    rendersArguments[index][0] = mngType.getCanonicalName() + TypeProp.VALUE_OF + "(" + name + ")";
                    rendersArguments[index][1] = name;
                } else {
                    rendersArguments[index][0] = name;
                    rendersArguments[index][1] = name + " == null ? null : " + name + "."
                            + properties.getAsPrimitiveValueMethod();
                }
            }
        } else {
            rendersParams[index][0] = renderVarType(varInfo);
            rendersArguments[index][0] = name;
        }
    }

  private String maskedMethodName(MethodInfo methodInfo) {
    String name = methodInfo.getName();
    List<VarInfo> params = methodInfo.getParameters();
    int arity = params.size();
    boolean isObjMethod = false;
    if (arity == 0) {
      isObjMethod = (name.equals("toString")
                     || name.equals("hashCode"));
    } else if (arity == 1) {
      if (name.equals("equals")) {
        String argType = params.get(0).getComplexType();
        isObjMethod = "java.lang.Object".equals(argType);
      }
    }
    if (isObjMethod) {
      name = "__OBJECT_METHOD_"+name;
    }
    return name;
  }

    /**
     * Render method properties, including: name, return type and casting
     * 
     * @param methodInfo
     *            information of the method to render
     * @return rendered properties
     */
    private String[][] renderMethodProperties(MethodInfo methodInfo) {
        VarInfo returnType = methodInfo.getReturnType();
        String methodName = maskedMethodName(methodInfo);
        if (returnType.isEmittedTwice()) {
            String[][] renders = new String[2][4];
            Properties properties = dataTypeRenderer.getProperties(returnType.getType());
            Class<?> mngType = properties.getMngType();
            renders[PRIM][RETURN_TYPE] = properties.getPrimitiveType();
            renders[PRIM][CAST_START] = RETURN;
            renders[MNG][RETURN_TYPE] = mngType.getCanonicalName();
            if (returnType.isManaged()) {
                renders[PRIM][METHOD_NAME] = "prim" + firstCharUpperCase(methodName);
                renders[PRIM][CAST_END] = "." + properties.getAsPrimitiveValueMethod();
                renders[MNG][METHOD_NAME] = methodName;
                renders[MNG][CAST_START] = RETURN;
                renders[MNG][CAST_END] = EMPTY;
            } else {
                renders[PRIM][METHOD_NAME] = methodName;
                renders[PRIM][CAST_END] = EMPTY;
                renders[MNG][METHOD_NAME] = "managed" + firstCharUpperCase(methodName);
                renders[MNG][CAST_START] = RETURN + mngType.getCanonicalName() + TypeProp.VALUE_OF + "(";
                renders[MNG][CAST_END] = ")";
            }
            return renders;
        } else {
            String castStart = DataType.VOID.equals(returnType.getType()) ? EMPTY : RETURN;
            return new String[][] { { methodName, renderVarType(methodInfo.getReturnType()), castStart, EMPTY } };
        }
    }

    /**
     * @param string
     * @return the given string with its first character in upper case
     */
    private String firstCharUpperCase(String string) {
        return string.substring(0, 1).toUpperCase() + string.substring(1);
    }

    /**
     * Renders an instance method at the required visibility level
     * 
     * @param parameters
     *            parameters of the method
     * @param arguments
     *            arguments for the call to the schema method
     * @param renders
     *            the render of the elements: method name, return type and cast
     *            operations before and after schema method invocation
     * @param methodInfo
     *            information of the method to render
     */
  private void renderInstanceMethodMembers(String parameters, String[] paramNames, List<String> arguments,
                                           String[] renders, MethodInfo methodInfo)
  {
    String decl = renderMethodDeclaration(renders[RETURN_TYPE],
                                          renders[METHOD_NAME],
                                          parameters,
                                          paramNames);
    String impl = renderDefaultMethodImpl(parameters, arguments, renders,
                                          methodInfo.getName());
    Visibility vis = methodInfo.getVisibility();

    if (methodInfo.isAbstract()) {
      addCode(vis, decl);
    } else {
      addCode(methodInfo.getVisibility(), decl, impl);
      if (methodInfo.isAmbiguous()) {
        addAmbiguousMethod(renderAmbiguousMethodImpl(parameters, arguments,
                                                     renders, methodInfo.getName()));
      }
    }
  }

    /**
     * @param parameters
     *            parameters of the method
     * @param arguments
     *            arguments for the schema method
     * @param renders
     *            the render of the elements: method name, return type and cast
     *            operations before and after schema method invocation
     * @param schemaMethod
     *            name of the method in the schema
     * @return render of an instance method implementation for a class
     */
  private String renderAmbiguousMethodImpl(String parameters, List<String> arguments, String[] renders,
            String schemaMethod) {
        return renderMethodImpl(parameters, arguments, renders, schemaMethod, TEMPLATE_AMBIGUOUS_METHOD);
    }

    /**
     * Renders a static method at the required visibility level
     * 
     * @param parameters
     *            parameters of the method
     * @param arguments
     *            arguments for the call to the schema method
     * @param renders
     *            the render of the elements: method name, return type and cast
     *            operations before and after schema method invocation
     * @param methodInfo
     *            information of the method to render
     */
  private void renderStaticMethodMembers(String parameters, String[] paramNames, List<String> arguments,
                                         String[] renders, MethodInfo methodInfo)
  {
    String decl = renderStaticMethodDeclaration(renders[RETURN_TYPE],
                                                renders[METHOD_NAME],
                                                parameters);
    String impl = renderDefaultMethodImpl(parameters, arguments, renders, methodInfo.getName());

    addPrivateStaticMethod(impl);
    // addCode(methodInfo.getVisibility(),
    //         renderStaticMethod(parameters, arguments, renders, methodInfo.getName()));
    switch (methodInfo.getVisibility()) {
    case PUBLIC:
      addPublicStaticMethod(decl);
      addPublicMethod(renderStaticMethod(parameters, arguments, renders, methodInfo.getName()));
      break;
    case PROTECTED:
      addProtectedStaticMethod(decl);
      break;
    case PRIVATE:
      break; // ignore, default implementation is at this level
    default:
      break;
    }

  }

    /**
     * @param parameters
     *            parameters of the method
     * @param arguments
     *            arguments for the schema method
     * @param renders
     *            the render of the elements: method name, return type and cast
     *            operations before and after schema method invocation
     * @param schemaMethod
     *            name of the method in the schema
     * @return render of an instance method implementation for an interface
     */
    private String renderDefaultMethodImpl(String parameters, List<String> arguments, String[] renders,
            String schemaMethod) {
        return renderMethodImpl(parameters, arguments, renders, schemaMethod, TEMPLATE_METHOD_IMPL);
    }

    /**
     * @param parameters
     *            parameters of the method
     * @param arguments
     *            arguments for the schema method
     * @param renders
     *            the render of the elements: method name, return type and cast
     *            operations before and after schema method invocation
     * @param schemaMethod
     *            name of the method in the schema
     * @return render of the static method for an interface
     */
    private String renderStaticMethod(String parameters, List<String> arguments, String[] renders,
            String schemaMethod) {
        return renderMethodImpl(parameters, arguments, renders, schemaMethod, TEMPLATE_STATIC_METHOD);
    }

    /**
     * @param parameters
     *            parameters of the method
     * @param arguments
     *            arguments for the schema method
     * @param renders
     *            the render of the elements: method name, return type and cast
     *            operations before and after schema method invocation
     * @param schemaMethod
     *            name of the method in the schema
     * @param templateName
     *            name of the schema for the render
     * @return render of an instance method implementation
     */
    private String renderMethodImpl(String parameters, List<String> arguments, String[] renders, String schemaMethod,
            String templateName) {
      return renderTemplate(templateName,
                            t->{
                              t.add("methodName", renders[METHOD_NAME]);
                              t.add("returnType", renders[RETURN_TYPE]);
                              t.add("parameters", parameters);
                              t.add("schema", recordInfo.getSchema());
                              t.add("schemaMethod", schemaMethod);
                              t.add("arguments", arguments);
                              t.add("castStart", renders[CAST_START]);
                              t.add("castEnd", renders[CAST_END]);
                            });
    }

    /**
     * @param returnType
     *            return type of the method
     * @param name
     *            method name
     * @param parameters
     *            method parameters
     * @return render of an instance method declaration
     */
  private String renderMethodDeclaration(String returnType, String name, String parameters,
                                         String[] paramNames)
  {
    return renderTemplate(TEMPLATE_METHOD_DECLARATION,
                          t->{
                            t.add("returnType", returnType);
                            t.add("methodName", name);
                            t.add("parameters", parameters);
                            t.add("paramNames", paramNames);
                            t.add("return", returnType.equals("void") ? "" : RETURN);
                          });
  }

  /**
     * @param returnType
     *            return type of the method
     * @param name
     *            method name
     * @param parameters
     *            method parameters
     * @return render of an instance method declaration
     */
  private String renderStaticMethodDeclaration(String returnType, String name, String parameters)
  {
    return renderTemplate(TEMPLATE_STATIC_METHOD_DECLARATION,
                          t->{
                            t.add("returnType", returnType);
                            t.add("methodName", name);
                            t.add("parameters", parameters);
                          });
  }

    /**
     * Renders all members associated with the given constructor
     * 
     * @param constructor
     *            constructor to render
     * @param signatures
     *            methods signatures
     */
    private void renderConstructor(MethodInfo constructor, Set<String> signatures) {
        List<VarInfo> parameters = constructor.getParameters();
        String[] rendersParams = new String[parameters.size()];
        String[] rendersArguments = new String[parameters.size()];
        for (int i = 0; i < parameters.size(); i++) {
            VarInfo varInfo = parameters.get(i);
            String name = varInfo.getName();
            rendersParams[i] = renderVarType(varInfo) + " " + name;
            rendersArguments[i] = name;
        }
        addUserConstructor(renderConstructor(rendersParams, rendersArguments));
        renderConstructorMethods(constructor, signatures);
    }

    /**
     * @param varInfo
     * @return the render of the data type of a {@link VarInfo} as original
     *         declared
     */
    private String renderVarType(VarInfo varInfo) {
        DataType dataType = varInfo.getType();

        // if record or unknown datatype
        if (dataType == null || DataType.RECORD.equals(dataType)) {
            return varInfo.getComplexType();
        }

        // if void
        if (DataType.VOID.equals(dataType)) {
            return VOID;
        }

        // if array type
        if (DataType.ARRAY.equals(dataType)) {
            String complexType = varInfo.getComplexType();
            if (complexType != null) {
                return complexType;
            } else {
                String type = TypeProp.ARRAY_GENERIC.getMngType().getCanonicalName();
                return dataTypeRenderer.renderTypeWithParams(type, varInfo.getTypeParams());
            }
        }

        Properties properties = dataTypeRenderer.getProperties(dataType);

        // if collection with parameters
        if (dataType.getRequiredParams() > 0) {
            final String typeName;
            if (varInfo.isManaged()) {
                typeName = properties.getMngType().getCanonicalName();
            } else {
                typeName = properties.getPrimitiveType();
            }
            return dataTypeRenderer.renderTypeWithParams(typeName, varInfo.getTypeParams());
        }

        // any other case
        if (varInfo.isManaged()) {
            return properties.getMngType().getCanonicalName();
        }
        return properties.getPrimitiveType();
    }

    /**
     * @param parameters
     *            rendered method parameters
     * @param arguments
     *            rendered arguments for the schema method
     * @return Render of a constructor
     */
    private String renderConstructor(String[] parameters, String[] arguments) {
      return renderTemplate(TEMPLATE_USER_CONSTRUCTOR,
                            t->{
                              t.add("recordName", recordInfo.getSimpleName());
                              t.add("parameters", parameters);
                              t.add("schema", recordInfo.getSchema());
                              t.add("arguments", arguments);
                            });
    }

    /**
     * Renders creation methods for the given constructor
     * 
     * @param constructor
     *            information of the constructor
     * @param signatures
     *            method signatures
     */
    private void renderConstructorMethods(MethodInfo constructor, Set<String> signatures) {
        List<VarInfo> parameters = constructor.getParameters();
        int[] renderIndex = new int[parameters.size()];
        boolean[] emittedTwiceIndex = new boolean[parameters.size()];
        String[][] paramTypes = new String[parameters.size()][2];
        String[][] rendersArguments = new String[parameters.size()][2];
        for (int i = 0; i < parameters.size(); i++) {
            VarInfo varInfo = parameters.get(i);
            emittedTwiceIndex[i] = varInfo.isEmittedTwice();
            renderArgumentAndParameterType(varInfo, paramTypes, rendersArguments, i);
        }

        StringBuilder methodSignature = new StringBuilder();
        List<String> argsSelected = new ArrayList<>(parameters.size());
        StringBuilder parametersRender = new StringBuilder();
        Visibility visibility = constructor.getVisibility();

        do {
            argsSelected.clear();
            renderArgumentsAndParameters(constructor, parameters, renderIndex, paramTypes, rendersArguments,
                    methodSignature, argsSelected, parametersRender);
            if (signatures.add(methodSignature.toString())) {
              if (!recordInfo.isAbstract()) {
                renderCreationMethodMembers(parametersRender.toString(), argsSelected, visibility);
              }
              addSuperInitMethod(renderSuperInitMethod(parametersRender.toString(), argsSelected));
              addConstructingMethod(renderThisInitMethod(parametersRender.toString(), argsSelected));
            } else {
                messager.printMessage(Kind.ERROR, ERROR_METHODS_SIGNATURE, constructor.getMethod());
            }
        } while (increment(renderIndex, emittedTwiceIndex));
    }

    /**
     * Renders the parameters of a method and the arguments used to call the
     * corresponding schema method
     * 
     * @param method
     *            information of the method being rendered
     * @param parameters
     *            parameters information
     * @param renderIndex
     *            the position index of parameters and arguments to render
     * @param paramTypes
     *            renders of parameters
     * @param rendersArguments
     *            renders of arguments
     * @param methodSignature
     *            to store the signature of the method being rendered
     * @param argsSelected
     *            to store the arguments used for the render of this method
     * @param parametersRender
     *            to store the rendered parameters
     */
    private void renderArgumentsAndParameters(MethodInfo method, List<VarInfo> parameters, int[] renderIndex,
            String[][] paramTypes, String[][] rendersArguments, StringBuilder methodSignature,
            List<String> argsSelected, StringBuilder parametersRender) {
        methodSignature.setLength(0); // cleaning the content first
        methodSignature.append(method.getName()).append(SIGNATURE_SEPARATOR);
        parametersRender.setLength(0); // cleaning the content first
        String separator = EMPTY;
        for (int i = 0; i < renderIndex.length; i++) {
            String paramType = paramTypes[i][renderIndex[i]];
            parametersRender.append(separator).append(paramType).append(" ").append(parameters.get(i).getName());
            methodSignature.append(paramType).append(SIGNATURE_SEPARATOR);
            argsSelected.add(rendersArguments[i][renderIndex[i]]);
            separator = ", ";
        }
    }

    /**
     * Renders creation method implementation and declarations at the given
     * visibility level
     * 
     * @param parameters
     *            rendered creation method parameters
     * @param arguments
     *            rendered arguments for the implementation
     * @param visibility
     *            the visibility level of the creation method
     */
    private void renderCreationMethodMembers(String parameters, List<String> arguments, Visibility visibility) {
        addCreationMethodsImpl(renderCreationMethodImpl(parameters, arguments));
        switch (visibility) {
        case PUBLIC:
            addPublicCreationMethod(renderCreationMethodDec(parameters));
            // public also renders protected and private
        case PROTECTED:
            addProtectedCreationMethod(renderCreationMethodDecWithType(parameters, PROTECTED));
            // protected also renders private
        case PRIVATE:
            addPrivateCreationMethod(renderCreationMethodDecWithType(parameters, PRIVATE));
            break;
        default:
            break;
        }
    }

    /**
     * Tries to increment the counter of the indexes
     * 
     * @param renderIndex
     *            index to increment
     * @param emittedTwiceIndex
     *            flags for index that cannot be incremented
     * @return true if the index was incremented
     */
    private boolean increment(int[] renderIndex, boolean[] emittedTwiceIndex) {
        for (int i = 0; i < renderIndex.length; i++) {
            if (emittedTwiceIndex[i]) {
                if (renderIndex[i] == 0) {
                    renderIndex[i] = 1;
                    return true;
                } else {
                    renderIndex[i] = 0;
                }
            }
        }
        return false;
    }

    /**
     * 
     * @param parameters
     *            rendered method parameters
     * @param arguments
     *            rendered arguments for the schema method
     * @return Implementation of a creation method
     */
    private String renderCreationMethodImpl(String parameters, List<String> arguments) {
      return renderTemplate(TEMPLATE_CREATION_METHOD_IMPL,
                            t->{
                              t.add("recordName", recordInfo.getSimpleName());
                              t.add("parameters", parameters);
                              t.add("arguments", arguments);
                              t.add("fq_name", recordInfo.getFQName());
                            });
    }

    /**
     * @param parameters
     *            rendered method parameters
     * @param type
     *            for the return type
     * @return Render of a creation method declaration with the given type
     */
    private String renderCreationMethodDecWithType(String parameters, String type) {
        String returnType = recordInfo.getSimpleName() + "." + type;
        return renderCreationMethodDec(parameters, returnType);
    }

    /**
     * @param parameters
     *            rendered method parameters
     * @return Render of a creation method declaration with the record type as
     *         return type
     */
    private String renderCreationMethodDec(String parameters) {
        return renderCreationMethodDec(parameters, recordInfo.getSimpleName());
    }

    /**
     * @param parameters
     *            rendered method parameters
     * @param returnType
     *            the rendered return type of the method
     * @return Render of a creation method declaration with the given return
     *         type
     */
    private String renderCreationMethodDec(String parameters, String returnType) {
      return renderTemplate(TEMPLATE_CREATION_METHOD_DEC,
                            t->{
                              t.add("returnType", returnType);
                              t.add("parameters", parameters);
                            });
    }

    /**
     * Renders the default no argument constructor
     */
    private void renderDefaultConstructor() {
      String code = renderTemplate(TEMPLATE_DEFAULT_CONSTRUCTOR,
                                   t->{
                                     t.add("recordName", recordInfo.getSimpleName());
                                     t.add("parentRecord", recordInfo.getParent());
                                   });
      addUserConstructor(code);
      addSuperInitMethod(renderDefaultSuperInitMethod());
      if (!recordInfo.isAbstract()) {
        renderCreationMethodMembers(EMPTY, Collections.emptyList(), Visibility.PUBLIC);
      }
    }

  private String renderSuperInitMethod(String parameters, List<String> arguments) {
    return renderTemplate(TEMPLATE_SUPER_INIT_METHOD,
                          t->{
                            t.add("recordName", recordInfo.getSimpleName());
                            t.add("parameters", parameters);
                            t.add("schema", recordInfo.getSchema());
                            t.add("arguments", arguments);
                            t.add("fq_name", recordInfo.getFQName());
                          });
    }

  private String renderDefaultSuperInitMethod() {
    return renderTemplate(TEMPLATE_DEFAULT_SUPER_INIT_METHOD,
                          t->{
                            t.add("recordName", recordInfo.getSimpleName());
                            t.add("parentRecord", recordInfo.getParent());
                            t.add("fq_name", recordInfo.getFQName());
                          });
    }

  private String renderThisInitMethod(String parameters, List<String> arguments) {
    return renderTemplate(TEMPLATE_THIS_INIT_METHOD,
                          t->{
                            t.add("recordName", recordInfo.getSimpleName());
                            t.add("parameters", parameters);
                            t.add("schema", recordInfo.getSchema());
                            t.add("arguments", arguments);
                          });
    }

}
