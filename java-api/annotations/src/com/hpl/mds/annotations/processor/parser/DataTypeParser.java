/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processor.parser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;

import javax.lang.model.element.Element;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.type.WildcardType;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;

import com.hpl.mds.annotations.processor.RecordInfo.DataType;
import com.hpl.mds.annotations.processor.RecordInfo.ParameterType;
import com.hpl.mds.annotations.processor.RecordInfo.VarInfo;

/**
 * Identifies a data type and its parameters into a more abstract ones, they are
 * converted to {@link DataType}s.
 * 
 * For example a {@link java.util.List} and a com.hpl.mds.ManagedList are both
 * converted to {@link DataType#LIST} with its corresponding parameters this
 * enables a more generic validation and code generation for both cases.
 * 
 * The information generated by this parser is stored in a {@link VarInfo}
 * 
 * @author Abraham Alcantara
 */
public class DataTypeParser {

    private static final String PKG_DELIMITER = ".";
    private static final String MANAGED_PREFIX = "com.hpl.mds.";

    private static final String MANAGED_MAP = "com.hpl.mds.ManagedMap";
    private static final String MANAGED_SET = "com.hpl.mds.ManagedSet";
    private static final String MANAGED_LIST = "com.hpl.mds.ManagedList";

    private static final String OBJ_MAP = "java.util.Map";
    private static final String OBJ_SET = "java.util.Set";
    private static final String OBJ_LIST = "java.util.List";
    private static final String OBJ_STRING = "java.lang.String";
    private static final String OBJ_SHORT = "java.lang.Short";
    private static final String OBJ_LONG = "java.lang.Long";
    private static final String OBJ_INTEGER = "java.lang.Integer";
    private static final String OBJ_FLOAT = "java.lang.Float";
    private static final String OBJ_DOUBLE = "java.lang.Double";
    private static final String OBJ_BYTE = "java.lang.Byte";
    private static final String OBJ_BOOLEAN = "java.lang.Boolean";

    private static final String MANAGED_PRIMITIVE = "com.hpl.mds.ManagedPrimitive";
    private static final String MANAGED_STRING = "com.hpl.mds.ManagedString";
    private static final String MANAGED_SHORT = "com.hpl.mds.ManagedShort";
    private static final String MANAGED_LONG = "com.hpl.mds.ManagedLong";
    private static final String MANAGED_INT = "com.hpl.mds.ManagedInt";
    private static final String MANAGED_FLOAT = "com.hpl.mds.ManagedFloat";
    private static final String MANAGED_DOUBLE = "com.hpl.mds.ManagedDouble";
    private static final String MANAGED_BYTE = "com.hpl.mds.ManagedByte";
    private static final String MANAGED_BOOLEAN = "com.hpl.mds.ManagedBoolean";

    private static final String MANAGED_ARRAY_BOOLEAN = "com.hpl.mds.ManagedBooleanArray";
    private static final String MANAGED_ARRAY_BYTE = "com.hpl.mds.ManagedByteArray";
    private static final String MANAGED_ARRAY_DOUBLE = "com.hpl.mds.ManagedDoubleArray";
    private static final String MANAGED_ARRAY_FLOAT = "com.hpl.mds.ManagedFloatArray";
    private static final String MANAGED_ARRAY_INT = "com.hpl.mds.ManagedIntArray";
    private static final String MANAGED_ARRAY_LONG = "com.hpl.mds.ManagedLongArray";
    private static final String MANAGED_ARRAY_SHORT = "com.hpl.mds.ManagedShortArray";
    private static final String MANAGED_ARRAY_STRING = "com.hpl.mds.ManagedStringArray";

    private static final String MANAGED_RECORD = "com.hpl.mds.ManagedRecord";
    private static final String MANAGED_ARRAY = "com.hpl.mds.ManagedArray";
    private static final String MANAGED_CONTAINER = "com.hpl.mds.ManagedContainer";
    private static final String MANAGED_COLLECTION = "com.hpl.mds.ManagedCollection";

    private static final String PROTECTED = "Protected";
    private static final String PRIVATE = "Private";

    /**
     * To log messages for debugging purposes
     */
    private static final Logger LOGGER = Logger.getLogger(DataTypeParser.class.getName());

    /**
     * Utilities for source code types
     */
    private final Types typeUtil;

    /*
     * reference to known types
     */
    private final TypeMirror managedRecordType;
    private final TypeMirror managedArrayType;
    private final TypeMirror managedPrimitiveType;
    private final TypeMirror managedContainerType;

    /*
     * All class qualified names of known managed records
     */
    private final Set<String> managedRecords;

    /**
     * 
     * @param typeUtil
     *            Utilities for source code types
     * @param elementUtil
     *            Utilities for source code elements
     * @param managedRecords
     *            All known managed records
     */
    public DataTypeParser(Types typeUtil, Elements elementUtil, Set<String> managedRecords) {
        this.typeUtil = typeUtil;
        this.managedRecords = managedRecords;
        managedRecordType = elementUtil.getTypeElement(MANAGED_RECORD).asType();
        WildcardType nullType = typeUtil.getWildcardType(null, null);
        managedArrayType = typeUtil.getDeclaredType(elementUtil.getTypeElement(MANAGED_ARRAY), nullType);
        managedPrimitiveType = typeUtil.getDeclaredType(elementUtil.getTypeElement(MANAGED_PRIMITIVE), nullType);
        managedContainerType = elementUtil.getTypeElement(MANAGED_CONTAINER).asType();
    }

    /**
     * Parses a data type
     * 
     * @param type
     *            data type to parse
     * @param varInfo
     *            to store parsed values
     * @param element
     *            for error messages
     * @param currentPkg
     * @param recordSimpleName
     * @return true if the data type was successfully parsed, false otherwise
     * 
     * @throws ProcessingException
     *             if invalid data type is found
     */
    public boolean parse(TypeMirror type, VarInfo varInfo, Element element, String currentPkg, String recordSimpleName)
            throws ProcessingException {
        if (parsePrimitiveType(type, varInfo, element)) {
            return true;
        }
        if (TypeKind.DECLARED.equals(type.getKind()) || type instanceof DeclaredType) {
            DeclaredType declaredType = (DeclaredType) type;
            if (parseManagedType(declaredType, varInfo, element, currentPkg)) {
                LOGGER.info("parsed as managed type: " + type);
                return true;
            }
            if (parseJavaObjectType(declaredType, varInfo, element, currentPkg)) {
                LOGGER.info("parsed as java type: " + type);
                return true;
            }
            if (isManagedRecord(declaredType, currentPkg)) {
                LOGGER.info("parsed as record type: " + type);
                parseRecordType(declaredType, varInfo);
                return true;
            }
        }
        if (TypeKind.ERROR.equals(type.getKind())) {
            LOGGER.info("parsing type with error: " + type);
            return parseAsManagedRecord(type, varInfo, currentPkg, recordSimpleName);
        }
        return false;
    }

    /**
     * Parses data type of primitive type
     * 
     * @param type
     *            data type to parse
     * @param varInfo
     *            to store parsed values
     * @param element
     *            for error messages
     * 
     * @return true if it's a primitive type
     */
    private boolean parsePrimitiveType(TypeMirror type, VarInfo varInfo, Element element) {
        DataType primType = parsePrimitiveDataType(type);
        if (primType != null) {
            varInfo.setManaged(false);
            varInfo.setType(primType);
            return true;
        }
        return false;
    }

    /**
     * Parses Java primitive data types
     * 
     * @param type
     *            data type to parse
     * @return null if no data type is not of primitive type
     */
    private DataType parsePrimitiveDataType(TypeMirror type) {
        switch (type.getKind()) {
        case INT:
            return DataType.INT;
        case BOOLEAN:
            return DataType.BOOLEAN;
        case BYTE:
            return DataType.BYTE;
        case DOUBLE:
            return DataType.DOUBLE;
        case FLOAT:
            return DataType.FLOAT;
        case LONG:
            return DataType.LONG;
        case SHORT:
            return DataType.SHORT;
        case VOID:
            return DataType.VOID;
        default:
            return null;
        }
    }

    /**
     * Parses field data type of managed type
     * 
     * @param declaredType
     *            data type to parse
     * @param varInfo
     *            to store parsed values
     * @param element
     *            for error messages
     * @param currentPkg
     *            the default package in this scope
     * @return true if it's a managed type
     * @throws ProcessingException
     */
    private boolean parseManagedType(DeclaredType declaredType, VarInfo varInfo, Element element, String currentPkg)
            throws ProcessingException {
        DataType dataType = parseManagedDataType(declaredType, element);
        if (dataType != null) {
            varInfo.setManaged(true);
            varInfo.setType(dataType);
            parseTypeParams(declaredType, varInfo, element, currentPkg);
            return true;
        }
        return false;
    }

    /**
     * Parses managed data types
     * 
     * @param declaredType
     *            data type to parse
     * @param element
     *            for error messages
     * @return the parsed {@link DataType}, null if unknown
     * @throws ProcessingException
     */
    private DataType parseManagedDataType(DeclaredType declaredType, Element element) throws ProcessingException {
        if (!declaredType.asElement().toString().startsWith(MANAGED_PREFIX)) {
            return null;
        }
        if (typeUtil.isAssignable(declaredType, managedPrimitiveType)
                || hasSuperType(declaredType, MANAGED_PRIMITIVE)) {
            return parseManagedPrimitiveDataType(declaredType, element);
        }
        if (MANAGED_ARRAY.equals(declaredType.asElement().toString())
                || typeUtil.isAssignable(declaredType, managedArrayType) || hasSuperType(declaredType, MANAGED_ARRAY)) {
            return DataType.ARRAY;
        }
        if (typeUtil.isAssignable(declaredType, managedContainerType) || hasSuperType(declaredType, MANAGED_CONTAINER)
                || hasSuperType(declaredType, MANAGED_COLLECTION)) {
            return parseManagedContainerDataType(declaredType, element);
        }
        return null;
    }

    /**
     * @param type
     * @param superType
     * @return true if the given type has the referenced super type, false
     *         otherwise
     */
    private boolean hasSuperType(TypeMirror type, String superType) {
        List<? extends TypeMirror> directSupertypes = typeUtil.directSupertypes(type);
        if (directSupertypes != null) {
            for (TypeMirror typeMirror : directSupertypes) {
                if (TypeKind.DECLARED.equals(typeMirror.getKind())) {
                    DeclaredType declaredType = (DeclaredType) typeMirror;
                    if (superType.equals(declaredType.asElement().toString())) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * Parses managed primitive data types
     * 
     * @param typeMirror
     *            data type to parse
     * @param element
     *            for error messages
     * @return the parsed {@link DataType}
     * @throws ProcessingException
     *             if invalid data type
     */
    private DataType parseManagedPrimitiveDataType(TypeMirror typeMirror, Element element) throws ProcessingException {
        switch (typeMirror.toString()) {
        case MANAGED_BOOLEAN:
            return DataType.BOOLEAN;
        case MANAGED_BYTE:
            return DataType.BYTE;
        case MANAGED_DOUBLE:
            return DataType.DOUBLE;
        case MANAGED_FLOAT:
            return DataType.FLOAT;
        case MANAGED_INT:
            return DataType.INT;
        case MANAGED_LONG:
            return DataType.LONG;
        case MANAGED_SHORT:
            return DataType.SHORT;
        case MANAGED_STRING:
            return DataType.STRING;
        default:
            throw new ProcessingException("Unsupported managed primitive data type: " + typeMirror, element);
        }
    }

    /**
     * Parses managed container data types
     * 
     * @param declaredType
     *            data type to parse
     * @param element
     *            for error messages
     * @return parsed {@link DataType}
     * @throws ProcessingException
     *             if invalid data type
     */
    private DataType parseManagedContainerDataType(DeclaredType declaredType, Element element)
            throws ProcessingException {
        switch (declaredType.asElement().toString()) {
        case MANAGED_LIST:
            return DataType.LIST;
        case MANAGED_SET:
            return DataType.SET;
        case MANAGED_MAP:
            return DataType.MAP;
        default:
            throw new ProcessingException("Unsupported managed container data type: " + declaredType, element);
        }
    }

    /**
     * Parses data type parameters
     * 
     * @param declaredType
     *            data type to parse
     * @param varInfo
     *            to store parsed parameter types
     * @param element
     *            for error messages
     * @param currentPkg
     *            the default package in this scope
     * @throws ProcessingException
     *             if invalid type parameters
     */
    private void parseTypeParams(DeclaredType declaredType, VarInfo varInfo, Element element, String currentPkg)
            throws ProcessingException {
        List<? extends TypeMirror> typeParams = declaredType.getTypeArguments();
        DataType dataType = varInfo.getType();
        if (parseValidParams(dataType, typeParams.size(), element)) {
            varInfo.setTypeParams(parseTypeParams(typeParams, element, currentPkg));
        }
        if (DataType.ARRAY.equals(dataType)) {
            if (typeParams.size() > 0) {
                varInfo.setTypeParams(parseTypeParams(typeParams, element, currentPkg));
            } else {
                varInfo.setComplexType(declaredType.toString());
                varInfo.setTypeParams(Arrays.asList(parseArrayParam(declaredType, element)));
            }
        }
    }

    /**
     * @param dataType
     *            the main data type
     * @param paramsSize
     *            number of parameters
     * @param field
     *            element for error messages
     * @return true if valid parameters are found, false if no parameters need
     *         to be parsed.
     * @throws ProcessingException
     *             if invalid parameters are found
     */
    private boolean parseValidParams(DataType dataType, int paramsSize, Element field) throws ProcessingException {
        int requiredParams = dataType.getRequiredParams();
        if (requiredParams > 0) {
            if (paramsSize != requiredParams) {
                throw new ProcessingException("Illegal number of parameters for data type: " + dataType, field);
            }
            return true;
        }
        return false;
    }

    /**
     * Parses data type parameters
     * 
     * @param typeParams
     *            the parameters to parse
     * @param element
     *            for error messages
     * @param currentPkg
     *            the default package in this scope
     * @return the resulting parameter types
     * @throws ProcessingException
     *             in case of invalid data type parameters
     */
    private List<ParameterType> parseTypeParams(List<? extends TypeMirror> typeParams, Element element,
            String currentPkg) throws ProcessingException {
        List<ParameterType> params = new ArrayList<>(typeParams.size());
        for (TypeMirror typeMirror : typeParams) {
            if (!(typeMirror instanceof DeclaredType)) {
                throw new ProcessingException("Unknown parameter data type: " + typeMirror, element);
            }
            params.add(parseParameterDataType((DeclaredType) typeMirror, element, currentPkg));
        }
        return params;
    }

    /**
     * Parses a parameter data type
     * 
     * @param declaredType
     *            data type to parse
     * @param element
     *            for error messages
     * @param currentPkg
     *            the default package in this scope
     * @return {@link ParameterType} with the parsed values
     * @throws ProcessingException
     *             if invalid data type
     */
    private ParameterType parseParameterDataType(DeclaredType declaredType, Element element, String currentPkg)
            throws ProcessingException {
        if (isManagedRecord(declaredType, currentPkg)) {
            ParameterType parameterType = new ParameterType(DataType.RECORD);
            parameterType.setComplexType(declaredType.toString());
            return parameterType;
        }
        DataType dataType = parseManagedDataType(declaredType, element);
        if (dataType != null) {
            return new ParameterType(dataType);
        }
        dataType = parseJavaObjectDataType(declaredType.toString());
        if (dataType != null) {
            return new ParameterType(dataType);
        }
        throw new ProcessingException("Unknown parameter data type: " + declaredType, element);
    }

    /**
     * @param type
     *            type to parse
     * @param currentPkg
     *            the default package in this scope
     * @return true if the given type is a managed record type, false otherwise
     */
    public boolean isManagedRecord(TypeMirror type, String currentPkg) {
        if (type instanceof DeclaredType) {
            /*
             * if the type referene is to a private or protected element we try
             * to identify the parent type
             */
            DeclaredType declaredType = (DeclaredType) type;
            String simpleName = declaredType.asElement().getSimpleName().toString();
            if (PRIVATE.equals(simpleName) || PROTECTED.equals(simpleName)) {
                type = declaredType.asElement().getEnclosingElement().asType();
            }
        }
        if (managedRecords.contains(addDefaultPackage(type.toString(), currentPkg))) {
            return true;
        }
        if (typeUtil.isAssignable(type, managedRecordType)) {
            return true;
        }
        return hasSuperType(type, MANAGED_RECORD);
    }

    /**
     * @param record
     *            the class name
     * @param currentPkg
     *            the default package in this scope
     * @return the given class name with the default package added to it
     */
    private String addDefaultPackage(String record, String currentPkg) {
        if (record.indexOf(PKG_DELIMITER) < 0) {
            record = currentPkg + PKG_DELIMITER + record;
        }
        return record;
    }

    /**
     * Parses data types of Java Object types
     * 
     * @param type
     *            qualified name of the type to parse
     * @return the parsed {@link DataType}, null if unknown
     */
    private DataType parseJavaObjectDataType(String type) {
        switch (type) {
        case OBJ_BOOLEAN:
            return DataType.BOOLEAN;
        case OBJ_BYTE:
            return DataType.BYTE;
        case OBJ_DOUBLE:
            return DataType.DOUBLE;
        case OBJ_FLOAT:
            return DataType.FLOAT;
        case OBJ_INTEGER:
            return DataType.INT;
        case OBJ_LONG:
            return DataType.LONG;
        case OBJ_SHORT:
            return DataType.SHORT;
        case OBJ_STRING:
            return DataType.STRING;
        case OBJ_LIST:
            return DataType.LIST;
        case OBJ_SET:
            return DataType.SET;
        case OBJ_MAP:
            return DataType.MAP;
        default:
            return null;
        }
    }

    /**
     * Parses data type of java object type
     * 
     * @param declaredType
     *            data type to parse
     * @param varInfo
     *            to store parsed values
     * @param element
     *            for error messages
     * @param currentPkg
     *            the default package in this scope
     * @return true if it's a object type
     * @throws ProcessingException
     */
    private boolean parseJavaObjectType(DeclaredType declaredType, VarInfo varInfo, Element element, String currentPkg)
            throws ProcessingException {
        DataType dataType = parseJavaObjectDataType(declaredType.asElement().toString());
        if (dataType != null) {
            varInfo.setManaged(false);
            varInfo.setType(dataType);
            parseTypeParams(declaredType, varInfo, element, currentPkg);
            return true;
        }
        return false;
    }

    /**
     * Retrieves the parameter type from the given implementation class of the
     * type
     * 
     * @param declaredType
     *            data type to parse
     * @param element
     *            for error messages
     * @return {@link ParameterType}
     * @throws ProcessingException
     *             if fail to parse the parameter type
     */
    private ParameterType parseArrayParam(DeclaredType declaredType, Element element) throws ProcessingException {
        switch (declaredType.toString()) {
        case MANAGED_ARRAY_BOOLEAN:
            return new ParameterType(DataType.BOOLEAN);
        case MANAGED_ARRAY_BYTE:
            return new ParameterType(DataType.BYTE);
        case MANAGED_ARRAY_DOUBLE:
            return new ParameterType(DataType.DOUBLE);
        case MANAGED_ARRAY_FLOAT:
            return new ParameterType(DataType.FLOAT);
        case MANAGED_ARRAY_INT:
            return new ParameterType(DataType.INT);
        case MANAGED_ARRAY_LONG:
            return new ParameterType(DataType.LONG);
        case MANAGED_ARRAY_SHORT:
            return new ParameterType(DataType.SHORT);
        case MANAGED_ARRAY_STRING:
            return new ParameterType(DataType.STRING);
        default:
            throw new ProcessingException("Unsupported array type: " + declaredType, element);
        }
    }

    /**
     * Parses a record data type
     * 
     * @param declaredType
     *            data type to parse
     * @param varInfo
     *            to store parsed values
     * 
     */
    private void parseRecordType(DeclaredType declaredType, VarInfo varInfo) {
        varInfo.setManaged(true);
        varInfo.setType(DataType.RECORD);
        varInfo.setComplexType(declaredType.toString());
        Element typeElement = declaredType.asElement();
        String simpleName = typeElement.getSimpleName().toString();
        if (PRIVATE.equals(simpleName) || PROTECTED.equals(simpleName)) {
            varInfo.setEmittedTwice();
        }
    }

    /**
     * @param type
     *            the data type to parse
     * @param varInfo
     *            to store parsed information
     * @param currentPkg
     *            the default package in this scope
     * @param recordSimpleName
     * @return true if the given data type is the same record that is being
     *         generated, false otherwise
     */
    private boolean parseAsManagedRecord(TypeMirror type, VarInfo varInfo, String currentPkg, String recordSimpleName) {
        String record = type.toString();
        if (record.endsWith(PRIVATE)) {
            record = record.substring(0, record.length() - PRIVATE.length());
        } else if (record.endsWith(PROTECTED)) {
            record = record.substring(0, record.length() - PROTECTED.length());
        }
        if (recordSimpleName.equals(record)) {
            varInfo.setManaged(true);
            varInfo.setType(DataType.RECORD);
            varInfo.setComplexType(currentPkg + PKG_DELIMITER + recordSimpleName);
            return true;
        }
        record = addDefaultPackage(record, currentPkg);
        if (managedRecords.contains(record)) {
            varInfo.setManaged(true);
            varInfo.setType(DataType.RECORD);
            varInfo.setComplexType(record);
            return true;
        }
        return false;
    }
}
