/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.mds.annotations.processor.parser;

import java.util.Collections;
import java.util.Map;
import java.util.logging.Logger;

import javax.annotation.processing.Messager;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.element.Modifier;
import javax.tools.Diagnostic.Kind;

import com.hpl.mds.annotations.Emitted;
import com.hpl.mds.annotations.Final;
import com.hpl.mds.annotations.Private;
import com.hpl.mds.annotations.processor.RecordInfo;
import com.hpl.mds.annotations.processor.RecordInfo.ConstantInfo;
import com.hpl.mds.annotations.processor.RecordInfo.DataType;
import com.hpl.mds.annotations.processor.RecordInfo.FieldInfo;
import com.hpl.mds.annotations.processor.RecordInfo.GetterFormatInfo;
import com.hpl.mds.annotations.processor.RecordInfo.VarInfo;
import com.hpl.mds.annotations.processor.RecordInfo.Visibility;

/**
 * Parses a declaration of a field member in a record schema, the parsing
 * process generates a {@link FieldInfo} which contains all information related
 * to this field including its visibility, getters and modifiers.
 * 
 * @author Abraham Alcantara
 */
public class FieldParser {

    private static final String PKG_DELIMITER = ".";
    private static final String FIELD_SUFFIX = "Field";

    /**
     * To log messages for debugging purposes
     */
    private static final Logger LOGGER = Logger.getLogger(FieldParser.class.getName());

    /**
     * To display localized messages to the user
     */
    private final Messager messager;

    /*
     * Parsers to extract specific data
     */
    private final DataTypeParser dataTypeParser;
    private final VisibilitiesParser visibilitiesParser;
    private final GetterNameParser getterNameParser;

    public FieldParser(Messager messager, VisibilitiesParser visibilitiesParser, GetterNameParser getterNameParser,
            DataTypeParser dataTypeParser) {
        this.messager = messager;
        this.visibilitiesParser = visibilitiesParser;
        this.getterNameParser = getterNameParser;
        this.dataTypeParser = dataTypeParser;
    }

    /**
     * Identifies and parses a member of a field declaration
     * 
     * @param method
     *            the member to prove and parse
     * @param recordInfo
     *            to store parsed values
     * @param schemaContext
     *            schema information context
     * @return true if the given member is a field declaration
     */
    public boolean parse(ExecutableElement method, RecordInfo recordInfo, SchemaContext schemaContext) {

        // if not a field
        if (!method.getParameters().isEmpty()) {
            return false;
        }

        // parsing field...
        try {
          String mdsName = method.getSimpleName().toString();
          if (isDuplicate(mdsName, recordInfo, schemaContext.getParent(), method)) {
            return true;
          }
          VarInfo varInfo = parseFieldDataType(method, schemaContext, mdsName);
          if (varInfo == null) {
            return true;
          }
          String getterNameFormat = getFieldGetterNameFormat(method, varInfo.getType(), schemaContext);
          boolean isFinal = (method.getAnnotation(Final.class) != null);
          FieldInfo fieldInfo = new FieldInfo(varInfo, mdsName, getterNameFormat, isFinal);
          parseFieldVisibility(fieldInfo, method, schemaContext);
          recordInfo.addField(fieldInfo);
        } catch (ProcessingException e) {
            messager.printMessage(Kind.ERROR, "Ignoring Field, " + e.getMessage(), e.getElement());
        } catch (Exception e) {
            LOGGER.severe("exception: " + e.getMessage());
        }
        // the element was identified as a field even if the parsing failed
        return true;
    }

    /**
     * 
     * @param method
     *            the member to prove and parse
     * @param schemaContext
     *            schema information context
     * @param mdsName
     *            field MDS name
     * @return {@link VarInfo} containing parsed data type information
     * @throws ProcessingException
     */
    private VarInfo parseFieldDataType(ExecutableElement method, SchemaContext schemaContext, String mdsName)
            throws ProcessingException {
        VarInfo varInfo = new VarInfo(mdsName + FIELD_SUFFIX);
        if (!dataTypeParser.parse(method.getReturnType(), varInfo, method, schemaContext.getPkg(),
                schemaContext.getRecordSimpleName())) {
            messager.printMessage(Kind.ERROR, "Ignoring Field, Unsupported datatype:" + method.getReturnType().getKind()
                    + ":" + method.getReturnType() + " for field", method);
            return null;
        }
        if (DataType.VOID.equals(varInfo.getType())) {
            messager.printMessage(Kind.ERROR, "Ignoring Field, Unsupported datatype:VOID", method);
            return null;
        }
        return varInfo;
    }

    /**
     * @param field
     * @param type
     *            field type
     * @param schemaContext
     * 
     * @return The default name format for the getter name if not present in the
     *         given field.
     */
    private String getFieldGetterNameFormat(Element field, DataType type, SchemaContext schemaContext) {
        GetterFormatInfo fieldGetterNameFormat = getterNameParser.parse(field);
        if (fieldGetterNameFormat == null) {
            fieldGetterNameFormat = schemaContext.getGetterNameFormat();
        }
        if (DataType.BOOLEAN.equals(type)) {
            return fieldGetterNameFormat.getBooleanFormat();
        } else {
            return fieldGetterNameFormat.getNonBooleanFormat();
        }
    }

    /**
     * Retrieves and validates the name of the declared field
     * 
     * @param recordInfo
     * 
     * @param element
     *            declared element for the field
     * @param parent
     * @return a valid field name, null if the field name already exists
     */
  private boolean isDuplicate(String name, RecordInfo recordInfo, RecordInfo parent, Element element)
  {
    if (recordInfo.getFieldNames().contains(name)) {
      messager.printMessage(Kind.ERROR,
                            String.format("Field '%s' previously declared in %s: ignoring",
                                          name, recordInfo.getSimpleName()),
                            element);
      return true;
    }
    if (parent != null && parent.getFieldNames().contains(name)) {
      messager.printMessage(Kind.ERROR,
                            String.format("Field '%s' previously declared in %s: ignoring",
                                          name, parent.getSimpleName()),
                            element);
      return true;
    }
    recordInfo.addFieldName(name);
    return false;
  }

    /**
     * Parses the visibility annotations of a field
     * 
     * @param fieldInfo
     *            to store the visibility values
     * @param field
     *            field with the annotations
     * @param schemaContext
     */
    private void parseFieldVisibility(FieldInfo fieldInfo, Element field, SchemaContext schemaContext) {

        Map<Emitted, Visibility> visibilities = visibilitiesParser.parse(field, Emitted.FIELD_AND_ACCESSORS);
        visibilitiesParser.populate(visibilities, Collections.emptyList(), schemaContext.getVisibilities());

        // set the visibility value for each member from the parsed values
        fieldInfo.setFieldVisibility(visibilities.get(Emitted.FIELD));
        fieldInfo.setGetterVisibility(visibilities.get(Emitted.GETTER));
        fieldInfo.setSetterVisibility(visibilities.get(Emitted.SETTER));
        fieldInfo.setModifiersVisibility(visibilities.get(Emitted.MODIFIERS));
        fieldInfo.setIncVisibility(visibilities.get(Emitted.INC));
        fieldInfo.setDecVisibility(visibilities.get(Emitted.DEC));
        fieldInfo.setMulVisibility(visibilities.get(Emitted.MUL));
        fieldInfo.setDivVisibility(visibilities.get(Emitted.DIV));
    }

  public boolean parseStaticFinal(VariableElement field,
                                  RecordInfo recordInfo,
                                  SchemaContext schemaContext)
  {
    if (!field.getModifiers().contains(Modifier.STATIC)
        || !field.getModifiers().contains(Modifier.FINAL))
      {
        return false;
      }
    String name = field.getSimpleName().toString();
    String type = field.asType().toString();
    Map<Emitted, Visibility>
      visibilities = visibilitiesParser.parse(field, Emitted.CONSTANT);
    visibilitiesParser.populate(visibilities, Collections.emptyList(),
                                schemaContext.getVisibilities());
    Visibility visibility = visibilities.get(Emitted.CONSTANT);
    ConstantInfo constInfo = new ConstantInfo(name, type, visibility);
    recordInfo.addConstant(constInfo);
    return true;
  }
}
