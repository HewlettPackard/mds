/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

delimiters "$", "$"
import "usage.stg"
import "type.stg"
import "string.stg"
import "covariant.stg"
package(type) ::= "com.hpl.mds"
class(type) ::= "$type.managedName$Array"

code(type,types) ::= <<
/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

$body(class(type), type, type.managedName, type.boxedName, type.primName, type.fieldName, type.shortName, types)$
>>                      

body(class, type, managed, boxed, prim, field, short, types) ::= <<
package $package(type)$;

import java.util.function.Consumer;

import com.hpl.mds.impl.$short$ArrayType;

import com.hpl.mds.usage.UsageBase;

public interface $class$ extends ManagedArray<$managed$> {
  $type(class, [], [], "ManagedArray", {<$managed$>}, 
        ["ManagedArray", "ManagedOrdered"], {
        
$class$ create(long size);
$class$ create($managed$[] arr);
$class$ create($arg()$[] arr);
$if(type.prim)$
$class$ create($boxed$[] arr);
$endif$

@Override
<RT extends ManagedRecord> $short$ArrayField<RT> fieldIn(RecordType<RT> recType, CharSequence name);
@Override
<RT extends ManagedRecord> $short$ArrayField<RT> findFieldIn(RecordType<RT> recType, CharSequence name);

default $managed$.Type eltType() {
  return $managed$.TYPE;
\}
}, {$short$ArrayType.INSTANCE})$
  
  $arrayUsage(class, "", "ManagedArray", ["ManagedArray", "ManagedOrdered"])$
  
  $covariant(class, [], [], [], {array})$

  static $class$ create(Usage hints) {
    return TYPE.create(hints);
  }
  
  static $class$ create() {
    return TYPE.create();
  }
  
  static $class$ create($managed$[] arr) {
    return TYPE.create(arr);
  }

  static $class$ create($boxed$[] arr) {
    return TYPE.create(arr);
  }

$if(type.prim)$
  static $class$ create($prim$[] arr) {
    return TYPE.create(arr);
  }
$endif$  
  
  static $class$ create(UsageBase<? super ForManaged$short$Array, ?> hints) {
    return create(hints.cast(Usage.class));
  }
  
  
  @Override
  default $managed$.Type eltType() {
    return $managed$.TYPE;
  }
  

$ifString({
  default boolean contains($arg()$ v) {
    return contains(ManagedString.valueOf(v));
  \}
},{
  default boolean contains($managed$ v) {
    return contains($managed$.as$short$(v));
  \}
  default boolean contains($arg()$ v) {
    long s = longSize();
    for (int i=0; i<s; i++) {
      if (get$short$(i) == v) {
        return true;
      \}
    \}
    return false;
  \}
  default void forEach($short$Consumer consumer) {
    final long s = longSize();
    for (long i=0; i<s; i++) {
      consumer.accept(get$short$(i));
    \}
  \} 
})$
  default boolean containsAll($arg()$[] array) {
    for ($arg()$ e : array) {
      if (!contains(e)) {
        return false;
      }
    }
    return true;
  }

  default void forEach$short$(Consumer<? super $above()$> consumer) {
    final long s = longSize();
    for (long i=0; i<s; i++) {
      consumer.accept(get$short$(i));
    }
  } 
  Iterable<$boxed$> $type.shortLower$Elements();
$unlessString({  
//  void replaceAll($short$Modifier operator);
//  void replaceAll($short$IndexedModifier operator);
})$  
//  void replaceAll$short$s(Function<? super $above()$, ? extends $below()$> modifier);

$ifString({
  default $val()$ get$short$(long index) {
    $managed$ v = get(index);
    return ManagedString.asString(v);
  \}
  default $val()$ set(long index, $arg()$ val) {
    return ManagedString.asString(set(index, $managed$.valueOf(val)));
  \}
  default $val()$ getAndSet(long index, $arg()$ val) {
    return ManagedString.asString(getAndSet(index, $managed$.valueOf(val)));
  \}
},{
  @Override
  default $managed$ get(long index) {
    return $managed$.valueOf(get$short$(index));
  \}
  $val()$ get$short$(long index);
  
  @Override
  default $managed$ peek(long index) {
    return $managed$.valueOf(peek$short$(index));
  \}
  $val()$ peek$short$(long index);
  
  $val()$ set(long index, $arg()$ val);
  @Override
  default $managed$ set(long index, $managed$ val) {
    return $managed$.valueOf(set(index, $managed$.as$short$(val)));
  \}
  $val()$ getAndSet(long index, $arg()$ val);
  @Override
  default $managed$ getAndSet(long index, $managed$ val) {
    return $managed$.valueOf(getAndSet(index, $managed$.as$short$(val)));
  \}
  
})$
  
  default $boxed$[] toJavaArray() {
    final $boxed$[] array = new $boxed$[size()];
    for (int i=0; i<array.length; i++) {
      array[i] = get$short$(i);
    }
    return array;
  }
  /*
   * E must be a superclass of $boxed$, but Java doesn't provide a way
   * to say that.
   */  
  default <E> E[] toJavaArray(E[] array) {
    int n = size();
    if (array.length < n) {
      Class<?> componentType = array.getClass().getComponentType();
      @SuppressWarnings("unchecked")
import java.lang.reflect.Array;
      E[] newArray = (E[])Array.newInstance(componentType, n);
      array = newArray;
    }
    for (int i=0; i<n; i++) {
      @SuppressWarnings("unchecked")
      E e = (E)$unlessString({($boxed$)})$get$short$(i);
      array[i] = e;
    }
    if (array.length > n) {
      array[n] = null;
    }
    return array;
  }
  
  default $val()$[] toJavaArray($val()$[] array) {
    final int s = size();
    final $val()$[] a = (array!=null && s <= array.length) ? array : new $val()$[s];
    for (int i=0; i<s; i++) {
      a[i] = get$short$(i);
    }
    return a;
  }
  default $val()$[] to$short$Array($val()$[] array) {
    return toJavaArray(array);
  }
  default $val()$[] to$short$Array() {
    return to$short$Array(null);
  }  
  
  default $val()$[] toArray($val()$[] array) {
    return toJavaArray(array);
  }
  
  /*
   * E can be a superclass of $managed$ or $boxed$ or it can be $prim$.  If it's Object,
   * we use $managed$.
   */  
  default <E> E[] toArray(E[] array) {
    final Class<?> arrayClass = array.getClass();
    final boolean mgd = arrayClass.isAssignableFrom($managed$[].class);
    int n = size();
    if (array.length < n) {
      Class<?> componentType = arrayClass.getComponentType();
      @SuppressWarnings("unchecked")
      E[] newArray = (E[])Array.newInstance(componentType, n);
      array = newArray;
    }
    for (int i=0; i<n; i++) {
      @SuppressWarnings("unchecked")
      E e = mgd ? (E)get(i) : (E)$unlessString({($boxed$)})$get$short$(i);
      array[i] = e;      
    }
    if (array.length > n) {
      array[n] = null;
    }
    return array;
  }
  
  
$if(type.numeric)$
$["inc","dec","mult","div"],
 ["getAndInc","getAndDec","getAndMult","getAndDiv"]:{ func, getAndFunc |
  $prim$ $func$(long index, $prim$ by);
  $prim$ $getAndFunc$(long index, $prim$ by);
  default $managed$ $func$(long index, $managed$ by) {
    return $managed$.valueOf($func$(index, $managed$.as$type.shortName$(by)));
  \}
  default void $func$All($managed$ by) {
    $func$All($managed$.as$short$(by));
  \}
  default void $func$All($prim$ by) {
    final long s = size();
    for (long i=0; i<s; i++) {
      $func$(i, by);
    \}
  \}
}
$
$endif$

$if(type.long)$
import java.util.stream.LongStream;
  default LongStream longStream(long from, long to) {
    return indexStream(from, to).map(this::getLong);
  }
  default LongStream longStream() {
    return longStream(0, longSize());
  }
$endif$
$if(type.int)$
import java.util.stream.IntStream;
  default IntStream intStream(long from, long to) {
    return indexStream(from, to).mapToInt(this::getInt);
  }
  default IntStream intStream() {
    return intStream(0, longSize());
  }
$endif$
$if(type.double)$
import java.util.stream.DoubleStream;
  default DoubleStream doubleStream(long from, long to) {
    return indexStream(from, to).mapToDouble(this::getDouble);
  }
  default DoubleStream doubleStream() {
    return doubleStream(0, longSize());
  }
$endif$

  default java.util.function.LongConsumer $type.shortLower$ElementConsumer(Consumer<? super $above()$> fn) {
    return (i)->fn.accept(get$short$(i));
  }

  default void forEach$short$InTasks(Consumer<? super $above()$> fn) {
    indexStream()
      .forEach(Task.consumer($type.shortLower$ElementConsumer(fn)));
  }

  default void forEach$short$InParallelTasks(Consumer<? super $above()$> fn) {
    indexStream()
      .parallel()
      .forEach(Task.inCurrent(Task.consumer($type.shortLower$ElementConsumer(fn))));
  }


$unlessString({
  default java.util.function.LongConsumer elementConsumer($short$Consumer fn) {
    return (i)->fn.accept(get$short$(i));
  \}
  default java.util.function.LongConsumer $type.shortLower$ElementConsumer($short$Consumer fn) {
    return elementConsumer(fn);
  \}

  default void forEachInTasks($short$Consumer fn) {
    indexStream()
      .forEach(Task.consumer(elementConsumer(fn)));
  \}

  default void forEach$short$InTasks($short$Consumer fn) {
    forEachInTasks(fn);
  \}
  
  default void forEachInParallelTasks($short$Consumer fn) {
    indexStream()
      .parallel()
      .forEach(Task.inCurrent(Task.consumer(elementConsumer(fn))));
  \}

  default void forEach$short$InParallelTasks($short$Consumer fn) {
    forEachInParallelTasks(fn);
  \}
  
})$
}
>>