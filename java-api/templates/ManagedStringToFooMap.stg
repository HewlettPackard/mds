/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

delimiters "$", "$"
import "usage.stg"
import "type.stg"
import "string.stg"
import "covariant.stg"
package(type) ::= "com.hpl.mds.$ifString({string},{prim.container.map})$"
class(type) ::= "ManagedStringTo$type.shortName$Map"

code(type,types) ::= <<
/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

$body(class(type), type, type.managedName, type.boxedName, type.primName, type.fieldName, type.shortName, types)$
>>                      

body(class, type, managed, boxed, prim, field, short, types) ::= <<
package $package(type)$;

import java.util.Map;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;

import com.hpl.mds.ManagedContainer;
import com.hpl.mds.ManagedMap;
import com.hpl.mds.ManagedType;
import com.hpl.mds.$ifString({string},{prim})$.$managed$;
$unlessString({
import com.hpl.mds.function.To$short$Function;
import com.hpl.mds.function.$short$KeyedModifier;
})$
$unlessString({
import com.hpl.mds.string.ManagedString;
})$
import com.hpl.mds.string.ManagedMapFromString;
import com.hpl.mds.usage.UsageBase;


public interface $class$ extends ManagedMapTo$short$<ManagedString>, ManagedMapFromString<$managed$> {
  $type(class, [], [], [{ManagedMapTo$short$}, "ManagedMapFromString"], ["<ManagedString>", {<$managed$>}], 
        [{ManagedMapTo$short$}, "ManagedMapFromString", "ManagedMap", "ManagedContainer"], {
},[])$

  $mapUsage(class, "", [{ManagedMapTo$short$}, "ManagedMapFromString"], [{ManagedMapTo$short$}, "ManagedMapFromString", "ManagedMap", "ManagedContainer"])$

  $covariant(class, [], [], {Map<String,$managed$>}, {map})$

  
  interface UnmanagedMapView extends Map<String, $boxed$> {
    $class$ asManagedMap();

  }

  UnmanagedMapView asUnmanagedMap();
  
    
  static 
  $class$ create(Usage hints) {
    return TYPE.create(hints);
  }
  
  static
  $class$ create() {
    return TYPE.create();
  }
  static
  $class$ create(UsageBase<? super For$class$,?> hints) {
    return create(hints.cast(Usage.class));
  }
  
  static 
  $class$ create(ManagedType<ManagedMap<ManagedString, $managed$>\> type, Usage hints) {
    return create(hints);
  }
  
  static
  $class$ create(ManagedType<ManagedMap<ManagedString,$managed$>\> type) {
    return create();
  }
  static
  $class$ create(ManagedType<ManagedMap<ManagedString,$managed$>\> type, UsageBase<? super For$class$,?> hints) {
    return create(hints.cast(Usage.class));
  }
  
  $val()$ get$short$(CharSequence key);
  $managed$ put(CharSequence key, $arg()$ v);
  $val()$ put$short$(CharSequence key, $managed$ v);
  $val()$ put$short$(CharSequence key, $arg()$ v);

  $managed$ getOrDefault(CharSequence key, $arg()$ defaultVal);
  $val()$ get$short$OrDefault(CharSequence key, $managed$ defaultVal);
  $val()$ get$short$OrDefault(CharSequence key, $arg()$ defaultVal);
  void forEach$short$StringKeys(BiConsumer<? super String, ? super $above()$> action);
  void replaceAll$short$StringKeys(BiFunction<? super String, ? super $above()$, ? extends $below()$> function);
  $managed$ putIfAbsent(CharSequence key, $arg()$ val);
  $val()$ put$short$IfAbsent(CharSequence Key, $managed$ val);
  $val()$ put$short$IfAbsent(CharSequence Key, $arg()$ val);
  boolean remove(CharSequence key, $arg()$ val);
  boolean replace(CharSequence key, $arg()$ oldVal, $arg()$ newVal);  
  boolean replace(CharSequence key, $arg()$ newVal);
$unlessString({
  void replaceAllStringKeys($short$KeyedModifier<? super String> function);
  $prim$ compute$short$IfAbsentStringKey(CharSequence key, To$short$Function<? super String> function);
  $managed$ computeIfAbsentStringKey(CharSequence key, To$short$Function<? super String> function);
})$  
  $val()$ compute$short$IfAbsentStringKey(CharSequence key, Function<? super String, ? extends $below()$> function);
$unlessString({  
  $prim$ compute$short$IfPresentStringKey(CharSequence key, To$short$Function<? super String> function);
  $managed$ computeIfPresentStringKey(CharSequence key, To$short$Function<? super String> function);
})$  
  $val()$ compute$short$IfPresentStringKey(CharSequence key, Function<? super String, ? extends $below()$> function);
  $val()$ compute$short$StringKey(CharSequence key, BiFunction<? super String, ? super $above()$, ? extends $below()$> function);
  $val()$ merge$short$StringKey(CharSequence key, $managed$ v, BiFunction<? super String, ? super $above()$, ? extends $below()$> function);
  $val()$ merge$short$StringKey(CharSequence key, $arg()$ v, BiFunction<? super String, ? super $above()$, ? extends $below()$> function);
    
$if(type.numeric)$
$["inc","dec","mult","div"]:{ func |
  $prim$ $func$$short$(CharSequence key, $prim$ by);
  default $prim$ $func$$short$(CharSequence key, $managed$ by) {
    return $func$$short$(key, $managed$.as$type.shortName$(by));
  \}
  default $managed$ $func$(CharSequence key, $prim$ by) {
    return $managed$.valueOf($func$$short$(key, by));
  \}
  default $managed$ $func$(CharSequence key, $managed$ by) {
    return $managed$.valueOf($func$$short$(key, $managed$.as$type.shortName$(by)));
  \}
}
$
$endif$  
  }
>>