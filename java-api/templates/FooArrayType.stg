/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

delimiters "$", "$"
import "string.stg"
package(type) ::= "com.hpl.mds.impl"
class(type) ::= "$type.shortName$ArrayType"

code(type,types) ::= <<
/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

$body(class(type), type, type.managedName, type.boxedName, type.primName, type.arrayFieldName, type.shortName, type.implName, types)$
>>                      

body(class, type, managed, boxed, prim, field, short, impl, types) ::= <<
package $package(type)$;

import com.hpl.mds.*;

public class $class$ implements ManagedTypeImpl<ManagedArray<$managed$>\>, $managed$Array.Type {

  private static final NativeLibraryLoader NATIVE_LIB_LOADER = NativeLibraryLoader.getInstance();
  
  public static $class$ INSTANCE = new $class$();
    
  /**
   * There should only be one instance of any given primitive array type.
   */

  @Override
  public boolean equals(Object other) {
    return other != null;
  }

  @Override
  public int hashCode() {
    return System.identityHashCode(this);
  }
  
  /**
   * @throws UnboundNameException when the name is not bound to anything in this context
   * @throws IncompatibleTypeException when the name is bound to something other than this type
   */
  private static native long lookupHandle(long namespaceHandle, long nameHandle);
  /**
   * @returns false if the name is bound to a sub-namespace in the current context.
   */
  private static native boolean bindHandle(long namespaceHandle, long nameHandle, long valHandle);
  private static native boolean isSameAs(long aHandle, long bHandle);
  private static native long createArrayHandle(long size);

    private $class$() {}
	
	@Override
	public <RT extends ManagedRecord> $field$Proxy<RT> fieldIn(
			RecordType<RT> recType, CharSequence name) {
//    	System.out.println("$class$: fieldIn recType: " + name);
    	return $field$Proxy.in(recType, name);
	}
	
	@Override
	public <RT extends ManagedRecord> $field$Proxy<RT> findFieldIn(
			RecordType<RT> recType, CharSequence name) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public $managed$Array construct(Object... ctorParams) {
		return Stub.notImplemented();
	}
		
  @Override
  public $managed$Array create() {
    return Stub.notImplemented();
  }
  
  @Override
  public $short$ArrayProxy create(long size) {
    long aHndl = createArrayHandle(size);
    return $short$ArrayProxy.fromHandle(aHndl, size);
  }

$if(type.prim)$  
  @Override
  public $short$ArrayProxy create($boxed$[] arr) {
    $short$ArrayProxy a = create(arr.length);
    for (int i=0; i<arr.length; i++) {
      a.set(i, arr[i]);
    }
    return a;
  }
$endif$
  
  @Override
  public $short$ArrayProxy create($arg()$[] arr) {
    $short$ArrayProxy a = create(arr.length);
    for (int i=0; i<arr.length; i++) {
      a.set(i, arr[i]);
    }
    return a;
  }
  
  @Override
  public $short$ArrayProxy create($managed$[] arr) {
    $short$ArrayProxy a = create(arr.length);
    for (int i=0; i<arr.length; i++) {
      a.set(i, arr[i]);
    }
    return a;
  }
  
  @Override
  public $short$ArrayProxy create($managed$Array.Usage hints) {
    return Stub.notImplemented();
  }
  @Override
  public $short$ArrayProxy create(ManagedArray.Usage hints) {
    return Stub.notImplemented();
  }
  @Override
  public $short$ArrayProxy create(ManagedOrdered.Usage hints) {
    return Stub.notImplemented();
  }
	
	
  @Override
  public ManagedArray.Type<ManagedArray<$managed$>\> inArray() {
    return Stub.notImplemented(); 
  }
    
  @Override
  public ManagedList.Type<ManagedArray<$managed$>\> inList() {
    return Stub.notImplemented(); 
  }

  @Override
  public ManagedSet.Type<ManagedArray<$managed$>\> inSet() {
    return Stub.notImplemented(); 
  }

  @Override
  public <K extends ManagedObject> ManagedMap.Type<K, ManagedArray<$managed$>\> inMapFrom(ManagedType<K> keyType) {
    return Stub.notImplemented(); 
  }

  @Override
  public ManagedMapFromString.Type<ManagedArray<$managed$>\> inMapFromString() {
    return inMapFrom(ManagedString.TYPE);
  }

  /**
   * @return null if the name is unbound in this context
   * @throws IncompatibleTypeException when the name is bound to something other than this type
   */
  @Override
  public $managed$Array lookupName(Namespace ns, CharSequence name) {
    NamespaceProxy nsp = (NamespaceProxy)ns;
    ManagedStringProxy msp = ManagedStringProxy.valueOf(name);
    
    long ah = lookupHandle(nsp.handleIndex(), msp.handleIndex());  
    return $short$ArrayProxy.fromHandle(ah);
  }
  
 @Override
  public ManagedArray<$managed$> bindIn(Namespace ns, CharSequence name, ManagedArray<$managed$> val, Prior prior) {
    /*
     * TODO: Prior is unused
     */
    NamespaceProxy nsp = (NamespaceProxy)ns;
    ManagedStringProxy msp = ManagedStringProxy.valueOf(name);
    $short$ArrayProxy ap = ($short$ArrayProxy)val;
    
    boolean worked = bindHandle(nsp.handleIndex(), msp.handleIndex(), ap.handleIndex());
    if (!worked) {
      throw new BoundToNamespaceException(ns, name);
    }
    return val;
  }

	
	
}
>>