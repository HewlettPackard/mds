/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

delimiters "$", "$"
import "string.stg"
package() ::= "com.hpl.mds"
class() ::= "IsolationContext"

code(types) ::= <<
/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

$contents(types.primTypes, types.maskedTypes, types)$
>>

comma(f) ::= "$if(f)$, $endif$"


functionals(imprt, tvars, rtype, ftype, tbounds, formals, actuals, apply, return) ::= <<
$if(imprt)$
import $imprt$;
$endif$
// Functions for $ftype$
  default $tvars$ $rtype$ call($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    try (Use use = use()) {
      $return$ fn.$apply$;
    }
  }
  
  default $tvars$ IsolationContext run($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    call(fn$comma(actuals)$$actuals$);
    return this;
  } 
  
  default $tvars$ PubResult runThenPublish(PubOption opts, $ftype$$tbounds$ fn$comma(formals)$$formals$) {
    call(fn$comma(actuals)$$actuals$);
    return publish(opts);
  } 
  
  default $tvars$ PubResult runThenPublish($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    return runThenPublish(PubOption.defaultOpts(), fn$comma(actuals)$$actuals$);
  }
  
  default $tvars$ $ftype$$tvars$ bind($ftype$$tbounds$ fn) {
    return ($actuals$) -> IsolationContext.this.call(fn$comma(actuals)$$actuals$);
  } 
  
  static $tvars$ $ftype$$tvars$ bindToCurrent($ftype$$tbounds$ fn) {
    return current().bind(fn);
  }

  default $tvars$ $rtype$ callIsolated($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ callIsolated(PubOption.defaultOpts(), fn$comma(actuals)$$actuals$);
  }
  
  static $tvars$ $rtype$ isolated(PubOption opts, $ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ current().callIsolated(opts, fn$comma(actuals)$$actuals$);
  }
  static $tvars$ $rtype$ isolated($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ isolated(PubOption.defaultOpts(), fn$comma(actuals)$$actuals$);
  }


  default $tvars$ $rtype$ callDetached($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ createNestedDetached().call(fn$comma(actuals)$$actuals$);
  }
  static $tvars$ $rtype$ detached($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ current().callDetached(fn$comma(actuals)$$actuals$);
  }

  default $tvars$ $rtype$ callInReadOnlySnapshot($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ createReadOnlySnapshot().call(fn$comma(actuals)$$actuals$);
  }
  static $tvars$ $rtype$ inReadOnlySnapshot($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ current().callInReadOnlySnapshot(fn$comma(actuals)$$actuals$);
  }
>>

contents(prims, masked, types) ::= <<
package $package()$;

import java.util.Arrays;
import java.util.Collection;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;

import com.hpl.mds.impl.IsoContextProxy;
import com.hpl.mds.impl.Stub;


public interface IsolationContext {
  interface Use extends AutoCloseable {
    void close();
  }
  
  enum ViewType {
      Live, Snapshot
  }
  
  enum ModificationType {
      Full, Detached, ReadOnly
  }
  
  boolean isPublishable();
  boolean isReadOnly();
  boolean isSnapshot();
  boolean hasConflicts();
  
  static IsolationContext current() {
    return IsoContextProxy.current();
  }
  
  static IsolationContext global() {
    return IsoContextProxy.global();
  }
  
  static IsolationContext forProcess() {
    return IsoContextProxy.forProcess();
  }
  
  IsolationContext createNested(ViewType vt, ModificationType mt);
  default IsolationContext createNested(ModificationType mt) {
      return createNested(ViewType.Live, mt);
  }
  default IsolationContext createSnapshot(ModificationType mt) {
      return createNested(ViewType.Snapshot, mt);
  }
  default IsolationContext createNested() {
      return createNested(ViewType.Live, ModificationType.Full);
  }
  default IsolationContext createSnapshot() {
      return createNested(ViewType.Snapshot, ModificationType.Full);
  }
  default IsolationContext createNestedDetached() {
      return createNested(ViewType.Live, ModificationType.Detached);
  }
  default IsolationContext createDetachedSnapshot() {
      return createNested(ViewType.Snapshot, ModificationType.Detached);
  }
  default IsolationContext createNestedReadOnly() {
      return createNested(ViewType.Live, ModificationType.ReadOnly);
  }
  default IsolationContext createReadOnlySnapshot() {
      return createNested(ViewType.Snapshot, ModificationType.ReadOnly);
  }
  
  
  static IsolationContext nestedFromCurrent(ViewType vt, ModificationType mt) {
    return current().createNested(vt, mt);
  }
  static IsolationContext nestedFromCurrent(ModificationType mt) {
    return nestedFromCurrent(ViewType.Live, mt);
  }
  static IsolationContext snapshotFromCurrent(ModificationType mt) {
      return nestedFromCurrent(ViewType.Snapshot, mt);
  }
  static IsolationContext nestedFromCurrent() {
    return nestedFromCurrent(ViewType.Live, ModificationType.Full);
  }
  static IsolationContext snapshotFromCurrent() {
      return nestedFromCurrent(ViewType.Snapshot, ModificationType.Full);
  }
  static IsolationContext nestedDetachedFromCurrent() {
    return nestedFromCurrent(ViewType.Live, ModificationType.Detached);
  }
  static IsolationContext detachedSnapshotFromCurrent() {
      return nestedFromCurrent(ViewType.Snapshot, ModificationType.Detached);
  }
  static IsolationContext nestedReadOnlyFromCurrent() {
    return nestedFromCurrent(ViewType.Live, ModificationType.ReadOnly);
  }
  static IsolationContext readOnlySnapshotFromCurrent() {
      return nestedFromCurrent(ViewType.Snapshot, ModificationType.ReadOnly);
  }
  
  IsolationContext parent();
  Task topLevelTask();
  Task creationTask();
  
  Use use();
  
  PubResult publish(PubOption opts);
  default PubResult publish() {
    return publish(PubOption.defaultOpts());
  }

  static PubResult publishCurrent(PubOption opts) {
    return current().publish(opts);
  }
  static PubResult publishCurrent() {
    return current().publish();
  }


  void giveUp();
  static void giveUpCurrent() {
    current().giveUp();
  }


$functionals({java.util.function.Supplier}, {<R>}, {R}, {Supplier}, {<? extends R>}, [], [], {get()}, {return})$    
  <R> R callIsolated(PubOption opts, Supplier<? extends R> func);

$functionals({java.util.function.Consumer}, {<T>}, {void}, {Consumer}, {<? super T>}, {T arg}, {arg}, {accept(arg)}, { })$    
  default <T> boolean callIsolated(PubOption opts, Consumer<? super T> func, T arg) {
      return callIsolated(opts, ()->func.accept(arg));
  }

$functionals({java.util.function.BiConsumer}, {<T1,T2>}, {void}, {BiConsumer}, {<? super T1, ? super T2>}, {T1 arg1, T2 arg2}, {arg1, arg2}, {accept(arg1, arg2)}, { })$    
  default <T1,T2> boolean callIsolated(PubOption opts, BiConsumer<? super T1, ? super T2> func, T1 arg1, T2 arg2) {
      return callIsolated(opts, ()->func.accept(arg1, arg2));
  }

$functionals([], [], {void}, {Runnable}, [], [], [], {run()}, { })$
  default boolean callIsolated(PubOption opts, Runnable func) {
      PublishReport rep = PublishReport.create();
      callIsolated(opts.reportTo(rep), () -> { func.run(); return null; });
      return rep.succeeded();
  }

$functionals({java.util.function.Predicate}, {<T>}, {boolean}, {Predicate}, {<? super T>}, {T arg}, {arg}, {test(arg)}, {return})$    
  default <T> boolean callIsolated(PubOption opts, Predicate<? super T> func, T arg) {
      return callIsolated(opts, () -> func.test(arg));
  }

$functionals({java.util.function.Function}, {<T,R>}, {R}, {Function}, {<? super T, ? extends R>}, {T arg}, {arg}, {apply(arg)}, {return})$    
  default <T,R> R callIsolated(PubOption opts, Function<? super T, ? extends R> func, T arg) {
      return callIsolated(opts, () -> func.apply(arg));
  }

$functionals({java.util.function.BiFunction}, {<T1,T2,R>}, {R}, {BiFunction}, {<? super T1, ? super T2, ? extends R>}, {T1 arg1, T2 arg2}, {arg1, arg2}, 
             {apply(arg1, arg2)}, {return})$    
  default <T1,T2,R> R callIsolated(PubOption opts, BiFunction<? super T1,? super T2, ? extends R> func, T1 arg1, T2 arg2) {
      return callIsolated(opts, () -> func.apply(arg1, arg2));
  }
  
  
$prims: { type |
$functionals([], {<T>}, {$val()$}, {To$type.shortName$Function}, {<? super T>}, {T arg}, {arg}, {applyAs$type.shortName$(arg)}, {return})$    
  default <T> $val()$ callIsolated(PubOption opts, To$type.shortName$Function<? super T> func, T arg) {
      return callIsolated(opts, () -> func.applyAs$type.shortName$(arg));
  \}
  
$functionals([], [], {$val()$}, {$type.shortName$Modifier}, [], {$arg()$ arg}, {arg}, {apply(arg)}, {return})$    
  default $val()$ callIsolated(PubOption opts, $type.shortName$Modifier func, $arg()$ arg) {
      return callIsolated(opts, () -> func.apply(arg));
  \}
  
$functionals([], [], {$val()$}, {$type.shortName$Supplier}, [], [], [], {get()}, {return})$
// No callIsolated for $type.shortName$Supplier.  Just delegate to Supplier<$type.shortName$>.    
  
$functionals([], [], {boolean}, {$type.shortName$Predicate}, [], {$arg()$ arg}, {arg}, {test(arg)}, {return})$    
  default boolean callIsolated(PubOption opts, $type.shortName$Predicate func, $arg()$ arg) {
      return callIsolated(opts, () -> func.test(arg));
  \}
  
  
$functionals([], [], {void}, {$type.shortName$Consumer}, [], {$arg()$ arg}, {arg}, {accept(arg)}, { })$    
  default void callIsolated(PubOption opts, $type.shortName$Consumer func, $arg()$ arg) {
      callIsolated(opts, () -> func.accept(arg));
  \}
  
  

}$


  default <X,R> R callIsolated(PubOption opts,
                               Supplier<? extends X> compute,
                               Function<? super X, ? extends R> get)
  {
    X data = callIsolated(opts, compute);
    return get.apply(data);
  }

  static <X,R> R isolated(PubOption opts,
                          Supplier<? extends X> compute,
                          Function<? super X, ? extends R> get)
  {
    return current().callIsolated(opts, compute, get);
  }

  default <X,R> R callIsolated(Supplier<? extends X> compute,
                               Function<? super X, ? extends R> get)
  {
    return callIsolated(PubOption.defaultOpts(), compute, get);
  }

  static <X,R> R isolated(Supplier<? extends X> compute, Function<? super X, ? extends R> get) {
    return current().callIsolated(compute, get);
  }

  default <R> R callIsolated(PubOption opts, Runnable compute, Supplier<? extends R> get) {
    return callIsolated(opts,
                        ()->{
                          compute.run();
                          return Boolean.FALSE;
                        },
                        b->get.get());
  }

  static <R> R isolated(PubOption opts, Runnable compute, Supplier<? extends R> get) {
    return current().callIsolated(opts, compute, get);
  }

  default <R> R callIsolated(Runnable compute, Supplier<? extends R> get) {
    return callIsolated(PubOption.defaultOpts(), compute, get);
  }

  static <R> R isolated(Runnable compute, Supplier<? extends R> get) {
    return current().callIsolated(compute, get);
  }


  default <X, R> R callIsolated(PubOption opts,
                                X data,
                                Consumer<? super X> compute,
                                Function<? super X, ? extends R> get)
  {
    return callIsolated(opts,
                        ()->{
                          compute.accept(data);
                          return data;
                        },
                        get::apply);
  }

  static <X, R> R isolated(PubOption opts,
                           X data,
                           Consumer<? super X> compute,
                           Function<? super X, ? extends R> get)
  {
    return current().callIsolated(opts, data, compute, get);
  }

  default <X, R> R callIsolated(X data,
                                Consumer<? super X> compute,
                                Function<? super X, ? extends R> get)
  {
    return callIsolated(PubOption.defaultOpts(), data, compute, get);
  }

  static <X, R> R isolated(X data,
                           Consumer<? super X> compute,
                           Function<? super X, ? extends R> get)
  {
    return current().callIsolated(data, compute, get);
  }

  /*
   * The after-publish hooks are run after, respectively, a successful or failed publication attempt.
   */

  /*
   * The after-publish hooks are run after, respectively, a successful
   * or failed publication attempt, where failure means that conflict
   * resolution has also been abandoned.  The hooks are run in the
   * context's "creation task".  That is, the task that was the
   * current task when the context was created.
   */

  void afterSuccessfulPublish(Consumer<? super IsoContextProxy> fn);
  void afterFailedPublish(Consumer<? super IsoContextProxy> fn);
  default void afterPublishAttempt(Consumer<? super IsoContextProxy> fn) {
    afterSuccessfulPublish(fn);
    afterFailedPublish(fn);
  }

  default void afterSuccessfulPublish(Runnable fn) {
    afterSuccessfulPublish(c->fn.run());
  }

  default void afterFailedPublish(Runnable fn) {
    afterFailedPublish(c->fn.run());
  }

  default void afterPublishAttempt(Runnable fn) {
    afterPublishAttempt(c->fn.run());
  }

// -----  
// These haven't made it into the document yet.
  
  <T extends ManagedObject> InContext<T> viewOf(T val);
  
  <T extends ManagedObject> InContext<T> viewOf(Supplier<? extends T> gen);

  static <T extends ManagedObject> InContext<T> currentViewOf(T val) {
    // TODO
    return Stub.notImplemented();
  }

}
>>
