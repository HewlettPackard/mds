/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

delimiters "$", "$"
import "string.stg"
package(type) ::= "com.hpl.mds.impl"
class(type) ::= "$type.shortName$ArrayProxy"

code(type,types) ::= <<
/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

$body(class(type), type, type.managedName, type.boxedName, type.primName, type.fieldName, type.shortName, type.jniName, types)$
>>                      

body(class, type, managed, boxed, prim, field, short, jni, types) ::= <<
package $package(type)$;

import java.util.Iterator;
import com.hpl.mds.*;

public class $class$ extends ArrayProxy<$managed$> implements $managed$Array {

    private static final NativeLibraryLoader NATIVE_LIB_LOADER = NativeLibraryLoader.getInstance();
    
    private static native void release(long handle);
    private static native boolean isIdentical(long aHandle, long bHandle);
    private static native boolean isSameObject(long aHandle, long bHandle);
    private static native boolean isSameViewOfSameObject(long aHandle, long bHandle);
    private static native long createArray(long size);
    
    private static native $jniArg()$ get$whenString({Handle})$(long handle, long index);
    private static native $jniArg()$ peek$whenString({Handle})$(long handle, long index);
    private static native $jniArg()$ set$whenString({Handle})$(long handle, long index, $jniArg()$ val);
    private static native $jniArg()$ getAndSet$whenString({Handle})$(long handle, long index, $jniArg()$ val);
    private static native long size(long handle);
$if(type.numeric)$
$["inc","dec","mult","div",
 "getAndInc","getAndDec","getAndMult","getAndDiv"]:{ func |
    private static native $jniArg()$ $func$Value(long handle, long index, $jniArg()$ val);
}
$
$endif$	
    
  @Override
  void releaseHandleIndex(long index) {
    release(index); 
  }
    
  public enum FromHandle { FROM_HANDLE };
  
  protected $class$(FromHandle kwd, long handle, long size) {
    super(handle, size);
  }
  protected $class$(FromHandle kwd, long handle) {
    this(kwd, handle, -1);
  }
  
  public $class$(long size) {
    this(FromHandle.FROM_HANDLE, createArray(size), size);
  }
  
//  public $class$() {
//    // Sergei had this, but it doesn't make any sense.
//    this(-1);
//  }

  @Override
  public $short$ArrayType type() {
    return $short$ArrayType.INSTANCE;
  }    
    
  @Override
  public $managed$.Type eltType() {
    return $managed$.TYPE;
  }
  
  @Override
  public long longSize() {
    if (size == -1) {
      size = size(handleIndex());
    }
    return size;
  }
  
  @Override
  public boolean isIdentical(ManagedComposite other) {
    if (other == this) {
      return true;
    } else if (other == null) {
      return false;
    } else if (!(other instanceof $class$)) {
      return false;
    }
    $class$ dc = ($class$)other;
    return isIdentical(handleIndex(), dc.handleIndex());
  }

  @Override
  public boolean isSameObject(ManagedComposite other) {
    if (other == this) {
      return true;
    } else if (other == null) {
      return false;
    } else if (!(other instanceof $class$)) {
      return false;
    }
    $class$ dc = ($class$)other;
    return isSameObject(handleIndex(), dc.handleIndex());
  }

  @Override
  public boolean isSameViewOfSameObject(ManagedComposite other) {
    if (other == this) {
      return true;
    } else if (other == null) {
      return false;
    } else if (!(other instanceof $class$)) {
      return false;
    }
    $class$ dc = ($class$)other;
    return isSameViewOfSameObject(handleIndex(), dc.handleIndex());
  }

$ifString({  
  @Override
  public $managed$ get(long index) {
    return $managed$Proxy.fromHandle(getHandle(handleIndex(), index));
  \}
  @Override
  public $managed$ peek(long index) {
    return $managed$Proxy.fromHandle(peekHandle(handleIndex(), index));
  \}
  @Override
  public $managed$ set(long index, $managed$ val) {
    long old = setHandle(handleIndex(), index, (($managed$Proxy)val).handleIndex());
    return $managed$Proxy.fromHandle(old);
  \}
  @Override
  public $managed$ getAndSet(long index, $managed$ val) {
    long old = getAndSetHandle(handleIndex(), index, (($managed$Proxy)val).handleIndex());
    return $managed$Proxy.fromHandle(old);
  \}
}, {
  @Override
  public $prim$ get$short$(long index) {
    return get(handleIndex(), index);
  \}
  @Override
  public $prim$ peek$short$(long index) {
    return peek(handleIndex(), index);
  \}
  @Override
  public $val()$ set(long index, $arg()$ val) {
    return set(handleIndex(), index, val);
  \}
  @Override
  public $val()$ getAndSet(long index, $arg()$ val) {
    return getAndSet(handleIndex(), index, val);
  \}
  
})$
  
$if(type.numeric)$
$["inc","dec","mult","div",
  "getAndInc","getAndDec","getAndMult","getAndDiv"]:{ func |
  @Override
  public $prim$ $func$(long index, $prim$ by) {
    return $func$Value(handleIndex_, index, by);
  \}
}
$
$endif$  
  
  @Override
  public Iterator<$managed$> iterator() {
    final long s = longSize();
    return new Iterator<$managed$>() {
      long i = 0;
      public boolean hasNext() {
        return i<s;
      }
      
      public $managed$ next() {
        return get(i++);
      }
    };
  }
  
  @Override
  public Iterable<$boxed$> $type.shortLower$Elements() {
    final long s = longSize();
    return ()->new Iterator<$boxed$>() {
      long i = 0;
      public boolean hasNext() {
        return i<s;
      }
      
      public $boxed$ next() {
        return get$short$(i++);
      }
    };
  }
  
  
  
  @Override
  public $class$ bindName(Prior prior, Namespace ns, CharSequence name) {
    return ($class$)type().bindIn(ns, name, this, prior);
  }
  
  static 
  $class$ fromHandle(long handle, long size) {
    return new $class$(FromHandle.FROM_HANDLE, handle, size);
  }      

  static 
  $class$ fromHandle(long handle) {
    return fromHandle(handle, -1);
  }
  
  public static long handleOf(ManagedArray<$managed$> arr) {
    $class$ p = ($class$)arr;
    return p == null ? 0 : p.handleIndex();  
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    String sep = "[";
    for ($val()$ elt : $type.shortLower$Elements()) {
      sb.append(sep);
      sb.append(elt);
      sep = ", ";
    }
    sb.append("]");
    return sb.toString();
  }

  @Override
  public $class$ using($managed$Array.Usage hint) {
    return Stub.notImplemented();
  }

  @Override
  public $class$ inherentUsage($managed$Array.Usage hint) {
    return Stub.notImplemented();
  }

  import com.hpl.mds.usage.UsageScope;
  @Override
  public $class$ usageDuring(UsageScope scope, $managed$Array.Usage hint) {
    return Stub.notImplemented();
  }

  import com.hpl.mds.usage.UsagePlan;
  @Override
  public UsagePlan usagePlan($managed$Array.Usage hint) {
    return Stub.notImplemented();
  }

}

>>
