/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

delimiters "$", "$"
import "string.stg"
package() ::= "com.hpl.mds"
class() ::= "MDS"

code(types) ::= <<
/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

$contents(types.primTypes, types.maskedTypes, types)$
>>

comma(f) ::= "$if(f)$, $endif$"


functionals(imprt, tvars, rtype, ftype, tbounds, formals, actuals, apply, return) ::= <<
$if(imprt)$
import $imprt$;
$endif$
  // Isolation Context statics for $ftype$

  static $tvars$ $rtype$ isolated(PubOption opts, $ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ IsolationContext.isolated(opts, fn$comma(actuals)$$actuals$);
  }
  static $tvars$ $rtype$ isolated($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ isolated(PubOption.defaultOpts(), fn$comma(actuals)$$actuals$);
  }
  static $tvars$ $rtype$ detached($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ IsolationContext.detached(fn$comma(actuals)$$actuals$);
  }
  static $tvars$ $rtype$ inReadOnlySnapshot($ftype$$tbounds$ fn$comma(formals)$$formals$) {
    $return$ IsolationContext.inReadOnlySnapshot(fn$comma(actuals)$$actuals$);
  }
>>

contents(prims, masked, types) ::= <<
package $package()$;

import java.util.Collection;

/**
 * Interface to hold static methods so that users can type
 *   
 *  import static MDS.*;
 *
 */
public interface MDS {
  public static void ensureKnown(RecordType<?>...types) {
    RecordType.ensureKnown(types);
  }



$functionals({java.util.function.Supplier}, {<R>}, {R}, {Supplier}, {<? extends R>}, [], [], {get()}, {return})$    

$functionals({java.util.function.Consumer}, {<T>}, {void}, {Consumer}, {<? super T>}, {T arg}, {arg}, {accept(arg)}, { })$    

$functionals({java.util.function.BiConsumer}, {<T1,T2>}, {void}, {BiConsumer}, {<? super T1, ? super T2>}, {T1 arg1, T2 arg2}, {arg1, arg2}, {accept(arg1, arg2)}, { })$    

$functionals([], [], {void}, {Runnable}, [], [], [], {run()}, { })$

$functionals({java.util.function.Predicate}, {<T>}, {boolean}, {Predicate}, {<? super T>}, {T arg}, {arg}, {test(arg)}, {return})$    

$functionals({java.util.function.Function}, {<T,R>}, {R}, {Function}, {<? super T, ? extends R>}, {T arg}, {arg}, {apply(arg)}, {return})$    

$functionals({java.util.function.BiFunction}, {<T1,T2,R>}, {R}, {BiFunction}, {<? super T1, ? super T2, ? extends R>}, {T1 arg1, T2 arg2}, {arg1, arg2}, 
             {apply(arg1, arg2)}, {return})$

static <X,R> R isolated(PubOption opts,
                        Supplier<? extends X> compute,
                        Function<? super X, ? extends R> get)
{
  return IsolationContext.isolated(opts, compute, get);
}

static <X,R> R isolated(Supplier<? extends X> compute, Function<? super X, ? extends R> get)
{
  return IsolationContext.isolated(compute, get);
}

static <R> R isolated(PubOption opts, Runnable compute, Supplier<? extends R> get) {
  return IsolationContext.isolated(opts, compute, get);
}

static <R> R isolated(Runnable compute, Supplier<? extends R> get) {
  return IsolationContext.isolated(compute, get);
}

static <X, R> R isolated(PubOption opts,
                         X data,
                         Consumer<? super X> compute,
                         Function<? super X, ? extends R> get)
{
  return IsolationContext.isolated(opts, data, compute, get);
}

static <X, R> R isolated(X data,
                         Consumer<? super X> compute,
                         Function<? super X, ? extends R> get)
{
  return IsolationContext.isolated(data, compute, get);
}



  static Task currentTask() {
    return Task.current();
  }

  static void asTask(Runnable fn) {
    Task.asTask(fn);
  }

  static void asTask(Supplier<?> fn) {
    Task.asTask(fn);
  }

}
>>
