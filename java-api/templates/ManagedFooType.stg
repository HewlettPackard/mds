/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

delimiters "$", "$"
import "string.stg"
package(type) ::= "com.hpl.mds.impl"
class(type) ::= "$type.managedName$Type"

code(type,types) ::= <<
/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

$body(class(type), type, type.managedName, type.boxedName, type.primName, type.fieldName, type.shortName, type.implName, types)$
>>                      

body(class, type, managed, boxed, prim, field, short, impl, types) ::= <<
package $package(type)$;

import com.hpl.mds.*;



public class $class$ implements ManagedTypeImpl<$managed$>, $managed$.Type {

  private static final NativeLibraryLoader NATIVE_LIB_LOADER = NativeLibraryLoader.getInstance();
  
  public static $class$ INSTANCE = new $class$();

  /**
   * There should only be one instance of any given primitive type.
   */

  @Override
  public boolean equals(Object other) {
    return other != null;
  }

  @Override
  public int hashCode() {
    return System.identityHashCode(this);
  }
  
    
  /**
   * @throws UnboundNameException when the name is not bound to anything in this context
   * @throws IncompatibleTypeException when the name is bound to something other than this type
   */
  private static native $jniArg()$ lookup$whenString({Handle})$(long namespaceHandle, long nameHandle);
  /**
   * @returns false if the name is bound to a sub-namespace in the current context.
   */
  private static native boolean bindIn(long namespaceHandle, long nameHandle, $jniArg()$ val);

    private $class$() {}
	
	@Override
	public <RT extends ManagedRecord> $field$<RT> fieldIn(
			RecordType<RT> recType, CharSequence name) {
//    	System.out.println("$class$: fieldIn recType: " + name);
    	return $field$Proxy.in(recType, name);
	}
	
	@Override
	public <RT extends ManagedRecord> $field$<RT> findFieldIn(
			RecordType<RT> recType, CharSequence name) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public $managed$ construct(Object... ctorParams) {
		// TODO Auto-generated method stub
		return null;
	}
		
	
	
  @Override
  public $managed$Array.Type inArray() {
    return $managed$.Type.super.inArray();
  }
    
  @Override
  public $managed$List.Type inList() {
    return $managed$.Type.super.inList();
  }

  @Override
  public $managed$Set.Type inSet() {
    return $managed$.Type.super.inSet();
  }

  @Override
  public <K extends ManagedObject> ManagedMapTo$short$.Type<K> inMapFrom(ManagedType<K> keyType) {
    return $managed$.Type.super.inMapFrom(keyType);
  }

  @Override
  public ManagedStringTo$short$Map.Type inMapFromString() {
    return $managed$.Type.super.inMapFromString();
  }

  /**
   * @return null if the name is unbound in this context
   * @throws IncompatibleTypeException when the name is bound to something other than this type
   */
  @Override
  public $impl$ lookupName(Namespace ns, CharSequence name) {
    try {
$ifString({
      NamespaceProxy nsp = (NamespaceProxy)ns;
      ManagedStringProxy msp = ManagedStringProxy.valueOf(name);
      return $fromJNI({lookupHandle(nsp.handleIndex(), msp.handleIndex())})$;
},{
      return $impl$.valueOf(lookupNameAs$short$(ns, name));
})$      
    } catch (UnboundNameException ex) {
      return null;
    }
  }
  
  
  /**
   * @throws IncompatibleTypeException when the name is bound to something other than this type
   */
  @Override
  public $val()$ lookupNameAs$short$(Namespace ns, CharSequence name) {
$ifString({
    return ManagedString.asString(lookupName(ns, name));
},{
    NamespaceProxy nsp = (NamespaceProxy)ns;
    ManagedStringProxy msp = ManagedStringProxy.valueOf(name);
    
    return lookup(nsp.handleIndex(), msp.handleIndex());
})$    
  }
	
 @Override
  public $val()$ bindIn(Namespace ns, CharSequence name, $arg()$ val, Prior prior) {
    /*
     * TODO: Prior is unused
     */
    NamespaceProxy nsp = (NamespaceProxy)ns;
    ManagedStringProxy msp = ManagedStringProxy.valueOf(name);
    
    boolean worked = bindIn(nsp.handleIndex(), msp.handleIndex(), $toJNI({val})$);
    if (!worked) {
      throw new BoundToNamespaceException(ns, name);
    }
    return val$whenString({.toString()})$;
  }

	
	
}
>>