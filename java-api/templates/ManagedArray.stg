/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

delimiters "$", "$"
import "usage.stg"
import "type.stg"
import "covariant.stg"
import "string.stg"
package() ::= "com.hpl.mds"
class() ::= "ManagedArray"

code(types) ::= <<
/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

$contents(types.primTypes, types.maskedTypes, types)$
>>

contents(prims, masked, types) ::= <<
package $package()$;

import java.util.Collection;

import com.hpl.mds.usage.Operation;
import com.hpl.mds.usage.UsageBase;
import com.hpl.mds.usage.UsageMode;
import com.hpl.mds.impl.Stub;



public interface ManagedArray<T extends ManagedObject> extends ManagedOrdered<T> {
$masked: { type |
  static final Managed$type.shortName$Array.Type OF_$type.shortUpper$_TYPE = Managed$type.shortName$Array.TYPE;
}
$

  // su - length will be added in to each implementor of ManagedArray by the template
  // public final int length;
  
  static final Operation<ForManagedArray> GET = Stub.notImplemented();
  static final Operation<ForManagedArray> SET = Stub.notImplemented();
  static final Operation<ForManagedArray> TO_JAVA_ARRAY = Stub.notImplemented();
  static final Operation<ForManagedArray> SIZEOF = Stub.notImplemented();
  
  $type("ManagedArray", "T", "ManagedObject", "ManagedOrdered", "<T, ManagedArray<T>\>", 
        ["ManagedOrdered"], {
ManagedArray<T> create(long size);
ManagedArray<T> create(T[] arr);
@Override
<RT extends ManagedRecord> ArrayField<RT,T> fieldIn(RecordType<RT> recType, CharSequence name);
@Override
<RT extends ManagedRecord> ArrayField<RT,T> findFieldIn(RecordType<RT> recType, CharSequence name);
}, [])$
  $arrayUsage("ManagedArray", "<T>", "ManagedOrdered", ["ManagedOrdered"])$

  static <T extends ManagedObject> 
  ManagedArray<T> of(ManagedType<T> eltType, Usage hints) {
    return eltType.createArray(hints);
  }

  static <T extends ManagedObject> 
  ManagedArray<T> of(ManagedType<T> eltType, long size) {
    return eltType.createArray(size);
  }

  static <T extends ManagedObject>
  ManagedArray<T> of(ManagedType<T> eltType, UsageBase<? super ForManagedArray, ?> hints) {
    return ManagedArray.of(eltType, hints.cast(Usage.class));
  }
  
$masked: { type |
    static Managed$type.shortName$Array of($type.managedName$.Type type, long size) {
      return OF_$type.shortUpper$_TYPE.create(size);
    \}
}
$

$masked: { type |
    static Managed$type.shortName$Array of($type.managedName$.Type type, UsageBase<? super Managed$type.shortName$Array.ForManaged$type.shortName$Array,?> hints) {
      return OF_$type.shortUpper$_TYPE.create(hints.cast(Managed$type.shortName$Array.Usage.class));
    \}
}
$

$masked: { type |
    static Managed$type.shortName$Array of$type.shortName$(long size) {
      return OF_$type.shortUpper$_TYPE.create(size);
    \}
}
$

$masked: { type |
    static Managed$type.shortName$Array of$type.shortName$(UsageBase<? super Managed$type.shortName$Array.ForManaged$type.shortName$Array,?> hints) {
      return OF_$type.shortUpper$_TYPE.create(hints.cast(Managed$type.shortName$Array.Usage.class));
    \}
}
$

  
  static <T extends ManagedObject>
  ManagedArray<T> create(ManagedType<ManagedArray<T>\> type, Usage hints) {
    return ((Type<T>)type).create(hints);
  }
  static <T extends ManagedObject>
  ManagedArray<T> create(ManagedType<ManagedArray<T>\> type) {
    return ((Type<T>)type).create();
  }
  static <T extends ManagedObject>
  ManagedArray<T> create(ManagedType<ManagedArray<T>\> type, long size) {
    return ((Type<T>)type).create(size);
  }
  static <T extends ManagedObject>
  ManagedArray<T> create(ManagedType<ManagedArray<T>\> type, UsageBase<? super ForManagedArray, ?> hints) {
    return ManagedArray.create(type, hints.cast(Usage.class));
  }
  
    
$masked: { type |
    static Managed$type.shortName$Array create($type.managedName$Array.Type type) {
      return OF_$type.shortUpper$_TYPE.create();
    \}
    static Managed$type.shortName$Array create($type.managedName$Array.Type type, long size) {
      return OF_$type.shortUpper$_TYPE.create(size);
    \}
}
$

$masked: { type |
    static Managed$type.shortName$Array create($type.managedName$Array.Type type, UsageBase<? super Managed$type.shortName$Array.ForManaged$type.shortName$Array,?> hints) {
      return OF_$type.shortUpper$_TYPE.create(hints.cast(Managed$type.shortName$Array.Usage.class));
    \}
}
$

  $covariant({ManagedArray}, {T}, {ManagedObject}, [], {array})$

  static <T extends ManagedObject> Type<T> typeContaining(ManagedType<T> type) {
    return type.inArray();
  }
  
  
$masked: { type |
    static Managed$type.shortName$Array.Type typeContaining($type.managedName$.Type type) {
      return OF_$type.shortUpper$_TYPE;
    \}
}
$

$masked: { type |
    static Managed$type.shortName$Array.Type typeContaining$type.shortName$() {
      return OF_$type.shortUpper$_TYPE;
    \}
}
$

  static <T extends ManagedObject> ManagedArray<T> from(ManagedType<T> eltType, T[] array) {
    return eltType.inArray().create(array);
  }
$masked: { type |
  static Managed$type.shortName$Array from($type.managedName$[] array) {
    return OF_$type.shortUpper$_TYPE.create(array);
  \}
$if(type.string)$  
  static Managed$type.shortName$Array from(CharSequence[] array) {
    return OF_$type.shortUpper$_TYPE.create(array);
  \}
$else$  
  static Managed$type.shortName$Array from($type.primName$[] array) {
    return OF_$type.shortUpper$_TYPE.create(array);
  \}
  static Managed$type.shortName$Array from($type.boxedName$[] array) {
    return OF_$type.shortUpper$_TYPE.create(array);
  \}
$endif$  
}
$
  // Actual operations below
  T get(long index);
  T peek(long index);
  T set(long index, T newValue);
  T getAndSet(long index, T newValue);

  default Object[] toArray() {
    int n = size();
    Object[] array = new Object[n];
    for (int i=0; i<n; i++) {
      array[i] = get(i);
    }
    return array;
  }

  /*
   * E must be a superclass of T, but Java doesn't provide a way
   * to say that.
   */  
  default <E> E[] toArray(E[] array) {
    int n = size();
    if (array.length < n) {
      Class<?> componentType = array.getClass().getComponentType();
      @SuppressWarnings("unchecked")
import java.lang.reflect.Array;
      E[] newArray = (E[])Array.newInstance(componentType, n);
      array = newArray;
    }
    for (int i=0; i<n; i++) {
      @SuppressWarnings("unchecked")
      E e = (E)get(i);
      array[i] = e;
    }
    if (array.length > n) {
      array[n] = null;
    }
    return array;
  }

import java.util.function.IntFunction;

  default T[] toArray(IntFunction<T[]> generator) {
    return toArray(generator.apply(size()));
  }

  default boolean contains(T val) {
    long s = longSize();
    for (long i=0; i<s; i++) {
      if (val == get(i)) {
        return true;
      }
    }
    return false;
  }
  
  default boolean contains(T[] array) {
    for (T e : array) {
      if (!contains(e)) {
        return false;
      }
    }
  	return true;
  }

import java.util.stream.Stream;
import java.util.stream.LongStream;

  default LongStream indexStream(long from, long to) {
    return LongStream.range(from, to);
  }

  default LongStream indexStream() {
    return indexStream(0, longSize());
  }

  default Stream<T> stream(long from, long to) { 
	  return indexStream(from, to).mapToObj(this::get);
  }

  default Stream<T> stream() { 
	  return stream(0, longSize());
  }
    


import java.util.function.Consumer;
import java.util.function.LongConsumer;

  default LongConsumer elementConsumer(Consumer<? super T> fn) {
    return (i)->fn.accept(get(i));
  }

  default void forEachInTasks(Consumer<? super T> fn) {
    indexStream()
      .forEach(Task.consumer(elementConsumer(fn)));
  }

  default void forEachInParallelTasks(Consumer<? super T> fn) {
    indexStream()
      .parallel()
      .forEach(Task.inCurrent(Task.consumer(elementConsumer(fn))));
  }
}
>>
