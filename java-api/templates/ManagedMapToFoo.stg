/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

delimiters "$", "$"
import "usage.stg"
import "type.stg"
import "string.stg"
import "covariant.stg"
package(type) ::= "com.hpl.mds"
class(type) ::= "ManagedMapTo$type.shortName$"

code(type,types) ::= <<
/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

$body(class(type), type, type.managedName, type.boxedName, type.primName, type.fieldName, type.shortName, types)$
>>                      

body(class, type, managed, boxed, prim, field, short, types) ::= <<
package $package(type)$;

import java.util.Collection;
import java.util.Map;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;
import com.hpl.mds.impl.Stub;


import com.hpl.mds.usage.UsageBase;

public interface $class$<K extends ManagedObject> extends $ifString({ManagedMap<K,$managed$>},{ManagedMapToPrim<K, $boxed$, $managed$>})$ {
  $type(class, "K", "ManagedObject", "ManagedMap", {<K, $managed$>}, 
        ["ManagedMap", "ManagedContainer"], {
default $managed$.Type valueType() {
  return $managed$.TYPE;
\}
},[])$

  $mapUsage(class, "<K>", "ManagedMap", ["ManagedMap", "ManagedContainer"])$
  
  $covariant(class, {K}, {ManagedObject}, {Map<K,$managed$>}, {map})$
  

  interface UnmanagedValueMapView<K extends ManagedObject> extends $ifString({Map<K,String>},{ManagedMapToPrim.UnmanagedMapView<K, $boxed$, $managed$>})$ {
    $class$<K> asManagedMap();

  }


  $unlessString({@Override  
  })$UnmanagedValueMapView<K> asUnmanagedValueMap();

  static <K extends ManagedObject> 
  $class$<K> mappingFrom(ManagedType<K> keyType) {
    return $managed$.TYPE.createMapFrom(keyType);
  }

  static ManagedStringTo$short$Map mappingFrom(ManagedString.Type keyType) {
    return ManagedStringTo$short$Map.create();
  }

  static <K extends ManagedObject> 
  $class$<K> mappingFrom(ManagedType<K> keyType, Usage hints) {
    return $managed$.TYPE.createMapFrom(keyType, hints);
  }

  static ManagedStringTo$short$Map mappingFrom(ManagedString.Type keyType, ManagedStringTo$short$Map.Usage hints) {
    return ManagedStringTo$short$Map.create(hints);
  }

  static <K extends ManagedObject> 
  $class$<K> mappingFrom(ManagedType<K> keyType, UsageBase<? super ForManagedMapTo$short$,?> hints) {
    return mappingFrom(keyType, hints.cast(Usage.class));
  }

  static ManagedStringTo$short$Map mappingFrom(ManagedString.Type keyType, UsageBase<? super ManagedStringTo$short$Map.ForManagedStringTo$short$Map, ?> hints) {
    return ManagedStringTo$short$Map.create(hints);
  }

  static <K extends ManagedObject> 
  $class$<K> mapping(ManagedType<K> keyType, ManagedType<$managed$> valType, Usage hints) {
    return mappingFrom(keyType, hints);
  }

  static ManagedStringTo$short$Map mapping(ManagedString.Type keyType, ManagedType<$managed$> valType, ManagedStringTo$short$Map.Usage hints) {
    return ManagedStringTo$short$Map.create(hints);
  }

  static <K extends ManagedObject> 
  $class$<K> mapping(ManagedType<K> keyType, ManagedType<$managed$> valType) {
    return mappingFrom(keyType);
  }

  static ManagedStringTo$short$Map mapping(ManagedString.Type keyType, ManagedType<$managed$> valType) {
    return ManagedStringTo$short$Map.create();
  }

  static <K extends ManagedObject> 
  $class$<K> mapping(ManagedType<K> keyType, ManagedType<$managed$> valType, UsageBase<? super ForManagedMapTo$short$,?> hints) {
    return mappingFrom(keyType, hints.cast(Usage.class));
  }
  
  static ManagedStringTo$short$Map mapping(ManagedString.Type keyType, ManagedType<$managed$> valType, UsageBase<? super ManagedStringTo$short$Map.ForManagedStringTo$short$Map, ?> hints) {
    return ManagedStringTo$short$Map.create(hints);
  }

  static <K extends ManagedObject>
  $class$<K> create(ManagedType<ManagedMap<K,$managed$>\> type) {
    final Type<K> dcType = (Type<K>)type;
    return dcType.create();
  }
  
  static ManagedStringTo$short$Map create(ManagedStringTo$short$Map.Type type) {
    return ManagedStringTo$short$Map.create();
  }

  static <K extends ManagedObject>
  $class$<K> create(ManagedType<ManagedMap<K, $managed$>\> type, Usage hints) {
    final Type<K> dcType = (Type<K>)type;
    return dcType.create(hints);
  }
  
  static ManagedStringTo$short$Map create(ManagedStringTo$short$Map.Type type, ManagedStringTo$short$Map.Usage hints) {
    return ManagedStringTo$short$Map.create(hints);
  }

  static <K extends ManagedObject>
  $class$<K> create(ManagedType<ManagedMap<K,$managed$>\> type, UsageBase<? super ForManagedMapTo$short$,?> hints) {
    return create(type, hints.cast(Usage.class));
  }
  
  static ManagedStringTo$short$Map create(ManagedStringTo$short$Map.Type type, UsageBase<? super ManagedStringTo$short$Map.ForManagedStringTo$short$Map, ?> hints) {
    return ManagedStringTo$short$Map.create(hints);
  }

  
    
  static <K extends ManagedObject> 
  Type<K> typeMappingFrom(ManagedType<K> keyType) {
    // TODO
    return Stub.notImplemented();
  }
  static <K extends ManagedObject> 
  Type<K> typeMapping(ManagedType<K> keyType, ManagedType<$managed$> valType) {
    return typeMappingFrom(keyType);
  }
  
  static ManagedStringTo$short$Map.Type typeMappingFrom(ManagedString.Type keyType) {
    return ManagedStringTo$short$Map.TYPE;
  }
  static ManagedStringTo$short$Map.Type typeMapping(ManagedString.Type keyType, ManagedType<$managed$> valType) {
    return ManagedStringTo$short$Map.TYPE;
  }
  
  
  @Override
  default $managed$.Type valueType() {
    return $managed$.TYPE;
  }

  boolean containsValue($arg()$ v);
  $val()$ get$short$(K key);
  $managed$ put(K key, $arg()$ v);
  $val()$ put$short$(K key, $managed$ v);
  $val()$ put$short$(K key, $arg()$ v);
  Collection<$boxed$> $type.shortLower$Values();
  $managed$ getOrDefault(K key, $arg()$ defaultVal);
  $val()$ get$short$OrDefault(K key, $managed$ defaultVal);
  $val()$ get$short$OrDefault(K key, $arg()$ defaultVal);
  void forEach$short$(BiConsumer<? super K, ? super $above()$> action);
$unlessString({  
  void replaceAll($short$Modifier function);
  void replaceAll($short$KeyedModifier<? super K> function);
})$  
  void replaceAll$short$s(BiFunction<? super K, ? super $above()$, ? extends $below()$> function);
  void replaceAll$short$s(Function<? super $above()$, ? extends $below()$> function);
  $managed$ putIfAbsent(K key, $arg()$ val);
  $val()$ put$short$IfAbsent(K Key, $managed$ val);
  $val()$ put$short$IfAbsent(K Key, $arg()$ val);
  boolean remove(K key, $arg()$ val);
  boolean replace(K key, $arg()$ oldVal, $arg()$ newVal);  
  boolean replace(K key, $arg()$ newVal);
$unlessString({  
  $prim$ compute$short$IfAbsent(K key, To$short$Function<? super K> function);
  $managed$ computeIfAbsent(K key, To$short$Function<? super K> function);
})$  
  $val()$ compute$short$IfAbsent(K key, Function<? super K, ? extends $below()$> function);
$unlessString({  
  $prim$ compute$short$IfPresent(K key, To$short$Function<? super K> function);
  $managed$ computeIfPresent(K key, To$short$Function<? super K> function);
})$  
  $val()$ compute$short$IfPresent(K key, Function<? super K, ? extends $below()$> function);
  $val()$ compute$short$(K key, BiFunction<? super K, ? super $above()$, ? extends $below()$> function);
  $val()$ merge$short$(K key, $managed$ v, BiFunction<? super K, ? super $above()$, ? extends $below()$> function);
  $val()$ merge$short$(K key, $arg()$ v, BiFunction<? super K, ? super $above()$, ? extends $below()$> function);
    
$if(type.numeric)$
$["inc","dec","mult","div"]:{ func |
  $prim$ $func$$short$(K key, $prim$ by);
  default $prim$ $func$$short$(K key, $managed$ by) {
    return $func$$short$(key, $managed$.as$type.shortName$(by));
  \}
  default $managed$ $func$(K key, $prim$ by) {
    return $managed$.valueOf($func$$short$(key, by));
  \}
  default $managed$ $func$(K key, $managed$ by) {
    return $managed$.valueOf($func$$short$(key, $managed$.as$type.shortName$(by)));
  \}
  default void $func$All($managed$ by) {
    $func$All($managed$.as$short$(by));
  \}
  void $func$All($prim$ by);
}
$
$endif$  
  }
>>