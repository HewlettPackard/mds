/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

delimiters "$", "$"
import "string.stg"
package(type) ::= "com.hpl.mds.impl"
class(type) ::= "$type.fieldName$Proxy"

code(type,types) ::= <<
/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

$body(class(type), type, type.managedName, type.boxedName, type.primName, type.fieldName, type.shortName, type.jniName, types)$
>>                      

body(class, type, managed, boxed, prim, field, short, jni, types) ::= <<
package $package(type)$;

import com.hpl.mds.*;
$whenString({
import java.util.function.Function;
import java.util.function.Consumer;
})$

//public class $class$<RT extends ManagedRecord, $managed$> extends FieldProxy<RT, $managed$> implements $field$<RT> {
//public interface $field$<RT extends ManagedRecord> extends Field<RT, $managed$>

public class $class$<RT extends ManagedRecord> extends FieldProxy<RT, $managed$> implements $field$<RT> {

    private static final NativeLibraryLoader NATIVE_LIB_LOADER = NativeLibraryLoader.getInstance();

	protected $class$(long handleIndex, RecordTypeProxy<RT> recType, ManagedStringProxy name) {
		super(handleIndex, recType, name);
	}


    private static native void release(long handle);
    private static native long getNameHandle(long handle);
    private static native long getRecTypeHandle(long handle);
  
	private static native long createFieldIn(long rtHandle, long nameHandle);
    private static native $jniArg()$ setValue$whenString({Handle})$(long handle, long recHandle, $jniArg()$ val);
    private static native $jniArg()$ getAndSetValue$whenString({Handle})$(long handle, long recHandle, $jniArg()$ val);
    private static native boolean initFinal(long handle, long recHandle, $jniArg()$ val);
$if(type.numeric)$
$["inc","dec","mult","div",
 "getAndInc","getAndDec","getAndMult","getAndDiv"]:{ func |
    private static native $jniArg()$ $func$Value(long handle, long recHandle, $jniArg()$ val);
}
$
$endif$	

  @Override
  void releaseHandleIndex(long index) {
    release(index); 
  }
    
    
$ifString({    
    private static native boolean changeValue$whenString({Handle})$(long handle, long recHandle, 
                                                         long expectedHandle, long valHandle,
                                              Consumer<? super $above()$> mismatchSink);
    private static native long getValue$whenString({Handle})$(long handle, long recordHandle);
    private static native long peekValue$whenString({Handle})$(long handle, long recordHandle);
},{                                              
    private static native boolean changeValue$whenString({Handle})$(long handle, long recHandle, $arg()$ expected, $arg()$ val,
                                              $short$Consumer mismatchSink);
    private static native $val()$ getValue$whenString({Handle})$(long handle, long recordHandle);
    private static native $val()$ peekValue$whenString({Handle})$(long handle, long recordHandle);
})$                                              

	static <RT extends ManagedRecord> $class$<RT> in(RecordType<RT> recType, CharSequence name) {
	   RecordTypeProxy<RT> rtp = RecordTypeProxy.downcast(recType);
       ManagedStringProxy nameProxy = ManagedStringProxy.valueOf(name);
       long h = createFieldIn(rtp.handleIndex(), nameProxy.handleIndex());
       $class$<RT> p = new $class$<>(h, rtp, nameProxy);
       return p;
	}
	
	public $managed$Type valueType() {
	  return $managed$Type.INSTANCE;
	}
	
	@Override
    public ManagedStringProxy name() {
      if (name_ == null) {
        name_ = ManagedStringProxy.fromHandle(getNameHandle(handleIndex_));
      }
      return name_;
    }

	
	   
    @Override
    public RecordType<RT> recordType() {
      if (recordType_ == null) {
        recordType_ = RecordTypeProxy.<RT>fromHandle(getRecTypeHandle(handleIndex_));
      }
      return recordType_;
    }



$ifString({
    @Override
    public $managed$ get(RT record) {
        long h = $class$.<RT>getValueHandle(handleIndex_, ManagedRecordProxy.handleOf(record));
       return ManagedStringProxy.fromHandle(h);
    \}
    public $managed$ peek(RT record) {
        long h = $class$.<RT>peekValueHandle(handleIndex_, ManagedRecordProxy.handleOf(record));
       return ManagedStringProxy.fromHandle(h);
    \}
},{
    @Override
    public $val()$ get$short$(RT record) {
        $val()$ val = $class$.<RT>getValue(handleIndex_, ManagedRecordProxy.handleOf(record));
       return val;                         
    \}
    @Override
    public $val()$ peek$short$(RT record) {
        $val()$ val = $class$.<RT>peekValue(handleIndex_, ManagedRecordProxy.handleOf(record));
       return val;                         
    \}
})$

  @Override
  public final boolean change(RT rec, $arg()$ expected, $arg()$ value) {
    return Stub.notImplemented();
  }
  @Override
  public final boolean change(RT rec, Holder<$boxed$> holdsExpected, $arg()$ value) {
    return Stub.notImplemented();
  }
$unlessString({  
  @Override
  public final boolean change(RT rec, $short$Holder holdsExpected, $arg()$ value) {
    return Stub.notImplemented();
  \}
})$  

$ifString({
	@Override
	public $managed$ set(RT rec, $managed$ val) {
		setValueHandle(handleIndex_,
		                        ManagedRecordProxy.handleOf(rec),
					ManagedStringProxy.handleOf(val));
                return val;
	\}
	@Override
	public $managed$ getAndSet(RT rec, $managed$ val) {
		long h = setValueHandle(handleIndex_,
		                        ManagedRecordProxy.handleOf(rec),
					ManagedStringProxy.handleOf(val));
                return ManagedStringProxy.fromHandle(h);					
	\}
        @Override
        public void initFinal(RT rec, $managed$ val) {
          if (!initFinal(handleIndex_,
                         ManagedRecordProxy.handleOf(rec),
                         ManagedStringProxy.handleOf(val)))
          {
            throw new FinalFieldModifiedException(recordType().name().asString(),
                                                  name().asString());
          \}
        \}                   
},{
	@Override
	public $val()$ set(RT rec, $arg()$ val) {
		setValue$whenString({Handle})$(handleIndex_, 
		                ManagedRecordProxy.handleOf(rec), $toJNI({val})$);
                return val;
	\}
	@Override
	public $val()$ getAndSet(RT rec, $arg()$ val) {
		return $fromJNI({getAndSetValue$whenString({Handle})$(handleIndex_, 
		                ManagedRecordProxy.handleOf(rec), $toJNI({val})$)})$;
	\}
        @Override
        public void initFinal(RT rec, $arg()$ val) {
          if (!initFinal(handleIndex_,
                         ManagedRecordProxy.handleOf(rec),
                         $toJNI({val})$))
          {
            throw new FinalFieldModifiedException(recordType().name().asString(),
                                                  name().asString());
          \}
        \}
})$

$if(type.numeric)$
$["inc","dec","mult","div",
 "getAndInc","getAndDec","getAndMult","getAndDiv"]:{ func |
	@Override
	public $prim$ $func$(RT rec, $prim$ by) {
		return $func$Value(handleIndex_, ManagedRecordProxy.handleOf(rec), by);
	\}
}
$
$endif$	

}

>>
