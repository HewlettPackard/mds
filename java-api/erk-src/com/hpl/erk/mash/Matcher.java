/*
 *
 *  Managed Data Structures
 *  Copyright © 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

package com.hpl.erk.mash;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.Random;
import java.util.Set;
import java.util.TreeSet;

import com.hpl.erk.func.UnaryFunc;
import com.hpl.erk.impl_helper.CompareToImpl;
import com.hpl.erk.util.IterUtils;
import com.hpl.erk.util.Strings;


public class Matcher {
  
  private static final boolean TRACE = false;
  private static final int[] mashTable = makeMASHTable();
  private static final long SEED = "Palo Alto".hashCode();
  private static final byte STOPWORD_MASK = 0x03;
  private static final byte STOPWORD_VAL = 0x02;
  
  private static final String[] STOPWORDS = new String[] {
    "of", "the", "in", "on", "a", "an", "and", "or", "to"
  };
  
  enum LookupResult { STOPWORD, NO, YES, FINAL };
  
  public static class Match implements Comparable<Match> {
    private final String string;
    private final int length;
    Match(String s, int nWords) {
      length = nWords;
      string = s;
    }
    public String getString() {
      return string;
    }
    @Override
    public String toString() {
      return string;
    }
    /**
     * Prefer the largest number of words, then the longest string
     */
    public int compareTo(Match other) {
      return CompareToImpl.notNull(this, other)
          .compare(other.length, length)
          .compare(other.string, string, Strings.length())
          .compare(string, other.string)
          .value();
    }
    @Override
    public int hashCode() {
      return string.hashCode();
    }
  }
  
  public static class MatchSet implements Iterable<String> {
    private final Set<Match> set = new TreeSet<Match>();
    public int size() { return set.size(); }// GHF 080725  Easier to know size w/o iterating

    public Iterator<String> iterator() {
      return IterUtils.map(set.iterator(), new UnaryFunc<Match,String>() {
        @Override
        public String call(Match match) {
          return match.string;
        }
      });
    }
    public String[] toArray() {
      String[] strings = new String[set.size()];
      int i=0;
      for (Match ms : set) {
        strings[i++] = ms.string;
      }
      return strings;
    }
    void add(Match ms) {
      set.add(ms);
    }
  }
  
  private final class WordSeq {
    boolean active;
    int hash;
    WordSeq next;
    StringBuilder word = new StringBuilder(8);
    int nRealWords;  // doesn't include stopwords
    int nWords; // includes stopword
    int longestMatch;
    int longestMatchRealWords;
    int longestMatchHash;
    
    void addStopword() {
      if (nWords > 0) {
        nWords++;
      } else {
        active = false;
      }
    }
    
    void add(final int lastWordHash, final MatchSet matches) {
      if (active) {
        hash = (hash >> 1)^lastWordHash;
        nWords++;
        nRealWords++;
        final LookupResult r = checkArray(hash, nRealWords-1);
        switch (r) {
        case FINAL:
          longestMatch = nWords;
          longestMatchRealWords = nRealWords;
          longestMatchHash = hash;
          return;
        case YES:
          return;
        default:
        	// fall through
        }
        assert r == LookupResult.NO;
        // we've hit a word that can't extend.  We assert our longest
        // full match, if we have one.
        assertMatch(matches);
      }
    }

    private void assertMatch(final MatchSet matches) {
      if (longestMatch > 0) {
        int len = longestMatch-1; // that many spaces
        WordSeq ws = this;
        for (int i=0; i<longestMatch; i++) {
          len += ws.word.length();
          ws = ws.next;
        }
        StringBuilder sb = new StringBuilder(len);
        ws = this;
        for (int i=0; i<longestMatch; i++) {
          if (i > 0) {
            sb.append(' ');
          }
          sb.append(ws.word);
          ws = ws.next;
        }
        matches.add(new Match(sb.toString(), longestMatchRealWords));
//        System.out.println("Asserting "+this);
      }
      longestMatch = 0;
      active = false;
    }

    public void reset() {
      active = true;
      hash = 0;
      word.setLength(0);
      nWords = 0;
      nRealWords = 0;
      longestMatch = 0;
    }
    
    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("#{");
      sb.append(Integer.toHexString(hash & mask));
      sb.append(", ");
      if (longestMatch > 0) {
        sb.append("("+Integer.toHexString(longestMatchHash & mask)+") ");
      }
      if (active) {
        sb.append("[");
      }
      int i=0;
      String sep = "";
      for (WordSeq ws = this; ws != null; ws=ws.next) {
        i++;
        sb.append(sep);
        sep = " ";
        sb.append(ws.word);
        if (i == longestMatch) {
          sb.append(" ! ");
        }
        if (i == nWords) {
          sb.append("]");
        }
      }
      sb.append("}");
      return sb.toString();
    }
  }
  

  private final class Matching {
    private Matching next;
    private WordSeq current = new WordSeq();
    private WordSeq firstActive = current;
    private WordSeq lastActive = current;
    private WordSeq freeList;

    Matching() {
    }

    private void reset() {
      if (firstActive != lastActive) {
        lastActive.next = freeList;
        freeList = firstActive.next;
        lastActive = firstActive;
        current = firstActive;
      }
      current.reset();
    }
    
    private void newCurrent() {
      current = freeList;
      if (current == null) {
        current = new WordSeq();
      } else {
        freeList = current.next;
      }
      lastActive.next = current;
      lastActive = current;
      current.next = null;
      current.reset();
    }
    
    <T extends CharSequence> MatchSet checkAll(Iterable<T> strings, boolean separatep) {
      MatchSet matches = new MatchSet();
      reset();
      StringBuilder sb = current.word;
      for (CharSequence s : strings) {
        final int strLen = s.length();
        int hash = 0;
        for (int i=0; i<strLen; i++) {
          char c = s.charAt(i);
          int code = mashTable[c];
          if (code == 0) {
            if (hash != 0) {
              addWord(hash, matches);
              sb = current.word;
              hash = 0;
            }
          } else {
            hash = (hash>>1)+code;
            sb.append(c);
          }
        }
        if (hash != 0) {
          addWord(hash, matches);
        }
        if (separatep) {
          assertNonSubsumed(matches);
          reset();
        }
      }
      assertNonSubsumed(matches);
      return matches;
    }

    private void assertNonSubsumed(MatchSet matches) {
      for (WordSeq ws = firstActive; ws != null; ws=ws.next) {
        ws.assertMatch(matches);
      }
    }

    private void addWord(int hash, MatchSet matches) {
      if (isStopword(hash)) {
        for (WordSeq ws = firstActive; ws != null; ws=ws.next) {
          ws.addStopword();
        }
      } else {
        for (WordSeq ws = firstActive; ws != null; ws=ws.next) {
          ws.add(hash, matches);
        }
      }
      // now, having done that, we prune the inactive ones to the 
      // free list.
      
      WordSeq lastInactive = null;
      for (WordSeq ws = firstActive; ws != lastActive && !ws.active; ws=ws.next) {
        lastInactive = ws;
      }
      if (lastInactive != null) {
        WordSeq newFirst = lastInactive.next;
        lastInactive.next = freeList;
        freeList = firstActive;
        firstActive = newFirst;
      }
      if (current == firstActive && !current.active) {
        current.reset();
      } else {
        newCurrent();
      }
    }
  }
  
  public abstract class Masher {
    public void process(final CharSequence s) {
      start(s);
      try {
        int hash = 0;
        final int len = s.length();
        for (int i = 0; i < len; i++) {
          char c = s.charAt(i);
          int code = mashTable[c];
          if (code == 0) {
            if (hash != 0) {
              if (!isStopword(hash)) {
                boolean cont = addWord(hash);
                if (!cont) {
                  return;
                }
              }
              hash = 0;
            }
          } else {
            hash = (hash>>1)+code;
          }
        }
        if (hash != 0 && !isStopword(hash)) {
        addWord(hash);
        }
      } finally {
        end();
      }
    }
    
    protected void start(CharSequence s) {}
    protected void end() {}
    
    protected int extend(int oldHash, int newHash) {
      return (oldHash>>1)^newHash;
    }

    protected abstract boolean addWord(int hash);
    
    protected boolean isStopword(int hash) {
      return checkArray(hash, 0) == LookupResult.STOPWORD;
    }
  }
  
  private final byte[] targets;
  protected final int mask;
  private final int nBits;
  private Matching nextMatching = null;
  public Matcher(int bits) {
    nBits = bits;
    int arrayLength = 1<<bits;
    targets = new byte[arrayLength];
    mask = arrayLength-1;
    for (String sw : STOPWORDS) {
      addStopword(sw);
    }
  }
  public Matcher(int bits, Iterable<String> targets) {
    this(bits);
    addAll(targets);
  }
  public Matcher(int bits, String[] targets) {
    this(bits, Arrays.asList(targets));
  }
  public Matcher(File f) throws IOException {
    try (InputStream fin = new FileInputStream(f);
        DataInputStream in = new DataInputStream(fin)) {
      nBits = in.readByte();
      int arrayLength = 1<<nBits;
      mask = arrayLength-1;
      targets = new byte[arrayLength];
      in.readFully(targets);
    }
  }
  
  public void addStopword(final String s) {
    // I'm only allowing single-word stopwords.  Anything longer will throw an IllegalArgumentException
    Masher m = new Masher() {
      boolean asserted = false;
      @Override
      protected boolean addWord(int hash) {
        if (asserted) {
          throw new IllegalArgumentException("More than one word in stopword: '"+s+"'");
        }
        int index = hash & mask;
        targets[index] &= ~STOPWORD_MASK;
        targets[index] |= STOPWORD_VAL;
        return true;
      }
    };
    m.process(s);
  }
  
  
  public void addAll(Iterable<String> strings) {
    for (String s : strings) {
      addTarget(s);
    }
  }
  
  synchronized private final Matching acquireMatching() {
    Matching m = nextMatching;
    if (m == null) {
      return new Matching();
    }
    nextMatching = m.next;
    return m;
  }
  
  synchronized private final void releaseMatching(Matching m) {
    if (m != null) {
      m.next = nextMatching;
      nextMatching = m;
    }
  }
  

  
  
  public void addTarget(String s) {
    if (TRACE) {
      System.out.format("Target: %s%n", s);
    }
    Masher m = new Masher() {
      int current = 0;
      int pos = 0;
      @Override
      protected boolean addWord(int hash) {
        current = extend(current, hash);
        assertTarget(current, pos, false);
        pos++;
        return true;
      }
      @Override
      protected void end() {
        // the last one is final
        assertTarget(current, pos-1, true);
      }
    };
    m.process(s);
  }
  
  public void addTargetWindowed(String s, final int windowSize) {
    if (TRACE) {
      System.out.format("Target: %s%n", s);
    }
    final int maxPos = windowSize-1;
    final int[] hashes = new int[(maxPos)*(maxPos)];
    Masher m = new Masher() {
      int next = 0;
      boolean asserting = false;
      @Override
      protected boolean addWord(int hash) {
        if (asserting) {
          int p = (maxPos)*next;
          for (int i=0; i<maxPos; i++,p++) {
            assertTarget(hashes[p], i, false);
          }
          int full = extend(hashes[p-1], hash);
          assertTarget(full, maxPos, true);
        }
        int bound = asserting ? maxPos : next;
        for (int i=0; i<bound; i++) {
          int base = (maxPos)*i;
          int pos = next-i;
          if (pos == 0) {
            continue;
          }
          if (pos<0) {
            pos += maxPos;
          }
          hashes[base+pos] = extend(hashes[base+pos-1], hash);
        }
        hashes[(maxPos)*next] = hash;
        next++;
        if (next == maxPos) {
          next = 0;
          asserting = true;
        }
        return true;
      }
      @Override
      protected void end() {
        if (!asserting) {
          for (int i=0; i<next; i++) {
            assertTarget(hashes[i], i, i==next-1);
          }
        }
      }
    };
    m.process(s);
  }
  
  public void dump(File f) throws IOException {
    // I'm totally cheating here, but it shouldn't matter.  I'm just going to put the 
    // maximum target size in the first byte (and zero it out on read in).  The odds of
    // it actually clobbering something are minuscule.
    try (OutputStream fout = new FileOutputStream(f);
        DataOutputStream out = new DataOutputStream(fout)) { 
      out.writeByte(nBits);
      out.write(targets);
    }
  }
  
  private static int[] makeMASHTable() {
    final int[] randomTable = makeRandomTable();
    final int[] table = new int[65536];
    for (int c = 0; c<65536; c++) {
      if (Character.isLetter(c)) {
        char lc = (char) Character.toLowerCase(c);
        // This should really check whether it's a precomposed character and take the first
        // char in it's canonical representation, but I don't see an easy way to do that.
        switch (lc) {
        case 'á':
        case 'â':
        case 'à':
        case 'ä':
        case 'ã':
          lc = 'a';
          break;
        case 'é':
        case 'ê':
        case 'è':
        case 'ë':
        case 'æ':
          lc = 'e';
          break;
        case 'í':
        case 'î':
        case 'ì':
        case 'ï':
          lc = 'i';
          break;
        case 'ó':
        case 'ô':
        case 'ò':
        case 'ö':
        case 'õ':
        case 'ø':
          lc = 'o';
          break;
        case 'ú':
        case 'û':
        case 'ù':
        case 'ü':
          lc = 'u';
          break;
        case 'ñ':
          lc = 'n';
          break;
        case 'ç':
          lc = 'c';
          break;
        case 'ÿ':
          lc = 'y';
          break;
        case 'ð':
          lc = 'd';
          break;
        case 'ß':
          lc = 's';
          break;
        case 'þ':
          lc = 't';
          break;
        }
        table[c] = randomTable[lc];
      } else if (Character.isDigit(c)) {
        table[c] = randomTable[c];
      } else {
        // we leave it at zero
      }
    }
    return table;
  }
  
  public <T extends CharSequence>MatchSet checkAll(Iterable<T> strings, boolean separatep) {
    Matching matching = acquireMatching();
    try {
      return matching.checkAll(strings, separatep);
    } finally {
      releaseMatching(matching);
    }
    
  }
  
  public MatchSet check(String s) {
    return checkAll(Collections.singleton(s), false);
  }



  private static int[] makeRandomTable() {
    int[] table = new int[65536];
    Random rnd = new Random(SEED);
    for (int i=0; i<table.length; i++) {
      table[i] = rnd.nextInt();
    }
    return table;
  }
  
  public static byte makeNybble(int pos, boolean isFinal) {
    if (pos > 5) {
      pos = 5;
    }
    int val = (pos+1)<<1;
    if (isFinal) {
      val |= 1;
    }
    return (byte) val;
  }

  public final boolean isStopword(final int hash) {
    return checkArray(hash, 0) == LookupResult.STOPWORD;
  }

  private final LookupResult checkArray(final int hash, final int pos) {
    final int index = hash & mask;
    byte b = targets[index];
    int mask = 0x03;
    int shift = pos > 3 ? 6 : 2*pos;
    int val = ((b & (mask << shift)) >> shift) & 0xFF;
    
    switch (val) {
    case 0x00:
      return LookupResult.NO;
    case 0x01:
      return LookupResult.YES;
    case 0x02:
      assert pos==0;
      return LookupResult.STOPWORD;
    case 0x03:
      return LookupResult.FINAL;
    }
    assert false;
    return LookupResult.NO;
  }
  
  
  private int nAsserted = 0;
  private final void assertTarget(final int hash, int pos, final boolean isFinal) {
    if ((++nAsserted%1000) == 0) {
      System.out.format("** %,d%n", nAsserted);
    }
    if (TRACE) {
      int index = hash & mask;
      System.out.format("-- %x [%x], pos = %d %s%n", hash, index, pos, Strings.flagWhen(isFinal, "[final]"));
    }
    int index = hash & mask;
    byte old = targets[index];
    if (pos == 0 && (old & STOPWORD_MASK) == STOPWORD_VAL) {
      // we don't clobber stopwords, though this shouldn't be seen anyway
      return;
    }
    if (pos > 3) {
      pos = 3;
    }
    int bits = isFinal ? 0x03 : 0x01;
    bits <<= 2*pos;
    targets[index] |= bits;
  }
  
  
  
  public static void main(String[] args) {
    String[] s = new String[] {
        "test",
        "Sony 21-inch LCD HDTV",
        "Sony 21-inch",
        "LCD HDTV",
        "plasma TV"
    };
    Matcher m = new Matcher(20, s);
    MatchSet matches = m.check("I bought a sony 21 inch lcd hdtv and a plasma tv for my bedroom");
//    MatchSet matches = m.check("this is a test");
    for (String match : matches) {
      System.out.format("matched '%s'%n", match);
    }
  }
  
}
