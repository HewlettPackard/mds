/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * mds_core_api.h
 *
 *  Created on: Sep 16, 2014
 *      Author: evank
 */

#ifndef MDS_CORE_API_H_
#define MDS_CORE_API_H_

#include "mds_types.h"
#include "core/mds_core.h"
#include <string>
#include <vector>
#include <unordered_map>
#include <memory>
#include <iterator>
#include <algorithm>
#include <type_traits>
#include <mutex>
#include <locale>
#include <stack>
#include <type_traits>

namespace mds {
 namespace api {
   /*
    * This namespace contains the types and functions that should be used by
    * an implementation of an MDS language API.  It includes the primitive
    * types used by the core (actually part of the mds namespace), the
    * kind enumeration, and "handles" for non-primitive core types.  Given a
    * kind, the API type (primitive or handle) is given as "api_type<K>"
    * and the core type as "core_type<K>".  To get from the api type to the
    * core type, you can use "to_core_val(val)".  (To go the other way, you
    * can just use a constructor.)
    *
    * Handles come in two forms.  view_independent_handle<T> holds an
    * external_gc_ptr<T> object.  It can be copy/move constructed or constructed
    * from a view_independent_handle<X>, external_gc_ptr<X>, or gc_ptr<X> for any
    * X for which pointer assignment would work.  It can also be default
    * constructed or constructed from nullptr.  Assignment operators for
    * each of these also exist as well as comparisons for equality and
    * inequality (whenever the corresponding pointers could be compared).
    *
    * view_relative_handle<T> hold a view_independent_handle<T>
    * pointing to a core object as well as an external_gc_ptr<view>.  Its constructor
    * requires both components and it can only be assigned from or compared
    * to another view_relative_handle<T>.  The object() and view() methods
    * can be used to obtain the two components.  There is also a constructor
    * that takes a view_relative_handle and an external_gc_ptr<view>
    * and returns a handle to the object on the new view.
    *
    * The actual classes APIs will use are subclasses of these two handle
    * types which expose (as direct methods, not via pointers) core methods,
    * converting API types to handle types as necessary.  These can, similarly,
    * be constructed and assigned from external_gc_ptr and gc_ptr values.  (The
    * inherited comparison operators suffice.)
    *
    * Each API handle class comes in two varieties, depending on whether
    * the handle logically refers to a const or non-const core object.  To
    * implement this, we actually have "foo_handle_cp<bool ConstP>",
    * with "foo_handle" being an alias for "foo_handle_cp<false>"
    * and "const_foo_handle" an alias for "foo_handle_cp<true>".  Methods
    * that apply to const core objects are available either way, and SFINAE
    * is used to omit methods that apply to non-const objects when ConstP is
    * true.  A consequence of this is that if you have a method that takes
    * a foo_handle as a reference argument and uses it in a const way, you
    * should declare the argument as "const foo_handle_cp<C> &".  Saying
    * "const const_foo_handle &" will also work, but it will copy a
    * "foo_handle" into a temporary, which is at least a shared pointer
    * copy.
   */


   /*
    * Returns true if the process had not previously been registered.
    * Parameter currently ignored
    */
   inline bool register_process(bool automatically_unregister = false) {
     return core::register_process();
   }

   /*
    * Returns true if the process had not previously been unregistered.
    */
   inline bool unregister_process() {
     return core::unregister_process();
   }

   inline void ensure_process_registered() {
     core::ensure_process_registered();
   }

   namespace mem_stats {
     inline std::size_t bytes_in_heap() {
       mpgc::initialize();
       return mpgc::control_block().mem_stats.bytes_in_heap();
     }
     inline std::size_t bytes_in_use() {
       mpgc::initialize();
       return mpgc::control_block().mem_stats.bytes_in_use();
     }
     inline std::size_t bytes_free() {
       mpgc::initialize();
       return mpgc::control_block().mem_stats.bytes_free();
     }
     inline std::size_t gc_cycle_number() {
       mpgc::initialize();
       return mpgc::control_block().mem_stats.cycle_number();
     }
     inline std::size_t n_processes() {
       mpgc::initialize();
       return mpgc::control_block().mem_stats.n_processes();
     }
     inline std::size_t n_objects() {
       mpgc::initialize();
       return mpgc::control_block().mem_stats.n_objects();
     }
     
   }


   using core::kind;
   using core::kind_val;
   using core::kind_type;
   using core::kind_field;

   using core::ret_mode;
   using core::modify_op;
   template <kind K> using mod_condition = core::mod_condition<K>;

   using core::with_uniform_id;
   using core::uniform_key;


   using core::incompatible_superclass_ex;
   using core::incompatible_type_ex;
   using core::unmodifiable_record_type_ex;
   using core::unbound_name_ex;
   using core::read_only_context_ex;
   using core::unpublishable_context_ex;

   using core::view_type;
   using core::mod_type;

   template <kind K> using core_type = core::kind_val<K>;

   template <bool ConstP> class interned_string_handle_cp;
   using interned_string_handle = interned_string_handle_cp<false>;
   using const_interned_string_handle = interned_string_handle_cp<true>;

   template <bool ConstP>
   using managed_string_handle_cp = interned_string_handle_cp<ConstP>;
   using managed_string_handle = managed_string_handle_cp<false>;
   using const_managed_string_handle = const_interned_string_handle;

   template <bool ConstP> class iso_context_handle_cp;
   using iso_context_handle = iso_context_handle_cp<false>;
   using const_iso_context_handle = iso_context_handle_cp<true>;

   template <bool ConstP> class publication_attempt_handle_cp;
   using publication_attempt_handle = publication_attempt_handle_cp<false>;
   using const_publication_attempt_handle = publication_attempt_handle_cp<true>;

   template <bool ConstP> class task_handle_cp;
   using task_handle = task_handle_cp<false>;
   using const_task_handle = task_handle_cp<true>;


   template <bool ConstP> class managed_record_handle_cp;
   using managed_record_handle = managed_record_handle_cp<false>;
   using const_managed_record_handle = managed_record_handle_cp<true>;

   template <kind K, bool ConstP> class record_field_handle_cp;
   template <kind K>
   using record_field_handle = record_field_handle_cp<K, false>;
   template <kind K>
   using const_record_field_handle = record_field_handle_cp<K, true>;

   template <bool ConstP> class managed_array_base_handle_cp;
   using managed_array_base_handle = managed_array_base_handle_cp<false>;
   using const_managed_array_base_handle = managed_array_base_handle_cp<true>;

   template <kind K, bool ConstP> class managed_array_handle_cp;
   template <kind K>
   using managed_array_handle = managed_array_handle_cp<K, false>;
   template <kind K>
   using const_managed_array_handle = managed_array_handle_cp<K, true>;
   using array_index_type = mds::core::array_index_type;

   template <kind K, bool ConstP, typename LeafT = core::kind_type<K>,
       typename = std::enable_if_t<std::is_base_of<core::kind_type<K>, LeafT>::value> >
   class managed_type_handle_cp;
   template <kind K> using managed_type_handle = managed_type_handle_cp<K, false>;
   template <kind K> using const_managed_type_handle = managed_type_handle_cp<K, true>;

   template <bool ConstP> class record_type_handle_cp;
   using record_type_handle = record_type_handle_cp<false>;
   using const_record_type_handle = record_type_handle_cp<true>;

   template <bool ConstP> class array_type_base_handle_cp;
   using array_type_base_handle = array_type_base_handle_cp<false>;
   using const_array_type_base_handle = array_type_base_handle_cp<true>;

   template <kind K, bool ConstP> class array_type_handle_cp;
   template <kind K> using array_type_handle = array_type_handle_cp<K, false>;
   template <kind K> using const_array_type_handle = array_type_handle_cp<K, true>;
   template <kind K> using array_size_type = typename mds::core::array_type<K>::size_type;

   template <bool ConstP> class namespace_handle_cp;
   using namespace_handle = namespace_handle_cp<false>;
   using const_namespace_handle = namespace_handle_cp<true>;

   /*
    * api_type<T> will either be T or a handle (defined in a specialization)
    */
   template <kind K, typename Enable = void> struct mv_wrapper;
   template <kind K> using api_type = typename mv_wrapper<K>::type;
   template <kind K>
   inline core::kind_mv<K> to_core_val(const api_type<K> &val) {
     return mv_wrapper<K>::to_core_val(val);
   }

   /*
    * Primitive types just pass by value
    */
   template <kind K>
   struct mv_wrapper<K, std::enable_if_t<std::is_arithmetic<core_type<K>>::value>>
   {
     using type = core_type<K>;
     static type to_core_val(const type &val) {
       return val;
     }
   };

   template <kind K, bool ConstP>
   struct type_handle_traits {
     using type = managed_type_handle_cp<K,ConstP>;
   };
   template <bool ConstP>
   struct type_handle_traits<kind::RECORD, ConstP> {
     using type = record_type_handle_cp<ConstP>;
   };

   template <kind K> using type_handle_for = typename type_handle_traits<K,false>::type;
   template <kind K> using const_type_handle_for = typename type_handle_traits<K,true>::type;


   /* Base class to simplify specializations */
   template <typename H>
   struct use_handle {
     using type = H;
     static auto to_core_val(const type &val) {
       return val.to_core_val();
     }
   };

   template <typename T, typename = std::enable_if_t<core::is_exportable<T>::value>
   >
   struct view_independent_handle {
     using value_type = T;
   private:
     core::external_gc_ptr<T> _ptr;

     template <typename X, typename E> friend class view_independent_handle;
   protected:
   public:
     auto &pointer() const {
       return _ptr;
     }

     template <typename X> using compatible = std::enable_if_t<std::is_convertible<X*,T*>::value>;

     view_independent_handle(const view_independent_handle &) = default;
     template <typename X, typename = compatible<X> >
     view_independent_handle(const view_independent_handle<X> &rhs) : _ptr{rhs.pointer()} {}

     view_independent_handle(view_independent_handle &&) = default;
     template <typename X, typename = compatible<X> >
     view_independent_handle(view_independent_handle<X> &&rhs) : _ptr{std::move(rhs.pointer())} {}

     template <typename X, typename = compatible<X> >
     view_independent_handle(const core::external_gc_ptr<X> &rhs) : _ptr{rhs} {}

     template <typename X, typename = compatible<X> >
     view_independent_handle(const core::gc_ptr<X> &rhs) : _ptr{rhs} {}

     constexpr view_independent_handle() = default;
     constexpr view_independent_handle(nullptr_t) {}

     view_independent_handle &operator =(const view_independent_handle &) = default;
     template <typename X, typename = compatible<X> >
     view_independent_handle &operator =(const view_independent_handle<X> &rhs) {
       _ptr = rhs.pointer();
       return *this;
     }

     view_independent_handle &operator =(view_independent_handle &&) = default;
     template <typename X, typename = compatible<X> >
     view_independent_handle &operator =(view_independent_handle<X> &&rhs) {
       _ptr = std::move(rhs.pointer());
       return this;
     }

     template <typename X, typename = compatible<X> >
     view_independent_handle &operator =(const core::external_gc_ptr<X> &rhs) {
       _ptr = rhs;
       return this;
     }

     template <typename X, typename = compatible<X> >
     view_independent_handle &operator =(const core::gc_ptr<X> &rhs) {
       _ptr = rhs;
       return this;
     }

     view_independent_handle &operator =(nullptr_t) {
       _ptr = nullptr;
       return this;
     }

     template <typename X>
     using if_comparable_t = std::enable_if_t<(
         std::is_base_of<std::decay_t<X>, std::decay_t<T>>::value
         ||
         std::is_base_of<std::decay_t<T>, std::decay_t<X>>::value
         )>;



     template <typename X, typename = if_comparable_t<X> >
     bool operator ==(const view_independent_handle<X> &rhs) const {
       return _ptr== rhs.pointer();
     }
     template <typename X, typename = if_comparable_t<X> >
     bool operator ==(const core::external_gc_ptr<X> &rhs) const {
       return _ptr == rhs;
     }
     template <typename X, typename = if_comparable_t<X> >
     bool operator ==(const core::gc_ptr<X> &rhs) const {
       return _ptr == rhs;
     }
     bool operator ==(nullptr_t) const {
       return _ptr .is_null();
     }
     template <typename X>
     bool operator !=(X&& rhs) const {
       return !((*this) == std::forward<X>(rhs));
     }
#if 0
     template <typename X, typename = std::enable_if_t<std::is_convertible<T*,X*>::value> >
     operator core::gc_ptr<X> () const {
       return value;
     }
     template <typename X, typename = std::enable_if_t<std::is_convertible<T*,X*>::value> >
     operator core::external_gc_ptr<X> () const {
       return value;
     }
     virtual ~view_independent_handle() {}
#endif
     bool is_null() const {
       return _ptr.is_null();
     }
     core::gc_ptr<value_type> to_core_val() const {
       return _ptr;
     }
     constexpr std::uint64_t hash1() const {
       return _ptr.hash1();
     }
     constexpr std::uint64_t hash2() const {
       return _ptr.hash2();
     }

     auto ignore_const() const {
       using nc_value_type = std::remove_const_t<value_type>;
       view_independent_handle<nc_value_type> nct(std::const_pointer_cast<nc_value_type>(_ptr));
       return nct;
     }

     uniform_key uuid() const {
       return pointer()->uuid();
     }

     void swap(view_independent_handle &other) {
       _ptr.swap(other._ptr);
     }

     template <typename S>
     class __weak_handle {
       core::external_weak_gc_ptr<T> _ptr;
     public:
       __weak_handle(const S &h) : _ptr{h.pointer()} {}
       __weak_handle() = default;
       S lock() const {
         return S(_ptr.lock());
       }
     };
   };

   template <typename T, typename X, typename = std::common_type_t<X,T> >
   bool operator ==(const core::external_gc_ptr<X> &lhs, const view_independent_handle<T> &rhs) {
     return rhs == lhs;
   }
   template <typename T, typename X, typename = std::common_type_t<X,T> >
   bool operator !=(const core::external_gc_ptr<X> &lhs, const view_independent_handle<T> &rhs) {
     return rhs != lhs;
   }
   template <typename T, typename X, typename = std::common_type_t<X,T> >
   bool operator ==(const core::gc_ptr<X> &lhs, const view_independent_handle<T> &rhs) {
     return rhs == lhs;
   }
   template <typename T, typename X, typename = std::common_type_t<X,T> >
   bool operator !=(const core::gc_ptr<X> &lhs, const view_independent_handle<T> &rhs) {
     return rhs != lhs;
   }
   template <typename T>
   inline bool operator==(nullptr_t, const view_independent_handle<T> &rhs) {
     return rhs.is_null();
   }
   template <typename T>
   inline bool operator!=(nullptr_t, const view_independent_handle<T> &rhs) {
     return !rhs.is_null();
   }


   template <typename T,  typename = std::enable_if_t<
       std::is_base_of<core::managed_composite, T>::value
       > >
   struct view_relative_handle {
     using value_type = T;
   private:
     template <typename X, typename E> friend class view_relative_handle;
     using icb = core::external_gc_ptr<core::view>;
     view_independent_handle<T> _obj;
     icb _view;

     icb nullcheck(const icb b) const {
       return _obj == nullptr ? icb{} : b;
     }

     void check_non_null_view() const {
       assert( (_obj == nullptr) == (_view==nullptr) );
     }
   public:
     auto &object() const {
       return _obj;
     }

     auto &pointer() const {
       return _obj.pointer();
     }

     auto &view() const {
       return _view;
     }

     template <typename X = T, typename = std::enable_if_t<std::is_base_of<X, T>::value>>
     auto to_core_val() const {
       return core::managed_value<X>(pointer(), view());
     }

     template <typename X> using compatible = std::enable_if_t<std::is_convertible<X*,T*>::value>;

     view_relative_handle(const view_relative_handle &) = default;
     template <typename X, typename = compatible<X> >
     view_relative_handle(const view_relative_handle<X> &rhs)
     : _obj{rhs._obj}, _view{rhs._view}
     {}

     view_relative_handle(view_relative_handle &&) = default;
     template <typename X, typename = compatible<X> >
     view_relative_handle(view_relative_handle<X> &&rhs)
     : _obj{std::move(rhs._obj)},
       _view{std::move(rhs._view)}
     {}

     template <typename X, typename = compatible<X> >
     view_relative_handle(const core::vd_value<X> &rhs)
     : _obj{rhs.value}, _view{rhs.in_view}
     {
       check_non_null_view();
     }

     template <typename X, typename = compatible<X> >
     view_relative_handle(const view_relative_handle &rhs, const icb &b)
     : _obj{rhs._obj}, _view{nullcheck(b)}
     {
       check_non_null_view();
     }

     template <typename X, typename = compatible<X> >
     view_relative_handle(view_relative_handle &&rhs, const icb &b)
     : _obj{std::move(rhs._obj)}, _view{nullcheck(b)}
     {
       check_non_null_view();
     }

     template <typename X, typename = compatible<X> >
     view_relative_handle(const core::external_gc_ptr<X> &rhs, const icb &b)
     : _obj{rhs}, _view{nullcheck(b)}
     {
       check_non_null_view();
     }

     template <typename X, typename = compatible<X> >
     view_relative_handle(const core::gc_ptr<X> &rhs, const icb &b)
     : _obj{rhs}, _view{nullcheck(b)}
     {
       check_non_null_view();
     }

     view_relative_handle() = default;
     constexpr view_relative_handle(nullptr_t) {}

     view_relative_handle &operator =(const view_relative_handle &) = default;
     template <typename X, typename = compatible<X> >
     view_relative_handle &operator =(const view_relative_handle<X> &rhs) {
       _obj= rhs._obj;
       _view = rhs._view;
       return *this;
     }

     view_relative_handle &operator =(view_relative_handle &&) = default;
     template <typename X, typename = compatible<X> >
     view_relative_handle &operator =(view_relative_handle<X> &&rhs) {
       _obj = std::move(rhs._obj);
       _view = std::move(rhs._view);
       return this;
     }

     view_relative_handle &operator =(nullptr_t) {
       _obj = nullptr;
       _view = nullptr;
       return this;
     }


     template <typename X, typename = std::common_type_t<X,T> >
     bool operator ==(const view_relative_handle<X> &rhs) const {
       return _obj == rhs._obj && _view == rhs._view;
     }
     bool operator ==(nullptr_t) const {
       return _obj.is_null();
     }
     template <typename X>
     bool operator !=(X&& rhs) const {
       return !((*this) == std::forward<X>(rhs));
     }
     bool is_null() const {
       return _obj.is_null();
     }

     template <typename X, typename = std::common_type_t<X,T> >
     bool same_in_prevailing_context(const view_relative_handle<X> &rhs) const
     {
       if (_obj != rhs._obj) {
         return false;
       }
       // If either view is null, then both objects should be null.
       // (If only one was, we would have failed the prior test.)  So
       // both views should be null, and we'll succeed here.
       if (_view == rhs._view) {
         return true;
       }
       auto cp = core::iso_context::prevailing();
       return cp->shadow(_view) == cp->shadow(rhs._view);
     }


     void swap(view_relative_handle &other) {
       _obj.swap(other._obj);
       _view.swap(other._view);
     }

     /*
      * We use opposite hashes and shift just in case we would have a
      * view_relative_handle<view> where both referred to the
      * same thing.  Farfetched, but why not be safe?
      */
     constexpr std::uint64_t hash1() const {
       return (_obj.hash1() << 1) ^ _view.hash2();
     }
     constexpr std::uint64_t hash2() const {
       return (_obj.hash2() << 1) ^ _view.hash1();
     }
     auto ignore_const() const {
       using nc_value_type = std::remove_const_t<value_type>;
       view_relative_handle<nc_value_type> nct(std::const_pointer_cast<nc_value_type>(_obj.pointer()), _view);
       return nct;
     }
#if 0
     template <typename X, typename = std::enable_if_t<std::is_convertible<T*,X*>::value> >
     operator core::gc_ptr<X> () const {
       return value;
     }
     template <typename X, typename = std::enable_if_t<std::is_convertible<T*,X*>::value> >
     operator core::external_gc_ptr<X> () const {
       return value;
     }
     virtual ~view_independent_handle() {}
     core::gc_ptr<value_type> to_core_val() const {
       return _ptr;
     }
     template <typename X = LeafT, typename = std::enable_if_t<std::is_base_of<X, LeafT>::value>>
     core::managed_value<X> to_core_val() const {
       return core::managed_value<X>(value, in_view);
     }

#endif
   };

   template <typename T>
   inline bool operator==(nullptr_t, const view_relative_handle<T> &rhs) {
     return rhs.is_null();
   }
   template <typename T>
   inline bool operator!=(nullptr_t, const view_relative_handle<T> &rhs) {
     return !rhs.is_null();
   }

   template <bool ConstP, typename T>
   using htarget_ = std::conditional_t<ConstP, const T, T>;

   template <bool ConstP>
   struct constness {
     constexpr static bool less_const(bool cp) {
       return cp <= ConstP;
     }
     template <bool CP>
     using when_less_const = std::enable_if_t<less_const(CP)>;
   };

   const interned_string_handle &empty_string_();

   template <bool ConstP>
   struct interned_string_handle_cp
       : view_independent_handle<htarget_<ConstP,core::interned_string>>
   {
     using base = view_independent_handle<htarget_<ConstP,core::interned_string>>;
     using typename base::value_type;
     using non_const_type = interned_string_handle_cp<false>;

     using string_type = value_type;
     using char_type = typename string_type::value_type;
     using const_iterator = typename string_type::const_iterator;
     using const_reverse_iterator = typename string_type::const_reverse_iterator;
     using const_reference = typename string_type::const_reference;
     using const_pointer = typename string_type::const_pointer;
     using size_type = typename string_type::size_type;
     using difference_type = typename string_type::difference_type;

     //     template <bool CP> using when_less_const = typename constness<ConstP>::template when_less_const<CP>;
     template <bool CP>
       using when_less_const = std::enable_if_t<(CP <= ConstP)>;

     using base::base;
     using base::is_null;
     using base::pointer;

     constexpr interned_string_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     interned_string_handle_cp(const interned_string_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     interned_string_handle_cp(interned_string_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     interned_string_handle_cp &
     operator =(const interned_string_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     interned_string_handle_cp &
     operator =(interned_string_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     static interned_string_handle empty_string() {
       return empty_string_();
     }

     std::size_t size() const {
       return is_null() ? 0 : pointer()->size();
     }
     std::size_t length() const {
       return size();
     }

     char_type operator[](std::size_t i) const {
       return (*pointer())[i];
     }

     char_type at(std::size_t i) const {
       return pointer()->at(i);
     }

     const_iterator cbegin() const {
       return is_null() ? const_iterator{} : pointer()->cbegin();
     }
     const_iterator begin() const {
       return cbegin();
     }

     const_iterator cend() const {
       return is_null() ? const_iterator{} : pointer()->cend();
     }
     const_iterator end() const {
       return cend();
     }

     std::string utf8() const {
       if (length() == 0) {
         return std::string{};
       }
       std::size_t size = 0;
       for (char_type c : *this) {
         if ((c & ~0x7F) == 0) {
           size++;
         } else if ((c & ~0x7FF) == 0) {
           size+=2;
         } else if ((c & ~0xFFFF) == 0) {
           size+=3;
         } else if ((c & ~0x1FFFFF) == 0) {
           size+=4;
         } else if ((c & ~0x3FFFFFF) == 0) {
           size+=5;
         } else {
           size += 6;
         }
       }
       std::string utf8;
       utf8.reserve(size);
       for (char_type c : *this) {
         if ((c & ~0x7F) == 0) {
           utf8.push_back(static_cast<char>(c & 0x7F));
         } else if ((c & ~0x7FF) == 0) {
           utf8.push_back(static_cast<char>(0xC0 | ((c >> 6) & 0x1F)));
           utf8.push_back(static_cast<char>(0x80 | (c & 0x3F)));
         } else if ((c & ~0xFFFF) == 0) {
           utf8.push_back(static_cast<char>(0xE0 | ((c >> 12) & 0x0F)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 6) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | (c & 0x3F)));
         } else if ((c & ~0x1FFFFF) == 0) {
           utf8.push_back(static_cast<char>(0xF0 | ((c >> 18) & 0x07)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 12) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 6) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | (c & 0x3F)));
         } else if ((c & ~0x3FFFFFF) == 0) {
           utf8.push_back(static_cast<char>(0xF8 | ((c >> 24) & 0x03)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 18) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 12) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 6) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | (c & 0x3F)));
         } else {
           utf8.push_back(static_cast<char>(0xFC | ((c >> 30) & 0x03)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 24) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 18) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 12) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 6) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | (c & 0x3F)));
         }
       }
       return utf8;
     }


   };
   template<>
   struct mv_wrapper<kind::STRING> : public use_handle<managed_string_handle> {};


   template <typename Iter>
   inline interned_string_handle intern(const Iter &from, const Iter &to) {
     ensure_process_registered();
     return interned_string_handle{core::intern(from, to)};
   }

   inline interned_string_handle intern(const char *chars, std::size_t len) {
     ensure_process_registered();
     return interned_string_handle{core::intern(chars, len)};
   }

   // This is assumed to be a literal string (with a null byte at the end)
   template <std::size_t N>
   inline interned_string_handle intern(const char (&chars)[N]) {
     ensure_process_registered();
     return interned_string_handle{core::intern(chars)};
   }

   inline interned_string_handle intern(const char16_t *chars, std::size_t len) {
     ensure_process_registered();
     return interned_string_handle{core::intern(chars, len)};
   }
   // This is assumed to be a literal string (with a null byte at the end)
   template <std::size_t N>
   inline interned_string_handle intern(const char16_t (&chars)[N]) {
     ensure_process_registered();
     return interned_string_handle{core::intern(chars)};
   }

   inline interned_string_handle intern(const wchar_t *chars, std::size_t len) {
     ensure_process_registered();
     return interned_string_handle{core::intern(chars, len)};
   }
   // This is assumed to be a literal string (with a null byte at the end)
   template <std::size_t N>
   inline interned_string_handle intern(const wchar_t (&chars)[N]) {
     ensure_process_registered();
     return interned_string_handle{core::intern(chars)};
   }

   template <typename C, typename T, typename A>
   inline interned_string_handle intern(const std::basic_string<C,T,A> &s) {
     ensure_process_registered();
     return interned_string_handle{core::intern(s.begin(), s.end())};
   }

   inline
   const interned_string_handle &empty_string_() {
     static interned_string_handle s = intern("");
     return s;
   }



   template <bool ConstP>
   struct task_handle_cp
     : view_independent_handle<htarget_<ConstP,core::task>>
   {
     using base = view_independent_handle<htarget_<ConstP,core::task>>;
     using typename base::value_type;
     using non_const_type = task_handle_cp<false>;

     using weak_handle = typename base::template __weak_handle<task_handle_cp>;

     template <bool CP>
       using when_less_const = std::enable_if_t<(CP <= ConstP)>;

     using base::base;
     using base::is_null;
     using base::pointer;

     task_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     task_handle_cp(const task_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     task_handle_cp(task_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     task_handle_cp &
     operator =(const task_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     task_handle_cp &
     operator =(task_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     iso_context_handle get_context() const;

     task_handle get_parent() const {
       return is_null() ? task_handle{} : pointer()->get_parent();
     }

     static task_handle default_task() {
       ensure_process_registered();
       static task_handle t{core::global_context->top_level_task()};
       return t;
     }

     template <typename Fn>
       static void init_thread_base_task(Fn &&fn)
     {
       ensure_process_registered();
       core::task::init_thread_base_task(std::forward<Fn>(fn));
     }

     task_handle push() const {
       return is_null() ? task_handle{} : pointer()->push();
     }

     static task_handle push_new() {
       task_handle h =  core::task::push_new();
       return h;
     }

     static task_handle pop() {
       return core::task::pop();
     }

     void add_dependent(const task_handle &other) {
       pointer()->add_dependent_task(other.pointer());
     }

     void always_redo() {
       pointer()->unconditionally_redo();
     }

     void cannot_redo() {
       pointer()->set_not_redoable();
     }

   };

   iso_context_handle global_ic__();
   iso_context_handle for_process_ic__();

   template <bool ConstP>
   struct iso_context_handle_cp : view_independent_handle<htarget_<ConstP,core::iso_context>>
   {
     /*
      * Could put a shadow view cache here that we pass in to calls to short-circuit
      * the shadow calculation.  It would have to be atomic but would probably be faster
      * than going to NVM.
      */

     using base = view_independent_handle<htarget_<ConstP,core::iso_context>>;
     using typename base::value_type;
     using non_const_type = iso_context_handle_cp<false>;

     //     template <bool CP> using when_less_const = typename constness<ConstP>::when_less_const;
     template <bool CP>
       using when_less_const = std::enable_if_t<(CP <= ConstP)>;

     using base::base;
     using base::is_null;
     using base::pointer;

     iso_context_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     iso_context_handle_cp(const iso_context_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     iso_context_handle_cp(iso_context_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     iso_context_handle_cp &
     operator =(const iso_context_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     iso_context_handle_cp &
     operator =(iso_context_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }


     bool is_snapshot() const {
       return is_null() ? false : pointer()->is_snapshot();
     }

     bool is_read_only() const {
       return is_null() ? true : pointer()->is_read_only();
     }

     bool is_publishable() const {
       return is_null() ? false : pointer()->is_publishable();
     }

     iso_context_handle parent() const {
       return is_null() ? iso_context_handle{} : pointer()->parent();
     }

     iso_context_handle ro_snapshot_at(core::timestamp_t ts) const {
       return is_null()
           ? iso_context_handle{}
       : pointer()->as_of(ts, core::view_type::snapshot, core::mod_type::read_only);
     }

     static iso_context_handle global() {
       return global_ic__();
     }
     static iso_context_handle for_process() {
       return for_process_ic__();
     }

     /*
      * Throws read_only_context_ex if context is read_only and mod type is full.
      */
     iso_context_handle new_child(view_type vt, mod_type mt) const {
       return iso_context_handle{pointer()->new_child(vt, mt)};
     }
     iso_context_handle new_snapshot_child(mod_type mt = mod_type::publishable) const {
       return new_child(view_type::snapshot, mt);
     }
     iso_context_handle new_nonsnapshot_child(mod_type mt = mod_type::publishable) const {
       return new_child(view_type::live, mt);
     }
     iso_context_handle new_detached_snapshot_child() const {
       return new_snapshot_child(mod_type::detached);
     }
     iso_context_handle new_detached_nonsnapshot_child() const {
       return new_nonsnapshot_child(mod_type::detached);
     }
     iso_context_handle new_read_only_snapshot_child() const {
       return new_snapshot_child(mod_type::read_only);
     }
     iso_context_handle new_read_only_nonsnapshot_child() const {
       return new_nonsnapshot_child(mod_type::read_only);
     }
     /*
      * Throws unmergeable_context_ex if not mergeable
      */
     publication_attempt_handle publish();

     task_handle push_prevailing() {
       return pointer()->push_prevailing();
     }

     bool has_conflicts() const {
       return pointer()->has_conflicts();
     }

     task_handle top_level_task() const {
       return pointer()->top_level_task();
     }

     task_handle creation_task() const {
       return pointer()->creation_task();
     }

   };


   inline iso_context_handle global_ic__() {
     ensure_process_registered();
     static iso_context_handle ctxt{core::global_context};
     return ctxt;
   }
   inline iso_context_handle for_process_ic__() {
     static iso_context_handle ctxt{global_ic__().new_child(view_type::live, mod_type::publishable)};
     return ctxt;
   }

   template <bool CP>
   inline
   iso_context_handle
   task_handle_cp<CP>::get_context() const {
       return is_null() ? iso_context_handle{} : pointer()->get_context();
     }

   template <bool ConstP>
   struct publication_attempt_handle_cp
     : view_independent_handle<htarget_<ConstP,core::publication_attempt>>
   {
     using base = view_independent_handle<htarget_<ConstP,core::publication_attempt>>;
     using typename base::value_type;
     using non_const_type = publication_attempt_handle_cp<false>;

     template <bool CP>
       using when_less_const = std::enable_if_t<(CP <= ConstP)>;

     using base::base;
     using base::is_null;
     using base::pointer;

     publication_attempt_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     publication_attempt_handle_cp(const publication_attempt_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     publication_attempt_handle_cp(publication_attempt_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     publication_attempt_handle_cp &
     operator =(const publication_attempt_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     publication_attempt_handle_cp &
     operator =(publication_attempt_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     bool succeeded() const {
       return pointer()->succeeded();
     }

     iso_context_handle source_context() const {
       return pointer()->context();
     }

     long n_to_redo() const {
       return pointer()->n_to_redo();
     }

     std::vector<task_handle> redo_tasks_by_start_time() const {
       std::vector<mpgc::gc_ptr<core::task>> tasks = pointer()->redo_tasks_by_start_time();
       std::vector<task_handle> handles(tasks.begin(), tasks.end());
       return handles;
     }

     bool prepare_for_redo() const {
       return pointer()->prepare_for_redo();
     }

   };

   template <bool CP>
   inline publication_attempt_handle
   iso_context_handle_cp<CP>::publish()
   {
     return pointer()->publish();
   }
   

   template <bool ConstP>
   struct managed_record_handle_cp : view_relative_handle<htarget_<ConstP,core::managed_record>>
   {
     /*
      * Could put a shadow view cache here that we pass in to calls to short-circuit
      * the shadow calculation.  It would have to be atomic but would probably be faster
      * than going to NVM.
      */

     using base = view_relative_handle<htarget_<ConstP,core::managed_record>>;
     using typename base::value_type;
     using non_const_type = managed_record_handle_cp<false>;

     //     template <bool CP> using when_less_const = typename constness<ConstP>::when_less_const;
     template <bool CP> using when_less_const = std::enable_if_t<(CP <= ConstP)>;

     using base::base;
     using base::is_null;
     using base::pointer;

     managed_record_handle_cp() = default;
     managed_record_handle_cp(const managed_record_handle_cp &) = default;
     managed_record_handle_cp(managed_record_handle_cp &&) = default;

     template <bool CP, typename = when_less_const<CP> >
     managed_record_handle_cp(const managed_record_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     managed_record_handle_cp(managed_record_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     managed_record_handle_cp &operator =(const managed_record_handle_cp &) = default;
     managed_record_handle_cp &operator =(managed_record_handle_cp &&) = default;

     template <bool CP, typename = when_less_const<CP> >
     managed_record_handle_cp &
     operator =(const managed_record_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     managed_record_handle_cp &
     operator =(managed_record_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     const_record_type_handle type() const;
     uniform_key uuid() const {
       return pointer()->uuid();
     }
   };

   template<>
   struct mv_wrapper<kind::RECORD> : public use_handle<managed_record_handle> {};

   template <kind K, bool ConstP>
   struct record_field_handle_cp
   : public view_independent_handle<htarget_<ConstP,const kind_field<K>>>
   {
     using base = view_independent_handle<htarget_<ConstP,const kind_field<K>>>;
     using typename base::value_type;
     using non_const_type = record_field_handle_cp<K, false>;

     //     template <bool CP> using when_less_const = typename constness<ConstP>::when_less_const;
     template <bool CP> using when_less_const = std::enable_if_t<(CP <= ConstP)>;


     using base::base;
     using base::is_null;
     using base::pointer;

     record_field_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     record_field_handle_cp(const record_field_handle_cp<K,CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     record_field_handle_cp(record_field_handle_cp<K,CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     record_field_handle_cp &
     operator =(const record_field_handle_cp<K,CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     record_field_handle_cp &
     operator =(record_field_handle_cp<K,CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     /*
      * NOTE: This doesn't work if we let FT be something abstract like "collection".
      * I'm assuming that it is fully specified, at least down to "record" for any
      * record type.
      */
     api_type<K> free_read(const managed_record_handle &r) const {
       api_type<K> val = pointer()->free_read(r.pointer(), r.view());
       // std::cout << "Free read " << val << std::endl;
       return val;
     }
     api_type<K> frozen_read(const managed_record_handle &r) const {
       api_type<K> val =  pointer()->frozen_read(r.pointer(), r.view());
       // std::cout << "Frozen read " << val << std::endl;
       return val;
     }
     bool has_value(const managed_record_handle &r) const {
       return is_null() ? false : pointer()->has_value(r.pointer(), r.view());
     }
     /*
      * Throws read_only_context_ex if context is read only
      */
     api_type<K> modify(const managed_record_handle &r,
                        modify_op op,
                        const api_type<K> &val,
                        ret_mode returning = ret_mode::resulting_val) const
     {
       api_type<K> rv =  pointer()->modify(r.pointer(), r.view(), op,
                                           to_core_val<K>(val), returning);
       // std::cout << "Modify returned " << rv << std::endl;
       return rv;
     }
     api_type<K> write(const managed_record_handle &r,
		       const api_type<K> &val,
		       ret_mode returning = ret_mode::resulting_val) const
     {
       return pointer()->write(r.pointer(), r.view(), to_core_val<K>(val), returning);
     }
     bool write_initial(const managed_record_handle &r,
                        const api_type<K> &val) const
     {
       try {
         pointer()->write(r.pointer(), r.view(), to_core_val<K>(val),
                          ret_mode::resulting_val, core::is_unbound_guard<K>());
         return true;
       } catch (core::guard_failure_ex &) {
         return false;
       }
     }
     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> add(const managed_record_handle &r,
		       const api_type<K> &val,
		       ret_mode returning = ret_mode::resulting_val) const
     {
       return pointer()->add(r.pointer(), r.view(), val, returning);
     }
     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> sub(const managed_record_handle &r,
		       const api_type<K> &val,
		       ret_mode returning = ret_mode::resulting_val) const
     {
       return pointer()->sub(r.pointer(), r.view(), val, returning);
     }
     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> mul(const managed_record_handle &r,
		       const api_type<K> &val,
		       ret_mode returning = ret_mode::resulting_val) const {
       return pointer()->mul(r.pointer(), r.view(), val, returning);
     }
     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> div(const managed_record_handle &r,
		       const api_type<K> &val,
		       ret_mode returning = ret_mode::resulting_val) const {
       return pointer()->div(r.pointer(), r.view(), val, returning);
     }

     interned_string_handle name() const {
       return pointer()->name;
     }

     const_record_type_handle rec_type() const;
     const_type_handle_for<K> field_type() const;
   };

   template <bool ConstP>
   struct managed_array_base_handle_cp
   : public view_relative_handle<htarget_<ConstP,core::managed_array_base>>
   {
     using base = view_relative_handle<htarget_<ConstP,core::managed_array_base>>;
     using typename base::value_type;
     using non_const_type = managed_array_base_handle_cp<false>;

     template <bool CP> using when_less_const = typename constness<CP>::when_less_const;

     using base::base;
     using base::is_null;
     using base::pointer;

     managed_array_base_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     managed_array_base_handle_cp(const managed_array_base_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     managed_array_base_handle_cp(managed_array_base_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     managed_array_base_handle_cp &
     operator =(const managed_array_base_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     managed_array_base_handle_cp &
     operator =(managed_array_base_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     const_array_type_base_handle type() const;
     uniform_key uuid() const {
       return pointer()->uuid();
     }
   };

   template <kind K, bool ConstP>
   struct managed_array_handle_cp
   : public view_relative_handle<htarget_<ConstP,core::managed_array<K>>>
   {
     using base = view_relative_handle<htarget_<ConstP,core::managed_array<K>>>;
     using typename base::value_type;
     using non_const_type = managed_array_handle_cp<K, false>;

     template <bool CP> using when_less_const = typename constness<CP>::when_less_const;

     using base::base;
     using base::is_null;
     using base::pointer;
     using base::view;

     managed_array_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     managed_array_handle_cp(const managed_array_handle_cp<K,CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     managed_array_handle_cp(managed_array_handle_cp<K,CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     managed_array_handle_cp &
     operator =(const managed_array_handle_cp<K,CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     managed_array_handle_cp &
     operator =(managed_array_handle_cp<K,CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     const_array_type_handle<K> type() const;
     uniform_key uuid() const {
       return pointer()->uuid();
     }

     api_type<K> free_read(const array_index_type i) const
     {
       return pointer()->free_read(i, view());
     }
     api_type<K> frozen_read(const array_index_type i) const
     {
       return pointer()->frozen_read(i, view());
     }

     api_type<K> write(const array_index_type i,
                       modify_op op,
                       const api_type<K> &val,
                       ret_mode returning = ret_mode::resulting_val) const
     {
       return pointer()->modify(i, view(), op, to_core_val<K>(val), returning);
     }

     api_type<K> write(const array_index_type i,
                       const api_type<K> &val,
                       ret_mode returning = ret_mode::resulting_val) const
     {
       return pointer()->write(i, view(), to_core_val<K>(val), returning);
     }

     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> add(const array_index_type i,
		       const api_type<K> &val,
		       ret_mode returning = ret_mode::resulting_val) const
     {
       return pointer()->add(i, view(), val, returning);
     }
     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> sub(const array_index_type i,
		       const api_type<K> &val,
		       ret_mode returning = ret_mode::resulting_val) const
     {
       return pointer()->sub(i, view(), val, returning);
     }
     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> mul(const array_index_type i,
		       const api_type<K> &val,
		       ret_mode returning = ret_mode::resulting_val) const
     {
       return pointer()->mul(i, view(), val, returning);
     }
     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> div(const array_index_type i,
		       const api_type<K> &val,
		       ret_mode returning = ret_mode::resulting_val) const {
       return pointer()->div(i, view(), val, returning);
     }

     bool has_value(const array_index_type i) const {
       return is_null() ? false : pointer()->has_value(i, view());
     }

     array_size_type<K> size() const {
       return pointer()->size;
     }

     managed_array_base_handle_cp<ConstP> as_base() {
       return managed_array_base_handle_cp<ConstP>(pointer(), view());
     }
   };

   // su - TODO - this needs work
   template <>
   struct mv_wrapper<kind::ARRAY> : public use_handle<managed_array_base_handle> {};

   template <kind K, bool ConstP, typename LeafT, typename Enable>
   struct managed_type_handle_cp: public view_independent_handle<htarget_<ConstP, LeafT>>
   {
     using base = view_independent_handle<htarget_<ConstP, LeafT>>;
     using typename base::value_type;
     using non_const_type = managed_type_handle_cp<K, false, LeafT, Enable>;

     //     template <bool CP> using when_less_const = typename constness<ConstP>::when_less_const;
     template <bool CP> using when_less_const = std::enable_if_t<(CP <= ConstP)>;

     using base::base;
     using base::is_null;
     using base::pointer;

     managed_type_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     managed_type_handle_cp(const managed_type_handle_cp<K,CP,LeafT,Enable> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     managed_type_handle_cp(managed_type_handle_cp<K,CP,LeafT,Enable> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     managed_type_handle_cp &
     operator =(const managed_type_handle_cp<K,CP,LeafT,Enable> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     managed_type_handle_cp &
     operator =(managed_type_handle_cp<K,CP,LeafT,Enable> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

#if 0
     std::remove_const_t<value_type> *nc_value() const {
       value_type *cval = value;
       return const_cast<std::remove_const_t<value_type> *>(cval);
     }
#endif
     /*
      * Throws incompatible_type_ex if the field exists but is of the wrong type
      *
      * Throws unmodifiable_record_type_ex if the field doesn't exist, create_if_absent
      * is true, and the record type is fully created.
      */
     // TODO: Add const_record_type_handle variant
     record_field_handle<K> field_in(const record_type_handle &rtype,
                                     const interned_string_handle &name,
                                     bool create_if_absent = true) const;
   };


   template <bool ConstP>
   struct array_type_base_handle_cp : managed_type_handle_cp<kind::ARRAY, ConstP, core::array_type_base>
   {
     using base = managed_type_handle_cp<kind::ARRAY, ConstP, core::array_type_base>;
     using typename base::value_type;
     using non_const_type = array_type_base_handle_cp<false>;

     template <bool CP> using when_less_const = typename constness<CP>::when_less_const;

     using base::base;
     using base::is_null;
     using base::pointer;

     array_type_base_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     array_type_base_handle_cp(const array_type_base_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     array_type_base_handle_cp(array_type_base_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     array_type_base_handle_cp &
     operator =(const array_type_base_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     array_type_base_handle_cp &
     operator =(array_type_base_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     template <bool CP>
     bool is_same_as(const array_type_base_handle_cp<CP> &rhs) const {
       if (pointer() == rhs.pointer()) {
         return true;
       } else if (!is_null()) {
         return pointer()->compare_types(rhs.pointer());
       } else {
         return false;
       }
     }
     template <bool CP>
     bool operator !=(const array_type_base_handle_cp<CP> &rhs) const {
       return !operator==(rhs);
     }
   };


   template <kind K, bool ConstP>
   struct array_type_handle_cp : managed_type_handle_cp<kind::ARRAY, ConstP, core::array_type<K>>
   {
     // su - TODO
     //   1. Add type logic
     //       managed_type<K> element_type()
     using base = managed_type_handle_cp<kind::ARRAY, ConstP, core::array_type<K>>;
     using typename base::value_type;
     using non_const_type = array_type_handle_cp<K, false>;

     template <bool CP> using when_less_const = typename constness<CP>::when_less_const;

     using base::base;
     using base::is_null;
     using base::pointer;

     array_type_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     array_type_handle_cp(const array_type_handle_cp<K,CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     array_type_handle_cp(array_type_handle_cp<K,CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     array_type_handle_cp &
     operator =(const array_type_handle_cp<K,CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     array_type_handle_cp &
     operator =(array_type_handle_cp<K,CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     const_managed_type_handle<K> element_type() const {
       return pointer()->element_type();
     }

     managed_array_handle<K>
     create_array(array_size_type<K> s) const {
       return pointer()->create_array(s);
     }

     template <bool CP>
     bool is_same_as(const array_type_handle_cp<K, CP> &rhs) const {
       if (pointer() == rhs.pointer()) {
         return true;
       } else if (!is_null()) {
         return pointer()->compare_types(rhs.pointer());
       } else {
         return false;
       }
     }
     
     template <bool CP>
     bool operator !=(const array_type_handle_cp<K, CP> &rhs) const {
       return !operator==(rhs);
     }

   };



//   template <typename FT> struct mv_wrapper<core::managed_type<FT>> : public use_handle<managed_type_handle<FT>> {};

#define _PRIM_TYPE_(K,name) \
  inline const_managed_type_handle<K> managed_##name##_type_handle() { \
   static const_managed_type_handle<K> \
   type((ensure_process_registered(), core::managed_##name##_type)); \
   return type; \
  } \
   \
  inline const_array_type_handle<K> managed_##name##_array_type_handle() { \
   static const_array_type_handle<K> \
     type((ensure_process_registered(), core::managed_##name##_type->in_array())); \
   return type; \
  }

   _PRIM_TYPE_(kind::BOOL,bool)
   _PRIM_TYPE_(kind::BYTE,byte)
   _PRIM_TYPE_(kind::UBYTE,ubyte)
   _PRIM_TYPE_(kind::SHORT,short)
   _PRIM_TYPE_(kind::USHORT,ushort)
   _PRIM_TYPE_(kind::INT,int)
   _PRIM_TYPE_(kind::UINT,uint)
   _PRIM_TYPE_(kind::LONG,long)
   _PRIM_TYPE_(kind::ULONG,ulong)
   _PRIM_TYPE_(kind::FLOAT,float)
   _PRIM_TYPE_(kind::DOUBLE,double)
   _PRIM_TYPE_(kind::STRING,string)

   template<kind KIND>
     inline const_managed_type_handle<KIND>
     managed_handle_by_kind ()
     {
	static const_managed_type_handle<KIND> type (
	    (ensure_process_registered (), core::global_managed_type<KIND>()));
	return type;
     }

   template<kind KIND>
     inline const_array_type_handle<KIND>
     managed_array_handle_by_kind ()
     {
       static const_array_type_handle<KIND> type (
            (ensure_process_registered (), core::global_managed_type<KIND>()->in_array ()));
   	return type;
     }

   template <bool ConstP>
   struct record_type_handle_cp : managed_type_handle_cp<kind::RECORD, ConstP, core::record_type>
   {
     using base = managed_type_handle_cp<kind::RECORD, ConstP, core::record_type>;
     using typename base::value_type;
     using non_const_type = record_type_handle_cp<false>;

     //     template <bool CP> using when_less_const = typename constness<ConstP>::when_less_const;
     template <bool CP> using when_less_const = std::enable_if_t<(CP <= ConstP)>;

     using base::base;
     using base::is_null;
     using base::pointer;

     record_type_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     record_type_handle_cp(const record_type_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     record_type_handle_cp(record_type_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     record_type_handle_cp &
     operator =(const record_type_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     record_type_handle_cp &
     operator =(record_type_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     managed_record_handle create_record() const {
       return pointer()->create_record();
     }
     bool is_created() const {
       return is_null() ? false : pointer()->is_created();
     }

     interned_string_handle name() const {
       return is_null() ? interned_string_handle{} : pointer()->name();
     }

     const_record_type_handle super_type() const {
       return is_null() ? const_record_type_handle{} : pointer()->super_type();
     }

     /*
      * Returns a handle to the core object that represents this type.  It may be this handle or
      * a handle to another one that was created while we were making this one.  The old handle
      * will continue to work, but it may be more efficient to replace references with this one.
      * Similarly, we may want to ask again about fields and replace references.
      */
     const_record_type_handle ensure_created() const {
       // This is null if this is the correct one or a pointer to the one that was created between
       // the time we created ours and this call.  The caller may want to update references.
       core::gc_ptr<const core::record_type> r = pointer()->ensure_created();
       return r == nullptr ? *this : const_record_type_handle{r};
     }
     static const_record_type_handle find(const interned_string_handle &name) {
       ensure_process_registered();
       return core::record_type::find(name.pointer());
     }

     template <bool CP>
     bool is_same_as(const record_type_handle_cp<CP> &rhs) const {
       if (pointer() == rhs.pointer()) {
         return true;
       } else if (!is_null()) {
         return pointer()->compare_types(rhs.pointer());
       } else {
         return false;
       }
     }
     template <bool CP>
     bool operator !=(const record_type_handle_cp<CP> &rhs) const {
       return !operator==(rhs);
     }
     template <bool CP>
     bool is_super_of(const record_type_handle_cp<CP> &other) const {
       return is_null() ? false : pointer()->is_super_of(other.pointer());
     }

     /*
      * I'm going to punt on multiple inheritence for a while.  It's not needed for the initial
      * demo, and I can't figure out an efficient layout for doing the dispatch.
      */

     static record_type_handle declare(const interned_string_handle &name,
                                       const const_record_type_handle &super = const_record_type_handle{}) {
       ensure_process_registered();
       core::gc_ptr<core::record_type> rt = core::record_type::declare(name.pointer(), super.pointer());
       return rt;
     }

   };

   template <bool ConstP>
   inline
   const_record_type_handle
   managed_record_handle_cp<ConstP>::type() const {
     if (is_null()) {
       return nullptr;
     }
     return pointer()->r_type;
   }


   template <kind K, bool ConstP>
   inline
   const_record_type_handle
   record_field_handle_cp<K,ConstP>::rec_type() const {
     return pointer()->r_type;
   }

   template <kind K, bool ConstP>
   inline
   const_type_handle_for<K>
   record_field_handle_cp<K,ConstP>::field_type() const {
     return pointer()->f_type;
   }

   //   template <> struct mv_wrapper<core::record_type> : public use_handle<record_type_handle> {};
   //
   template <bool ConstP>
   struct namespace_handle_cp : public view_relative_handle<htarget_<ConstP,core::name_space>> {
     using base = view_relative_handle<htarget_<ConstP,core::name_space>>;
     using typename base::value_type;
     using non_const_type = namespace_handle_cp<false>;

     //     template <bool CP> using when_less_const = typename constness<ConstP>::when_less_const;
     template <bool CP> using when_less_const = std::enable_if_t<(CP <= ConstP)>;

     using base::base;
     using base::is_null;
     using base::pointer;
     using base::view;

     namespace_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     namespace_handle_cp(const namespace_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     namespace_handle_cp(namespace_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     namespace_handle_cp &
     operator =(const namespace_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     namespace_handle_cp &
     operator =(namespace_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     template <bool C1>
     namespace_handle child_namespace(const interned_string_handle_cp<C1> &name,
                                      bool create_if_missing)
     {
       return namespace_handle{pointer()->child_namespace(name.pointer(),
                                                          view(),
                                                          create_if_missing)};
     }
     /*
      * Throws unbound_name_ex if the name is unbound.
      *
      * Throws incompatible_type_ex if the name is bound but not to
      * something that can be considered to be of this type (e.g., the
      * same type or a record type of a subclass of this type).
      */
     template <kind K, bool C1>
       api_type<K> _lookup(const interned_string_handle_cp<C1> &name,
                           const core::external_gc_ptr<core::view> &v) const
     {
       return pointer()->template read<K>(name.pointer(), v);
     }
     template <kind K, typename LeafT, bool C1, bool C2>
     api_type<K> lookup(const interned_string_handle_cp<C1> &name,
                        const managed_type_handle_cp<K,C2,LeafT> &type) const
     {
       return _lookup<K>(name, view());
     }
     template <bool C1, bool C2>
     managed_record_handle lookup(const interned_string_handle_cp<C1> &name,
                                  const record_type_handle_cp<C2> &rt) const
     {
       managed_record_handle mrh = _lookup<kind::RECORD>(name, view());
       /*
        * If we get here, it's bound to a record, but it might not be something
        * of the kind we expect.
        */
       const_record_type_handle old_rt = mrh.type();
       if (!rt.is_super_of(old_rt)) {
         throw incompatible_type_ex{};
       }
       return mrh;
     }

     // su - TODO error handling
     template <kind K, bool C1, bool C2>
     managed_array_handle<K> lookup(const interned_string_handle_cp<C1> &name,
                                    const array_type_handle_cp<K,C2> &at) const
     {
       managed_array_base_handle mabh = _lookup<kind::ARRAY>(name, view());
       managed_array_handle<K>   mah  = 
         managed_array_handle<K>(
           mabh.pointer()->template downcast<K>(),
           mabh.view()
           );

       return mah;
     }

     /*
      * Replaces binding of "name" with "val".  Returns false if name
      * bound to namespace and replace_namespace is false, true
      * otherwise.
      */
     template <kind K, bool C1>
     bool bind(const interned_string_handle_cp<C1> &name,
               const api_type<K> &val,
               ret_mode returning = ret_mode::resulting_val,
               bool replace_namespace = false) const
     {
       return pointer()->bind<K>(name.pointer(), view(), api::to_core_val<K>(val), replace_namespace);
     }
     /*
      * Binds "name" to "val", but only if there is no prior binding.
      * Returns whether it bound
      */
     template <kind K, bool C1>
     bool bind_new(const interned_string_handle_cp<C1> &name,
                   const api_type<K> &val) const
     {
       throw core::unimplemented{};
     }
     /*
      * Binds "name" to "val", but only if there was a prior binding.
      * Returns whether it bound
      */
     template <kind K, bool C1>
     bool replace_binding(const interned_string_handle_cp<C1> &name,
                          const api_type<K> &val) const
     {
       throw core::unimplemented{};
     }
     /*
      * Binds "name" to "val", but only if it was bound to "expected".
      * Returns whether it bound
      */
     template <kind K, kind K2, bool C1>
     bool replace_binding(const interned_string_handle_cp<C1> &name,
                          const api_type<K> &val,
                          const api_type<K2> &expected) const
     {
       throw core::unimplemented{};
     }

     template <bool C1>
     bool is_bound(const interned_string_handle_cp<C1> &name) const
     {
       return pointer()->is_bound(name.pointer(), view());
     }
     template <kind K, bool C1>
     bool is_bound_to(const interned_string_handle_cp<C1> &name,
                      const api_type<K> &expected) const
     {
       throw core::unimplemented{};
     }

     template <bool C1>
     bool unbind(const interned_string_handle_cp<C1> &name) const
     {
       throw core::unimplemented{};
     }
     template <kind K, bool C1>
     bool unbind_from(const interned_string_handle_cp<C1> &name,
                      const api_type<K> &expected) const
     {
       throw core::unimplemented{};
     }

     struct illegal_path_ex {
       std::vector<interned_string_handle> valid_prefix;
       interned_string_handle not_namespace;
       template <typename Iter>
       illegal_path_ex(const Iter &start, const Iter &end, const interned_string_handle &name)
       : valid_prefix(start, end), not_namespace{name}
       {}
     };

     static namespace_handle global() {
       return namespace_handle{core::global_namespace, prevailing_view()};
     }
     /*
      * Throws illegal_path_ex if one of the segments on the path is not a namespace.
      * If one of the segments is unbound, returns a null namespace_handle.
      */
     template <typename Iter>
     static namespace_handle
     from_existing_path(const Iter &path_start, const Iter &path_end) {
       return _path(path_start, path_end, false);
     }

     /*
      * Throws illegal_path_ex if one of the segments on the path is not a namespace.
      * If a suffix is unbound, creates namespaces.
      */
     template <typename Iter>
     static namespace_handle
     from_path(const Iter &path_start, const Iter &path_end) {
       return _path(path_start, path_end, true);
     }

   private:
     static mpgc::gc_ptr<core::view> prevailing_view() {
       return core::iso_context::prevailing()->shadow(core::top_level_view);
     }
     
     template <typename Iter>
     static namespace_handle _path(const Iter &path_start, const Iter &path_end,
                                   bool create_namespaces)
     {
       using namespace core;
       const mpgc::gc_ptr<core::view> v = prevailing_view();
       managed_value<name_space> d{global_namespace, v};
       for (Iter p = path_start; d != nullptr && p != path_end; p++) {
         interned_string_handle name = *p;
         try {
           d = d.value->child_namespace(name.pointer(), d.in_view, create_namespaces);
         } catch (incompatible_type_ex &) {
           /*
            * We found something that wasn't a namespace.
            */
           throw illegal_path_ex{path_start, p, name};
         }
       }
       return namespace_handle{d};
     }


   };



   template <kind K, bool ConstP, typename LeafT, typename Enable>
   inline
   record_field_handle<K>
   managed_type_handle_cp<K,ConstP,LeafT,Enable>::
   field_in(const record_type_handle &rtype, const interned_string_handle &name, bool create_if_absent) const {
     //     return nc_value()->field_in(rtype.nc_value(), name.value, create_if_absent);
     return pointer()->field_in(rtype.pointer(), name.pointer(), create_if_absent);
   }

   /*
    * This is a convenience class to allow stashing handles someplace
    * so that you can refer to them by an index, suitable for storing
    * in a Java object.  If you do so, remember to call free() when
    * the last use of the handle is gone (e.g., in a native finalize()
    * method).  If you can hold the handle directly, it will be more
    * efficient.  No effort is made to determine that the handle is
    * not already in the store.  What is returned is a copy of the
    * handle, so modifications are not preserved.
    *
    * index 0 is reserved to indicate a value of T{} (null handle,
    * null pointer, or zero value).  Otherwise, index i refers to the
    * (i-1)th element of the vector.
    */
   template <typename T>
   class handle_store {
   public:
     using index_type = std::size_t;
   private:
     std::stack<std::size_t> _free_list;
     std::vector<T> _handles;
     mutable std::mutex _mutex;
     static handle_store &_store() {
       static handle_store hs;
       return hs;
     }
     index_type _store(const T &handle) {
       if (handle == T{}) {
         return 0;
       }
       std::lock_guard<std::mutex> lock{_mutex};
       if (_free_list.empty()) {
         _handles.push_back(handle);
         index_type i = _handles.size();
         return i;
       } else {
         index_type i = _free_list.top();
         _free_list.pop();
         _handles[i-1] = handle;
         return i;
       }
     }

     void _free(index_type i) {
       if (i != 0) {
         std::lock_guard<std::mutex> lock{_mutex};
         _free_list.push(i);
         _handles[i-1] = T{};
       }
     }

     T _get(index_type i) {
       if (i == 0) {
         return T{};
       }
       std::lock_guard<std::mutex> lock{_mutex};
       return _handles[i-1];
     }
   public:
     static index_type store(const T &handle) {
       return _store()._store(handle);
     }
     static void free(index_type i) {
       _store()._free(i);
     }
     static T get(index_type i) {
       return _store()._get(i);
     }

   };

   /*
    * This is a convenience class to allow stashing handles someplace
    * so that you can refer to them by an index, suitable for storing
    * in a Java object.  If you do so, remember to call free() when
    * the last use of the handle is gone (e.g., in a native finalize()
    * method).  If you can hold the handle directly, it will be more
    * efficient.
    *
    * In this variant (unlike in handle_store), only one instance of
    * each handle is kept, so identical indices imply identical
    * handles.  Note that this only applies while the handle is in the
    * store.  Each entry in the store keeps a reference count,
    * incremented by calls to store(h) and decremented by calls to
    * free(i).  When this count hits zero, free() returns true, and
    * the index may be reused for another handle.
    *
    * Calls to store(h), by default, assume that the returned index
    * will be used to create a new wrapper object (which will call
    * free() in its finalize method), so the reference count is
    * incremented.  Users who maintain a side table of objects, so
    * they can be reused, should pass in a second parameter of false,
    * which indicates that the reference count should not be
    * incremented if the handle exists in the table.  The return value
    * from store() includes an indication of whether the handle was
    * added to the store by this operation.
    *
    * No effort is made to determine that the handle is not already in
    * the store.  What is returned is a copy of the handle, so
    * modifications are not preserved.
    *
    * index 0 is reserved to indicate a value of T{} (null handle,
    * null pointer, or zero value).  Otherwise, index i refers to the
    * (i-1)th element of the vector.
    */
   template <typename T>
   class unique_handle_store {
   public:
     using index_type = std::size_t;
     struct return_type {
       bool is_new_index;
       index_type index;
       return_type(bool nip, index_type i) : is_new_index{nip}, index{i} {}
       operator index_type() const {
         return index;
       }
     };
   private:
     struct counted_handle {
       std::size_t count;
       T handle;
       counted_handle(const T &h) : count{0}, handle{h} {}
     };
     std::stack<std::size_t> _free_list;
     std::vector<counted_handle> _handles;
     std::unordered_map<T,index_type> _known;
     mutable std::mutex _mutex;
     static unique_handle_store &_store() {
       static unique_handle_store hs;
       return hs;
     }
     return_type _store(const T &handle, bool inc_if_existsp) {
       if (handle == T{}) {
         return return_type{false, 0};
       }
       std::lock_guard<std::mutex> lock{_mutex};
       index_type &i = _known[handle];
       bool is_new = i==0;
       if (is_new) {
         // This one was not in the map.
         if (_free_list.empty()) {
           _handles.push_back(handle);
           i = _handles.size();
         } else {
           i = _free_list.top();
           _free_list.pop();
           _handles[i-1] = handle;
         }
       }
       if (is_new || inc_if_existsp) {
         _handles[i-1].count++;
       }
       return return_type{is_new, i};
     }

     bool _free(index_type i) {
       if (i != 0) {
         std::lock_guard<std::mutex> lock{_mutex};
         counted_handle &h = _handles[i-1];
         if (--h.count == 0) {
           _free_list.push(i);
           _known.erase(h.handle);
           h.handle = T{};
           return true;
         } else {
           return false;
         }
       }
       return false;
     }

     T _get(index_type i) {
       if (i == 0) {
         return T{};
       }
       std::lock_guard<std::mutex> lock{_mutex};
       return _handles[i-1].handle;
     }

     void _add_ref(index_type i) {
       if (i != 0) {
	 std::lock_guard<std::mutex> lock{_mutex};
	 _handles[i-1].count++;
       }
     }
   public:
     static return_type store(const T &handle, bool inc_if_existsp = true) {
       return _store()._store(handle, inc_if_existsp);
     }
     static bool free(index_type i) {
       return _store()._free(i);
     }
     static T get(index_type i) {
       return _store()._get(i);
     }
     static void add_ref(index_type i) {
       _store()._add_ref(i);
     }

   };
 }

}

namespace ruts {

 template <bool CP>
 struct hash1<mds::api::interned_string_handle_cp<CP>>
   : intrinsic_hash1<mds::api::interned_string_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::interned_string_handle_cp<CP>>
   : intrinsic_hash2<mds::api::interned_string_handle_cp<CP>> {};

 template <bool CP>
 struct hash1<mds::api::iso_context_handle_cp<CP>>
   : intrinsic_hash1<mds::api::iso_context_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::iso_context_handle_cp<CP>>
   : intrinsic_hash2<mds::api::iso_context_handle_cp<CP>> {};

 template <bool CP>
 struct hash1<mds::api::publication_attempt_handle_cp<CP>>
   : intrinsic_hash1<mds::api::publication_attempt_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::publication_attempt_handle_cp<CP>>
   : intrinsic_hash2<mds::api::publication_attempt_handle_cp<CP>> {};

 template <bool CP>
 struct hash1<mds::api::task_handle_cp<CP>>
   : intrinsic_hash1<mds::api::task_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::task_handle_cp<CP>>
   : intrinsic_hash2<mds::api::task_handle_cp<CP>> {};

 template <bool CP>
 struct hash1<mds::api::managed_record_handle_cp<CP>>
   : intrinsic_hash1<mds::api::managed_record_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::managed_record_handle_cp<CP>>
   : intrinsic_hash2<mds::api::managed_record_handle_cp<CP>> {};

 template <bool CP>
 struct hash1<mds::api::managed_array_base_handle_cp<CP>>
   : intrinsic_hash1<mds::api::managed_array_base_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::managed_array_base_handle_cp<CP>>
   : intrinsic_hash2<mds::api::managed_array_base_handle_cp<CP>> {};

 template <mds::api::kind K, bool CP>
 struct hash1<mds::api::managed_array_handle_cp<K,CP>>
   : intrinsic_hash1<mds::api::managed_array_handle_cp<K,CP>> {};
 template <mds::api::kind K, bool CP>
 struct hash2<mds::api::managed_array_handle_cp<K,CP>>
   : intrinsic_hash2<mds::api::managed_array_handle_cp<K,CP>> {};

 template <mds::api::kind K, bool CP>
 struct hash1<mds::api::record_field_handle_cp<K,CP>>
   : intrinsic_hash1<mds::api::record_field_handle_cp<K,CP>> {};
 template <mds::api::kind K, bool CP>
 struct hash2<mds::api::record_field_handle_cp<K,CP>>
   : intrinsic_hash2<mds::api::record_field_handle_cp<K,CP>> {};

 template <mds::api::kind K, bool CP, typename L>
 struct hash1<mds::api::managed_type_handle_cp<K,CP,L>>
   : intrinsic_hash1<mds::api::managed_type_handle_cp<K,CP,L>> {};
 template <mds::api::kind K, bool CP, typename L>
 struct hash2<mds::api::managed_type_handle_cp<K,CP,L>>
   : intrinsic_hash2<mds::api::managed_type_handle_cp<K,CP,L>> {};

 template <bool CP>
 struct hash1<mds::api::record_type_handle_cp<CP>>
   : intrinsic_hash1<mds::api::record_type_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::record_type_handle_cp<CP>>
   : intrinsic_hash2<mds::api::record_type_handle_cp<CP>> {};

 template <bool CP>
 struct hash1<mds::api::array_type_base_handle_cp<CP>>
   : intrinsic_hash1<mds::api::array_type_base_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::array_type_base_handle_cp<CP>>
   : intrinsic_hash2<mds::api::array_type_base_handle_cp<CP>> {};

 template <mds::api::kind K, bool CP>
 struct hash1<mds::api::array_type_handle_cp<K,CP>>
   : intrinsic_hash1<mds::api::array_type_handle_cp<K,CP>> {};
 template <mds::api::kind K, bool CP>
 struct hash2<mds::api::array_type_handle_cp<K,CP>>
   : intrinsic_hash2<mds::api::array_type_handle_cp<K,CP>> {};

 template <bool CP>
 struct hash1<mds::api::namespace_handle_cp<CP>>
   : intrinsic_hash1<mds::api::namespace_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::namespace_handle_cp<CP>>
   : intrinsic_hash2<mds::api::namespace_handle_cp<CP>> {};

}

namespace std {
  template <bool CP>
  struct hash<mds::api::iso_context_handle_cp<CP>> : ruts::delegate_hash<mds::api::iso_context_handle_cp<CP>> {};

  template <bool CP>
  struct hash<mds::api::publication_attempt_handle_cp<CP>> : ruts::delegate_hash<mds::api::publication_attempt_handle_cp<CP>> {};

  template <bool CP>
  struct hash<mds::api::task_handle_cp<CP>> : ruts::delegate_hash<mds::api::task_handle_cp<CP>> {};

  template <bool CP>
  struct hash<mds::api::interned_string_handle_cp<CP>> : ruts::delegate_hash<mds::api::interned_string_handle_cp<CP>> {};

  template <bool CP>
  struct hash<mds::api::managed_record_handle_cp<CP>> : ruts::delegate_hash<mds::api::managed_record_handle_cp<CP>> {};

  template <mds::api::kind K, bool CP>
  struct hash<mds::api::record_field_handle_cp<K,CP>> : ruts::delegate_hash<mds::api::record_field_handle_cp<K,CP>> {};

  template <bool CP>
  struct hash<mds::api::managed_array_base_handle_cp<CP>> : ruts::delegate_hash<mds::api::managed_array_base_handle_cp<CP>> {};

  template <mds::api::kind K, bool CP>
  struct hash<mds::api::managed_array_handle_cp<K,CP>> : ruts::delegate_hash<mds::api::managed_array_handle_cp<K,CP>> {};

  template <mds::api::kind K, bool CP, typename L>
  struct hash<mds::api::managed_type_handle_cp<K,CP,L>> : ruts::delegate_hash<mds::api::managed_type_handle_cp<K,CP,L>> {};

  template <bool CP>
  struct hash<mds::api::record_type_handle_cp<CP>> : ruts::delegate_hash<mds::api::record_type_handle_cp<CP>> {};

  template <bool CP>
  struct hash<mds::api::array_type_base_handle_cp<CP>> : ruts::delegate_hash<mds::api::array_type_base_handle_cp<CP>> {};

  template <mds::api::kind K, bool CP>
  struct hash<mds::api::array_type_handle_cp<K,CP>> : ruts::delegate_hash<mds::api::array_type_handle_cp<K,CP>> {};

  template <bool CP>
  struct hash<mds::api::namespace_handle_cp<CP>> : ruts::delegate_hash<mds::api::namespace_handle_cp<CP>> {};

  template <typename T>
  inline
  void swap(mds::api::view_independent_handle<T> &lhs, mds::api::view_independent_handle<T> &rhs) {
    lhs.swap(rhs);
  }
  template <typename T>
  inline
  void swap(mds::api::view_relative_handle<T> &lhs, mds::api::view_relative_handle<T> &rhs) {
    lhs.swap(rhs);
  }

//  template <typename T, typename E>
//  struct hash<mds::api::view_relative_handle<T,E>> : ruts::delegate_hash<mds::api::view_relative_handle<T,E>> {};

  template <typename C, typename Tr, typename T, typename E>
  basic_ostream<C,Tr> &
  operator <<(basic_ostream<C,Tr> &os, const mds::api::view_independent_handle<T,E> &h) {
    return os << h.pointer();
  }

  template <typename C, typename Tr, typename T, typename E>
  basic_ostream<C,Tr> &
  operator <<(basic_ostream<C,Tr> &os, const mds::api::view_relative_handle<T,E> &h) {
    return os << h.pointer() << "{" << h.view() << "}";
  }

  template <typename C, typename Tr, bool CP>
  basic_ostream<C,Tr> &
  operator <<(basic_ostream<C,Tr> &os, const mds::api::interned_string_handle_cp<CP> &h) {
    return os << h.pointer() ;
  }


}


#endif /* MDS_API_H_ */
