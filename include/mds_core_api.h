/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * mds_core_api.h
 *
 *  Created on: Sep 16, 2014
 *      Author: evank
 */

#ifndef MDS_CORE_API_H_
#define MDS_CORE_API_H_

#include "mds_types.h"
#include "core/mds_core.h"
#include <string>
#include <vector>
#include <unordered_map>
#include <memory>
#include <iterator>
#include <algorithm>
#include <type_traits>
#include <mutex>
#include <locale>
#include <stack>
#include <type_traits>

namespace mds {
 namespace api {
   /*
    * This namespace contains the types and functions that should be used by
    * an implementation of an MDS language API.  It includes the primitive
    * types used by the core (actually part of the mds namespace), the
    * kind enumeration, and "handles" for non-primitive core types.  Given a
    * kind, the API type (primitive or handle) is given as "api_type<K>"
    * and the core type as "core_type<K>".  To get from the api type to the
    * core type, you can use "to_core_val(val)".  (To go the other way, you
    * can just use a constructor.)
    *
    * Handles come in two forms.  branch_independent_handle<T> holds an
    * external_gc_ptr<T> object.  It can be copy/move constructed or constructed
    * from a branch_independent_handle<X>, external_gc_ptr<X>, or gc_ptr<X> for any
    * X for which pointer assignment would work.  It can also be default
    * constructed or constructed from nullptr.  Assignment operators for
    * each of these also exist as well as comparisons for equality and
    * inequality (whenever the corresponding pointers could be compared).
    *
    * branch_relative_handle<T> hold a branch_independent_handle<T>
    * pointing to a core object as well as an external_gc_ptr<branch>.  Its constructor
    * requires both components and it can only be assigned from or compared
    * to another branch_relative_handle<T>.  The object() and branch() methods
    * can be used to obtain the two components.  There is also a constructor
    * that takes a branch_relative_handle and an external_gc_ptr<branch>
    * and returns a handle to the object on the new branch.
    *
    * The actual classes APIs will use are subclasses of these two handle
    * types which expose (as direct methods, not via pointers) core methods,
    * converting API types to handle types as necessary.  These can, similarly,
    * be constructed and assigned from external_gc_ptr and gc_ptr values.  (The
    * inherited comparison operators suffice.)
    *
    * Each API handle class comes in two varieties, depending on whether
    * the handle logically refers to a const or non-const core object.  To
    * implement this, we actually have "foo_handle_cp<bool ConstP>",
    * with "foo_handle" being an alias for "foo_handle_cp<false>"
    * and "const_foo_handle" an alias for "foo_handle_cp<true>".  Methods
    * that apply to const core objects are available either way, and SFINAE
    * is used to omit methods that apply to non-const objects when ConstP is
    * true.  A consequence of this is that if you have a method that takes
    * a foo_handle as a reference argument and uses it in a const way, you
    * should declare the argument as "const foo_handle_cp<C> &".  Saying
    * "const const_foo_handle &" will also work, but it will copy a
    * "foo_handle" into a temporary, which is at least a shared pointer
    * copy.
   */


   /*
    * Returns true if the process had not previously been registered.
    * Parameter currently ignored
    */
   inline bool register_process(bool automatically_unregister = false) {
     return core::register_process();
   }

   /*
    * Returns true if the process had not previously been unregistered.
    */
   inline bool unregister_process() {
     return core::unregister_process();
   }

   inline void ensure_process_registered() {
     core::ensure_process_registered();
   }

   namespace mem_stats {
     inline std::size_t bytes_in_heap() {
       mpgc::initialize();
       return mpgc::control_block().mem_stats.bytes_in_heap();
     }
     inline std::size_t bytes_in_use() {
       mpgc::initialize();
       return mpgc::control_block().mem_stats.bytes_in_use();
     }
     inline std::size_t bytes_free() {
       mpgc::initialize();
       return mpgc::control_block().mem_stats.bytes_free();
     }
     inline std::size_t gc_cycle_number() {
       mpgc::initialize();
       return mpgc::control_block().mem_stats.cycle_number();
     }
     inline std::size_t n_processes() {
       mpgc::initialize();
       return mpgc::control_block().mem_stats.n_processes();
     }
     inline std::size_t n_objects() {
       mpgc::initialize();
       return mpgc::control_block().mem_stats.n_objects();
     }
     
   }

   using core::res_mode;
   constexpr res_mode resolving = res_mode::resolving;
   constexpr res_mode non_resolving = res_mode::non_resolving;

   using core::kind;
   using core::kind_val;
   using core::kind_type;
   using core::kind_field;

   using core::with_uniform_id;
   using core::uniform_key;


   using core::incompatible_superclass_ex;
   using core::incompatible_type_ex;
   using core::unmodifiable_record_type_ex;
   using core::unbound_name_ex;
   using core::read_only_context_ex;
   using core::unmergeable_context_ex;

   using core::view_type;
   using core::mod_type;

   template <kind K> using core_type = core::kind_val<K>;

   template <bool ConstP> class interned_string_handle_cp;
   using interned_string_handle = interned_string_handle_cp<false>;
   using const_interned_string_handle = interned_string_handle_cp<true>;

   template <bool ConstP>
   using managed_string_handle_cp = interned_string_handle_cp<ConstP>;
   using managed_string_handle = managed_string_handle_cp<false>;
   using const_managed_string_handle = const_interned_string_handle;

   template <bool ConstP> class iso_context_handle_cp;
   using iso_context_handle = iso_context_handle_cp<false>;
   using const_iso_context_handle = iso_context_handle_cp<true>;

   template <bool ConstP> class managed_record_handle_cp;
   using managed_record_handle = managed_record_handle_cp<false>;
   using const_managed_record_handle = managed_record_handle_cp<true>;

   template <kind K, bool ConstP> class record_field_handle_cp;
   template <kind K>
   using record_field_handle = record_field_handle_cp<K, false>;
   template <kind K>
   using const_record_field_handle = record_field_handle_cp<K, true>;

   template <bool ConstP> class managed_array_base_handle_cp;
   using managed_array_base_handle = managed_array_base_handle_cp<false>;
   using const_managed_array_base_handle = managed_array_base_handle_cp<true>;

   template <kind K, bool ConstP> class managed_array_handle_cp;
   template <kind K>
   using managed_array_handle = managed_array_handle_cp<K, false>;
   template <kind K>
   using const_managed_array_handle = managed_array_handle_cp<K, true>;
   using array_index_type = mds::core::array_index_type;

   template <kind K, bool ConstP, typename LeafT = core::kind_type<K>,
       typename = std::enable_if_t<std::is_base_of<core::kind_type<K>, LeafT>::value> >
   class managed_type_handle_cp;
   template <kind K> using managed_type_handle = managed_type_handle_cp<K, false>;
   template <kind K> using const_managed_type_handle = managed_type_handle_cp<K, true>;

   template <bool ConstP> class record_type_handle_cp;
   using record_type_handle = record_type_handle_cp<false>;
   using const_record_type_handle = record_type_handle_cp<true>;

   template <bool ConstP> class array_type_base_handle_cp;
   using array_type_base_handle = array_type_base_handle_cp<false>;
   using const_array_type_base_handle = array_type_base_handle_cp<true>;

   template <kind K, bool ConstP> class array_type_handle_cp;
   template <kind K> using array_type_handle = array_type_handle_cp<K, false>;
   template <kind K> using const_array_type_handle = array_type_handle_cp<K, true>;
   template <kind K> using array_size_type = typename mds::core::array_type<K>::size_type;

   template <bool ConstP> class namespace_handle_cp;
   using namespace_handle = namespace_handle_cp<false>;
   using const_namespace_handle = namespace_handle_cp<true>;

   class merge_result;

   /*
    * api_type<T> will either be T or a handle (defined in a specialization)
    */
   template <kind K, typename Enable = void> struct mv_wrapper;
   template <kind K> using api_type = typename mv_wrapper<K>::type;
   template <kind K>
   inline core::kind_mv<K> to_core_val(const api_type<K> &val) {
     return mv_wrapper<K>::to_core_val(val);
   }

   /*
    * Primitive types just pass by value
    */
   template <kind K>
   struct mv_wrapper<K, std::enable_if_t<std::is_arithmetic<core_type<K>>::value>>
   {
     using type = core_type<K>;
     static type to_core_val(const type &val) {
       return val;
     }
   };

   template <kind K, bool ConstP>
   struct type_handle_traits {
     using type = managed_type_handle_cp<K,ConstP>;
   };
   template <bool ConstP>
   struct type_handle_traits<kind::RECORD, ConstP> {
     using type = record_type_handle_cp<ConstP>;
   };

   template <kind K> using type_handle_for = typename type_handle_traits<K,false>::type;
   template <kind K> using const_type_handle_for = typename type_handle_traits<K,true>::type;


   /* Base class to simplify specializations */
   template <typename H>
   struct use_handle {
     using type = H;
     static auto to_core_val(const type &val) {
       return val.to_core_val();
     }
   };

   template <typename T, typename = std::enable_if_t<core::is_exportable<T>::value>
   >
   struct branch_independent_handle {
     using value_type = T;
   private:
     core::external_gc_ptr<T> _ptr;

     template <typename X, typename E> friend class branch_independent_handle;
   protected:
   public:
     auto &pointer() const {
       return _ptr;
     }

     template <typename X> using compatible = std::enable_if_t<std::is_convertible<X*,T*>::value>;

     branch_independent_handle(const branch_independent_handle &) = default;
     template <typename X, typename = compatible<X> >
     branch_independent_handle(const branch_independent_handle<X> &rhs) : _ptr{rhs.pointer()} {}

     branch_independent_handle(branch_independent_handle &&) = default;
     template <typename X, typename = compatible<X> >
     branch_independent_handle(branch_independent_handle<X> &&rhs) : _ptr{std::move(rhs.pointer())} {}

     template <typename X, typename = compatible<X> >
     branch_independent_handle(const core::external_gc_ptr<X> &rhs) : _ptr{rhs} {}

     template <typename X, typename = compatible<X> >
     branch_independent_handle(const core::gc_ptr<X> &rhs) : _ptr{rhs} {}

     constexpr branch_independent_handle() = default;
     constexpr branch_independent_handle(nullptr_t) {}

     branch_independent_handle &operator =(const branch_independent_handle &) = default;
     template <typename X, typename = compatible<X> >
     branch_independent_handle &operator =(const branch_independent_handle<X> &rhs) {
       _ptr = rhs.pointer();
       return *this;
     }

     branch_independent_handle &operator =(branch_independent_handle &&) = default;
     template <typename X, typename = compatible<X> >
     branch_independent_handle &operator =(branch_independent_handle<X> &&rhs) {
       _ptr = std::move(rhs.pointer());
       return this;
     }

     template <typename X, typename = compatible<X> >
     branch_independent_handle &operator =(const core::external_gc_ptr<X> &rhs) {
       _ptr = rhs;
       return this;
     }

     template <typename X, typename = compatible<X> >
     branch_independent_handle &operator =(const core::gc_ptr<X> &rhs) {
       _ptr = rhs;
       return this;
     }

     branch_independent_handle &operator =(nullptr_t) {
       _ptr = nullptr;
       return this;
     }

     template <typename X>
     using if_comparable_t = std::enable_if_t<(
         std::is_base_of<std::decay_t<X>, std::decay_t<T>>::value
         ||
         std::is_base_of<std::decay_t<T>, std::decay_t<X>>::value
         )>;



     template <typename X, typename = if_comparable_t<X> >
     bool operator ==(const branch_independent_handle<X> &rhs) const {
       return _ptr== rhs.pointer();
     }
     template <typename X, typename = if_comparable_t<X> >
     bool operator ==(const core::external_gc_ptr<X> &rhs) const {
       return _ptr == rhs;
     }
     template <typename X, typename = if_comparable_t<X> >
     bool operator ==(const core::gc_ptr<X> &rhs) const {
       return _ptr == rhs;
     }
     bool operator ==(nullptr_t) const {
       return _ptr .is_null();
     }
     template <typename X>
     bool operator !=(X&& rhs) const {
       return !((*this) == std::forward<X>(rhs));
     }
#if 0
     template <typename X, typename = std::enable_if_t<std::is_convertible<T*,X*>::value> >
     operator core::gc_ptr<X> () const {
       return value;
     }
     template <typename X, typename = std::enable_if_t<std::is_convertible<T*,X*>::value> >
     operator core::external_gc_ptr<X> () const {
       return value;
     }
     virtual ~branch_independent_handle() {}
#endif
     bool is_null() const {
       return _ptr.is_null();
     }
     core::gc_ptr<value_type> to_core_val() const {
       return _ptr;
     }
     constexpr std::uint64_t hash1() const {
       return _ptr.hash1();
     }
     constexpr std::uint64_t hash2() const {
       return _ptr.hash2();
     }

     auto ignore_const() const {
       using nc_value_type = std::remove_const_t<value_type>;
       branch_independent_handle<nc_value_type> nct(std::const_pointer_cast<nc_value_type>(_ptr));
       return nct;
     }

     uniform_key uuid() const {
       return pointer()->uuid();
     }

     void swap(branch_independent_handle &other) {
       _ptr.swap(other._ptr);
     }
   };

   template <typename T, typename X, typename = std::common_type_t<X,T> >
   bool operator ==(const core::external_gc_ptr<X> &lhs, const branch_independent_handle<T> &rhs) {
     return rhs == lhs;
   }
   template <typename T, typename X, typename = std::common_type_t<X,T> >
   bool operator !=(const core::external_gc_ptr<X> &lhs, const branch_independent_handle<T> &rhs) {
     return rhs != lhs;
   }
   template <typename T, typename X, typename = std::common_type_t<X,T> >
   bool operator ==(const core::gc_ptr<X> &lhs, const branch_independent_handle<T> &rhs) {
     return rhs == lhs;
   }
   template <typename T, typename X, typename = std::common_type_t<X,T> >
   bool operator !=(const core::gc_ptr<X> &lhs, const branch_independent_handle<T> &rhs) {
     return rhs != lhs;
   }
   template <typename T>
   inline bool operator==(nullptr_t, const branch_independent_handle<T> &rhs) {
     return rhs.is_null();
   }
   template <typename T>
   inline bool operator!=(nullptr_t, const branch_independent_handle<T> &rhs) {
     return !rhs.is_null();
   }


   template <typename T,  typename = std::enable_if_t<
       std::is_base_of<core::managed_composite, T>::value
       > >
   struct branch_relative_handle {
     using value_type = T;
   private:
     template <typename X, typename E> friend class branch_relative_handle;
     using icb = core::external_gc_ptr<core::branch>;
     branch_independent_handle<T> _obj;
     icb _branch;

     icb nullcheck(const icb b) const {
       return _obj == nullptr ? icb{} : b;
     }

     void check_non_null_branch() const {
       assert( (_obj == nullptr) == (_branch==nullptr) );
     }
   public:
     auto &object() const {
       return _obj;
     }

     auto &pointer() const {
       return _obj.pointer();
     }

     auto &branch() const {
       return _branch;
     }

     template <typename X = T, typename = std::enable_if_t<std::is_base_of<X, T>::value>>
     auto to_core_val() const {
       return core::managed_value<X>(pointer(), branch());
     }

     template <typename X> using compatible = std::enable_if_t<std::is_convertible<X*,T*>::value>;

     branch_relative_handle(const branch_relative_handle &) = default;
     template <typename X, typename = compatible<X> >
     branch_relative_handle(const branch_relative_handle<X> &rhs)
     : _obj{rhs._obj}, _branch{rhs._branch}
     {}

     branch_relative_handle(branch_relative_handle &&) = default;
     template <typename X, typename = compatible<X> >
     branch_relative_handle(branch_relative_handle<X> &&rhs)
     : _obj{std::move(rhs._obj)},
       _branch{std::move(rhs._branch)}
     {}

     template <typename X, typename = compatible<X> >
     branch_relative_handle(const core::bd_value<X> &rhs)
     : _obj{rhs.value}, _branch{rhs.on_branch}
     {
       check_non_null_branch();
     }

     template <typename X, typename = compatible<X> >
     branch_relative_handle(const branch_relative_handle &rhs, const icb &b)
     : _obj{rhs._obj}, _branch{nullcheck(b)}
     {
       check_non_null_branch();
     }

     template <typename X, typename = compatible<X> >
     branch_relative_handle(branch_relative_handle &&rhs, const icb &b)
     : _obj{std::move(rhs._obj)}, _branch{nullcheck(b)}
     {
       check_non_null_branch();
     }

     template <typename X, typename = compatible<X> >
     branch_relative_handle(const core::external_gc_ptr<X> &rhs, const icb &b)
     : _obj{rhs}, _branch{nullcheck(b)}
     {
       check_non_null_branch();
     }

     template <typename X, typename = compatible<X> >
     branch_relative_handle(const core::gc_ptr<X> &rhs, const icb &b)
     : _obj{rhs}, _branch{nullcheck(b)}
     {
       check_non_null_branch();
     }

     branch_relative_handle() = default;
     constexpr branch_relative_handle(nullptr_t) {}

     branch_relative_handle &operator =(const branch_relative_handle &) = default;
     template <typename X, typename = compatible<X> >
     branch_relative_handle &operator =(const branch_relative_handle<X> &rhs) {
       _obj= rhs._obj;
       _branch = rhs._branch;
       return *this;
     }

     branch_relative_handle &operator =(branch_relative_handle &&) = default;
     template <typename X, typename = compatible<X> >
     branch_relative_handle &operator =(branch_relative_handle<X> &&rhs) {
       _obj = std::move(rhs._obj);
       _branch = std::move(rhs._branch);
       return this;
     }

     branch_relative_handle &operator =(nullptr_t) {
       _obj = nullptr;
       _branch = nullptr;
       return this;
     }


     template <typename X, typename = std::common_type_t<X,T> >
     bool operator ==(const branch_relative_handle<X> &rhs) const {
       return _obj == rhs._obj && _branch == rhs._branch;
     }
     bool operator ==(nullptr_t) const {
       return _obj.is_null();
     }
     template <typename X>
     bool operator !=(X&& rhs) const {
       return !((*this) == std::forward<X>(rhs));
     }
     bool is_null() const {
       return _obj.is_null();
     }

     template <typename X, bool ConstP, typename = std::common_type_t<X,T> >
     bool same_in(const iso_context_handle_cp<ConstP> &ctxt,
                  const branch_relative_handle<X> &rhs) const
     {
       if (_obj != rhs._obj) {
         return false;
       }
       // If either branch is null, then both objects should be null.
       // (If only one was, we would have failed the prior test.)  So
       // both branches should be null, and we'll succeed here.
       if (_branch == rhs._branch) {
         return true;
       }
       auto cp = ctxt.pointer();
       return cp->shadow(_branch) == cp->shadow(rhs._branch);
     }


     void swap(branch_relative_handle &other) {
       _obj.swap(other._obj);
       _branch.swap(other._branch);
     }

     /*
      * We use opposite hashes and shift just in case we would have a
      * branch_relative_handle<branch> where both referred to the
      * same thing.  Farfetched, but why not be safe?
      */
     constexpr std::uint64_t hash1() const {
       return (_obj.hash1() << 1) ^ _branch.hash2();
     }
     constexpr std::uint64_t hash2() const {
       return (_obj.hash2() << 1) ^ _branch.hash1();
     }
     auto ignore_const() const {
       using nc_value_type = std::remove_const_t<value_type>;
       branch_relative_handle<nc_value_type> nct(std::const_pointer_cast<nc_value_type>(_obj.pointer()), _branch);
       return nct;
     }
#if 0
     template <typename X, typename = std::enable_if_t<std::is_convertible<T*,X*>::value> >
     operator core::gc_ptr<X> () const {
       return value;
     }
     template <typename X, typename = std::enable_if_t<std::is_convertible<T*,X*>::value> >
     operator core::external_gc_ptr<X> () const {
       return value;
     }
     virtual ~branch_independent_handle() {}
     core::gc_ptr<value_type> to_core_val() const {
       return _ptr;
     }
     template <typename X = LeafT, typename = std::enable_if_t<std::is_base_of<X, LeafT>::value>>
     core::managed_value<X> to_core_val() const {
       return core::managed_value<X>(value, on_branch);
     }

#endif
   };

   template <typename T>
   inline bool operator==(nullptr_t, const branch_relative_handle<T> &rhs) {
     return rhs.is_null();
   }
   template <typename T>
   inline bool operator!=(nullptr_t, const branch_relative_handle<T> &rhs) {
     return !rhs.is_null();
   }

   template <bool ConstP, typename T>
   using htarget_ = std::conditional_t<ConstP, const T, T>;

   template <bool ConstP>
   struct constness {
     constexpr static bool less_const(bool cp) {
       return cp <= ConstP;
     }
     template <bool CP>
     using when_less_const = std::enable_if_t<less_const(CP)>;
   };

   const interned_string_handle &empty_string_();

   template <bool ConstP>
   struct interned_string_handle_cp
       : branch_independent_handle<htarget_<ConstP,core::interned_string>>
   {
     using base = branch_independent_handle<htarget_<ConstP,core::interned_string>>;
     using typename base::value_type;
     using non_const_type = interned_string_handle_cp<false>;

     using string_type = value_type;
     using char_type = typename string_type::value_type;
     using const_iterator = typename string_type::const_iterator;
     using const_reverse_iterator = typename string_type::const_reverse_iterator;
     using const_reference = typename string_type::const_reference;
     using const_pointer = typename string_type::const_pointer;
     using size_type = typename string_type::size_type;
     using difference_type = typename string_type::difference_type;

     //     template <bool CP> using when_less_const = typename constness<ConstP>::template when_less_const<CP>;
     template <bool CP>
       using when_less_const = std::enable_if_t<(CP <= ConstP)>;

     using base::base;
     using base::is_null;
     using base::pointer;

     constexpr interned_string_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     interned_string_handle_cp(const interned_string_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     interned_string_handle_cp(interned_string_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     interned_string_handle_cp &
     operator =(const interned_string_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     interned_string_handle_cp &
     operator =(interned_string_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     static interned_string_handle empty_string() {
       return empty_string_();
     }

     std::size_t size() const {
       return is_null() ? 0 : pointer()->size();
     }
     std::size_t length() const {
       return size();
     }

     char_type operator[](std::size_t i) const {
       return (*pointer())[i];
     }

     char_type at(std::size_t i) const {
       return pointer()->at(i);
     }

     const_iterator cbegin() const {
       return is_null() ? const_iterator{} : pointer()->cbegin();
     }
     const_iterator begin() const {
       return cbegin();
     }

     const_iterator cend() const {
       return is_null() ? const_iterator{} : pointer()->cend();
     }
     const_iterator end() const {
       return cend();
     }

     std::string utf8() const {
       if (length() == 0) {
         return std::string{};
       }
       std::size_t size = 0;
       for (char_type c : *this) {
         if ((c & ~0x7F) == 0) {
           size++;
         } else if ((c & ~0x7FF) == 0) {
           size+=2;
         } else if ((c & ~0xFFFF) == 0) {
           size+=3;
         } else if ((c & ~0x1FFFFF) == 0) {
           size+=4;
         } else if ((c & ~0x3FFFFFF) == 0) {
           size+=5;
         } else {
           size += 6;
         }
       }
       std::string utf8;
       utf8.reserve(size);
       for (char_type c : *this) {
         if ((c & ~0x7F) == 0) {
           utf8.push_back(static_cast<char>(c & 0x7F));
         } else if ((c & ~0x7FF) == 0) {
           utf8.push_back(static_cast<char>(0xC0 | ((c >> 6) & 0x1F)));
           utf8.push_back(static_cast<char>(0x80 | (c & 0x3F)));
         } else if ((c & ~0xFFFF) == 0) {
           utf8.push_back(static_cast<char>(0xE0 | ((c >> 12) & 0x0F)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 6) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | (c & 0x3F)));
         } else if ((c & ~0x1FFFFF) == 0) {
           utf8.push_back(static_cast<char>(0xF0 | ((c >> 18) & 0x07)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 12) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 6) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | (c & 0x3F)));
         } else if ((c & ~0x3FFFFFF) == 0) {
           utf8.push_back(static_cast<char>(0xF8 | ((c >> 24) & 0x03)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 18) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 12) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 6) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | (c & 0x3F)));
         } else {
           utf8.push_back(static_cast<char>(0xFC | ((c >> 30) & 0x03)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 24) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 18) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 12) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | ((c >> 6) & 0x3F)));
           utf8.push_back(static_cast<char>(0x80 | (c & 0x3F)));
         }
       }
       return utf8;
     }


   };
   template<>
   struct mv_wrapper<kind::STRING> : public use_handle<managed_string_handle> {};


   template <typename Iter>
   inline interned_string_handle intern(const Iter &from, const Iter &to) {
     ensure_process_registered();
     return interned_string_handle{core::intern(from, to)};
   }

   inline interned_string_handle intern(const char *chars, std::size_t len) {
     ensure_process_registered();
     return interned_string_handle{core::intern(chars, len)};
   }

   // This is assumed to be a literal string (with a null byte at the end)
   template <std::size_t N>
   inline interned_string_handle intern(const char (&chars)[N]) {
     ensure_process_registered();
     return interned_string_handle{core::intern(chars)};
   }

   inline interned_string_handle intern(const char16_t *chars, std::size_t len) {
     ensure_process_registered();
     return interned_string_handle{core::intern(chars, len)};
   }
   // This is assumed to be a literal string (with a null byte at the end)
   template <std::size_t N>
   inline interned_string_handle intern(const char16_t (&chars)[N]) {
     ensure_process_registered();
     return interned_string_handle{core::intern(chars)};
   }

   inline interned_string_handle intern(const wchar_t *chars, std::size_t len) {
     ensure_process_registered();
     return interned_string_handle{core::intern(chars, len)};
   }
   // This is assumed to be a literal string (with a null byte at the end)
   template <std::size_t N>
   inline interned_string_handle intern(const wchar_t (&chars)[N]) {
     ensure_process_registered();
     return interned_string_handle{core::intern(chars)};
   }

   template <typename C, typename T, typename A>
   inline interned_string_handle intern(const std::basic_string<C,T,A> &s) {
     ensure_process_registered();
     return interned_string_handle{core::intern(s.begin(), s.end())};
   }

   inline
   const interned_string_handle &empty_string_() {
     static interned_string_handle s = intern("");
     return s;
   }

   iso_context_handle global_ic__();
   iso_context_handle for_process_ic__();

   template <bool ConstP>
   struct iso_context_handle_cp : branch_independent_handle<htarget_<ConstP,core::iso_context>>
   {
     /*
      * Could put a shadow branch cache here that we pass in to calls to short-circuit
      * the shadow calculation.  It would have to be atomic but would probably be faster
      * than going to NVM.
      */

     using base = branch_independent_handle<htarget_<ConstP,core::iso_context>>;
     using typename base::value_type;
     using non_const_type = iso_context_handle_cp<false>;

     //     template <bool CP> using when_less_const = typename constness<ConstP>::when_less_const;
     template <bool CP>
       using when_less_const = std::enable_if_t<(CP <= ConstP)>;

     using base::base;
     using base::is_null;
     using base::pointer;

     iso_context_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     iso_context_handle_cp(const iso_context_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     iso_context_handle_cp(iso_context_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     iso_context_handle_cp &
     operator =(const iso_context_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     iso_context_handle_cp &
     operator =(iso_context_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }


     bool is_snapshot() const {
       return is_null() ? false : pointer()->is_snapshot();
     }

     bool is_read_only() const {
       return is_null() ? true : pointer()->is_read_only();
     }

     bool is_mergeable() const {
       return is_null() ? false : pointer()->is_mergeable();
     }

     iso_context_handle parent() const {
       return is_null() ? iso_context_handle{} : pointer()->parent();
     }

     iso_context_handle ro_snapshot_at(core::timestamp_t ts) const {
       return is_null()
           ? iso_context_handle{}
       : pointer()->as_of(ts, core::view_type::snapshot, core::mod_type::read_only);
     }

     static iso_context_handle global() {
       return global_ic__();
     }
     static iso_context_handle for_process() {
       return for_process_ic__();
     }

     /*
      * Throws read_only_context_ex if context is read_only and mod type is full.
      */
     iso_context_handle new_child(view_type vt, mod_type mt) const {
       return iso_context_handle{pointer()->new_child(vt, mt)};
     }
     iso_context_handle new_snapshot_child(mod_type mt = mod_type::full) const {
       return new_child(view_type::snapshot, mt);
     }
     iso_context_handle new_nonsnapshot_child(mod_type mt = mod_type::full) const {
       return new_child(view_type::live, mt);
     }
     iso_context_handle new_detached_snapshot_child() const {
       return new_snapshot_child(mod_type::detached);
     }
     iso_context_handle new_detached_nonsnapshot_child() const {
       return new_nonsnapshot_child(mod_type::detached);
     }
     iso_context_handle new_read_only_snapshot_child() const {
       return new_snapshot_child(mod_type::read_only);
     }
     iso_context_handle new_read_only_nonsnapshot_child() const {
       return new_nonsnapshot_child(mod_type::read_only);
     }
     /*
      * Throws unmergeable_context_ex if not mergeable
      */
     void publish(merge_result &cs) const;

     // temporary for conflict resolution:
     void clear_conflicts() {
       pointer()->clear_conflicts();
     }
   };


   inline iso_context_handle global_ic__() {
     ensure_process_registered();
     static iso_context_handle ctxt{core::global_context};
     return ctxt;
   }
   inline iso_context_handle for_process_ic__() {
     static iso_context_handle ctxt{global_ic__().new_child(view_type::live, mod_type::full)};
     return ctxt;
   }

   template <bool ConstP>
   struct managed_record_handle_cp : branch_relative_handle<htarget_<ConstP,core::managed_record>>
   {
     /*
      * Could put a shadow branch cache here that we pass in to calls to short-circuit
      * the shadow calculation.  It would have to be atomic but would probably be faster
      * than going to NVM.
      */

     using base = branch_relative_handle<htarget_<ConstP,core::managed_record>>;
     using typename base::value_type;
     using non_const_type = managed_record_handle_cp<false>;

     //     template <bool CP> using when_less_const = typename constness<ConstP>::when_less_const;
     template <bool CP> using when_less_const = std::enable_if_t<(CP <= ConstP)>;

     using base::base;
     using base::is_null;
     using base::pointer;

     managed_record_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     managed_record_handle_cp(const managed_record_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     managed_record_handle_cp(managed_record_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     managed_record_handle_cp &
     operator =(const managed_record_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     managed_record_handle_cp &
     operator =(managed_record_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     const_record_type_handle type() const;
     uniform_key uuid() const {
       return pointer()->uuid();
     }
   };

   template<>
   struct mv_wrapper<kind::RECORD> : public use_handle<managed_record_handle> {};

   template <kind K, bool ConstP>
   struct record_field_handle_cp
   : public branch_independent_handle<htarget_<ConstP,const kind_field<K>>>
   {
     using base = branch_independent_handle<htarget_<ConstP,const kind_field<K>>>;
     using typename base::value_type;
     using non_const_type = record_field_handle_cp<K, false>;

     //     template <bool CP> using when_less_const = typename constness<ConstP>::when_less_const;
     template <bool CP> using when_less_const = std::enable_if_t<(CP <= ConstP)>;


     using base::base;
     using base::is_null;
     using base::pointer;

     record_field_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     record_field_handle_cp(const record_field_handle_cp<K,CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     record_field_handle_cp(record_field_handle_cp<K,CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     record_field_handle_cp &
     operator =(const record_field_handle_cp<K,CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     record_field_handle_cp &
     operator =(record_field_handle_cp<K,CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     /*
      * NOTE: This doesn't work if we let FT be something abstract like "collection".
      * I'm assuming that it is fully specified, at least down to "record" for any
      * record type.
      */
     api_type<K> read(const iso_context_handle &ctxt,
                      const managed_record_handle &r) const {
//       std::cout << "[reading from " << ctxt.value << "]" << std::endl ;
       return pointer()->read(r.pointer(), r.branch(), ctxt.pointer());
     }
     api_type<K> read_frozen(const iso_context_handle &ctxt,
                             const managed_record_handle &r) const {
       return pointer()->read_frozen(r.pointer(), r.branch(), ctxt.pointer());
     }
     /*
      * Throws read_only_context_ex if context is read only
      */
     api_type<K> write(const iso_context_handle &ctxt,
		       const managed_record_handle &r,
		       const api_type<K> &val,
		       res_mode resolving = non_resolving) const {
       return pointer()->write(r.pointer(), r.branch(), ctxt.pointer(), to_core_val<K>(val), resolving);
     }
     api_type<K> set_to_parent(const iso_context_handle &ctxt,
                        const managed_record_handle &r,
                        res_mode resolving = non_resolving) const {
       return pointer()->set_to_parent(r.pointer(), r.branch(), ctxt.pointer(), resolving);
     }
     api_type<K> resolve_to_parent(const iso_context_handle &ctxt,
                            const managed_record_handle &r) const {
       return set_to_parent(ctxt, r, resolving);
     }
     api_type<K> resolve_to_current(const iso_context_handle &ctxt,
                             const managed_record_handle &r) const {
       return pointer()->resolve_to_current(r.pointer(), r.branch(), ctxt.pointer());
     }
     api_type<K> roll_back(const iso_context_handle &ctxt,
                    const managed_record_handle &r,
                    res_mode resolving = non_resolving) const {
       return pointer()->roll_back(r.pointer(), r.branch(), ctxt.pointer(), resolving);
     }
     api_type<K> resolve_by_rollback(const iso_context_handle &ctxt,
                              const managed_record_handle &r) const {
       return roll_back(ctxt, r, resolving);
     }
     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> add(const iso_context_handle &ctxt,
		       const managed_record_handle &r,
		       const api_type<K> &val,
		       res_mode resolving = non_resolving) const {
       return pointer()->add(r.pointer(), r.branch(), ctxt.pointer(), val, resolving);
     }
     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> sub(const iso_context_handle &ctxt,
		       const managed_record_handle &r,
		       const api_type<K> &val,
		       res_mode resolving = non_resolving) const {
       return pointer()->sub(r.pointer(), r.branch(), ctxt.pointer(), val, resolving);
     }
     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> mul(const iso_context_handle &ctxt,
		       const managed_record_handle &r,
		       const api_type<K> &val,
		       res_mode resolving = non_resolving) const {
       return pointer()->mul(r.pointer(), r.branch(), ctxt.pointer(), val, resolving);
     }
     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> div(const iso_context_handle &ctxt,
		       const managed_record_handle &r,
		       const api_type<K> &val,
		       res_mode resolving = non_resolving) const {
       return pointer()->div(r.pointer(), r.branch(), ctxt.pointer(), val, resolving);
     }

     bool has_value(const iso_context_handle &ctxt,
                    const managed_record_handle &r) const {
       return is_null() ? false : pointer()->has_value(r.pointer(), r.branch(), ctxt.pointer());
     }
     interned_string_handle name() const {
       return pointer()->name;
     }

     const_record_type_handle rec_type() const;
     const_type_handle_for<K> field_type() const;
   };

   template <bool ConstP>
   struct managed_array_base_handle_cp
   : public branch_relative_handle<htarget_<ConstP,core::managed_array_base>>
   {
     using base = branch_relative_handle<htarget_<ConstP,core::managed_array_base>>;
     using typename base::value_type;
     using non_const_type = managed_array_base_handle_cp<false>;

     template <bool CP> using when_less_const = typename constness<CP>::when_less_const;

     using base::base;
     using base::is_null;
     using base::pointer;

     managed_array_base_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     managed_array_base_handle_cp(const managed_array_base_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     managed_array_base_handle_cp(managed_array_base_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     managed_array_base_handle_cp &
     operator =(const managed_array_base_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     managed_array_base_handle_cp &
     operator =(managed_array_base_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     const_array_type_base_handle type() const;
     uniform_key uuid() const {
       return pointer()->uuid();
     }
   };

   template <kind K, bool ConstP>
   struct managed_array_handle_cp
   : public branch_relative_handle<htarget_<ConstP,core::managed_array<K>>>
   {
     using base = branch_relative_handle<htarget_<ConstP,core::managed_array<K>>>;
     using typename base::value_type;
     using non_const_type = managed_array_handle_cp<K, false>;

     template <bool CP> using when_less_const = typename constness<CP>::when_less_const;

     using base::base;
     using base::is_null;
     using base::pointer;
     using base::branch;

     managed_array_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     managed_array_handle_cp(const managed_array_handle_cp<K,CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     managed_array_handle_cp(managed_array_handle_cp<K,CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     managed_array_handle_cp &
     operator =(const managed_array_handle_cp<K,CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     managed_array_handle_cp &
     operator =(managed_array_handle_cp<K,CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     const_array_type_handle<K> type() const;
     uniform_key uuid() const {
       return pointer()->uuid();
     }

     api_type<K> read(const iso_context_handle &ctxt,
                      const array_index_type i) const {
       return pointer()->read(i, branch(), ctxt.pointer());
     }
     api_type<K> read_frozen(const iso_context_handle &ctxt,
                             const array_index_type i) const {
       return pointer()->read_frozen(i, branch(), ctxt.pointer());
     }

     api_type<K> write(const iso_context_handle &ctxt,
		       const array_index_type i,
		       const api_type<K> &val,
		       res_mode resolving = non_resolving) const {
       return pointer()->write(i, branch(), ctxt.pointer(), to_core_val<K>(val), resolving);
     }
     api_type<K> set_to_parent(const iso_context_handle &ctxt,
			      const array_index_type i,
			      res_mode resolving = non_resolving) const {
       return pointer()->set_to_parent(i, branch(), ctxt.pointer(), resolving);
     }
     api_type<K> resolve_to_parent(const iso_context_handle &ctxt,
				   const array_index_type i) const {
       return set_to_parent(ctxt, i, resolving);
     }
     api_type<K> resolve_to_current(const iso_context_handle &ctxt,
				    const array_index_type i) const {
       return pointer()->resolve_to_current(i, branch(), ctxt.pointer());
     }
     api_type<K> roll_back(const iso_context_handle &ctxt,
			   const array_index_type i,
			   res_mode resolving = non_resolving) const {
       return pointer()->roll_back(i, branch(), ctxt.pointer(), resolving);
     }
     api_type<K> resolve_by_rollback(const iso_context_handle &ctxt,
				     const array_index_type i) const {
       return roll_back(ctxt, i, branch(), resolving);
     }
     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> add(const iso_context_handle &ctxt,
		       const array_index_type i,
		       const api_type<K> &val,
		       res_mode resolving = non_resolving) const {
       return pointer()->add(i, branch(), ctxt.pointer(), val, resolving);
     }
     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> sub(const iso_context_handle &ctxt,
		       const array_index_type i,
		       const api_type<K> &val,
		       res_mode resolving = non_resolving) const {
       return pointer()->sub(i, branch(), ctxt.pointer(), val, resolving);
     }
     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> mul(const iso_context_handle &ctxt,
		       const array_index_type i,
		       const api_type<K> &val,
		       res_mode resolving = non_resolving) const {
       return pointer()->mul(i, branch(), ctxt.pointer(), val, resolving);
     }
     template <typename T = api_type<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value> >
       api_type<K> div(const iso_context_handle &ctxt,
		       const array_index_type i,
		       const api_type<K> &val,
		       res_mode resolving = non_resolving) const {
       return pointer()->div(i, branch(), ctxt.pointer(), val, resolving);
     }

     bool has_value(const iso_context_handle &ctxt,
                    const array_index_type i) const {
       return is_null() ? false : pointer()->has_value(i, branch(), ctxt.pointer());
     }

     array_size_type<K> size() {
       return pointer()->size;
     }

     managed_array_base_handle_cp<ConstP> as_base() {
       return managed_array_base_handle_cp<ConstP>(pointer(), branch());
     }
   };

   // su - TODO - this needs work
   template <>
   struct mv_wrapper<kind::ARRAY> : public use_handle<managed_array_base_handle> {};

   template <kind K, bool ConstP, typename LeafT, typename Enable>
   struct managed_type_handle_cp: public branch_independent_handle<htarget_<ConstP, LeafT>>
   {
     using base = branch_independent_handle<htarget_<ConstP, LeafT>>;
     using typename base::value_type;
     using non_const_type = managed_type_handle_cp<K, false, LeafT, Enable>;

     //     template <bool CP> using when_less_const = typename constness<ConstP>::when_less_const;
     template <bool CP> using when_less_const = std::enable_if_t<(CP <= ConstP)>;

     using base::base;
     using base::is_null;
     using base::pointer;

     managed_type_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     managed_type_handle_cp(const managed_type_handle_cp<K,CP,LeafT,Enable> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     managed_type_handle_cp(managed_type_handle_cp<K,CP,LeafT,Enable> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     managed_type_handle_cp &
     operator =(const managed_type_handle_cp<K,CP,LeafT,Enable> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     managed_type_handle_cp &
     operator =(managed_type_handle_cp<K,CP,LeafT,Enable> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

#if 0
     std::remove_const_t<value_type> *nc_value() const {
       value_type *cval = value;
       return const_cast<std::remove_const_t<value_type> *>(cval);
     }
#endif
     /*
      * Throws incompatible_type_ex if the field exists but is of the wrong type
      *
      * Throws unmodifiable_record_type_ex if the field doesn't exist, create_if_absent
      * is true, and the record type is fully created.
      */
     // TODO: Add const_record_type_handle variant
     record_field_handle<K> field_in(const record_type_handle &rtype,
                                     const interned_string_handle &name,
                                     bool create_if_absent = true) const;
   };


   template <bool ConstP>
   struct array_type_base_handle_cp : managed_type_handle_cp<kind::ARRAY, ConstP, core::array_type_base>
   {
     using base = managed_type_handle_cp<kind::ARRAY, ConstP, core::array_type_base>;
     using typename base::value_type;
     using non_const_type = array_type_base_handle_cp<false>;

     template <bool CP> using when_less_const = typename constness<CP>::when_less_const;

     using base::base;
     using base::is_null;
     using base::pointer;

     array_type_base_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     array_type_base_handle_cp(const array_type_base_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     array_type_base_handle_cp(array_type_base_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     array_type_base_handle_cp &
     operator =(const array_type_base_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     array_type_base_handle_cp &
     operator =(array_type_base_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     template <bool CP>
     bool is_same_as(const array_type_base_handle_cp<CP> &rhs) const {
       if (pointer() == rhs.pointer()) {
         return true;
       } else if (!is_null()) {
         return pointer()->compare_types(rhs.pointer());
       } else {
         return false;
       }
     }
     template <bool CP>
     bool operator !=(const array_type_base_handle_cp<CP> &rhs) const {
       return !operator==(rhs);
     }
   };


   template <kind K, bool ConstP>
   struct array_type_handle_cp : managed_type_handle_cp<kind::ARRAY, ConstP, core::array_type<K>>
   {
     // su - TODO
     //   1. Add type logic
     //       managed_type<K> element_type()
     using base = managed_type_handle_cp<kind::ARRAY, ConstP, core::array_type<K>>;
     using typename base::value_type;
     using non_const_type = array_type_handle_cp<K, false>;

     template <bool CP> using when_less_const = typename constness<CP>::when_less_const;

     using base::base;
     using base::is_null;
     using base::pointer;

     array_type_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     array_type_handle_cp(const array_type_handle_cp<K,CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     array_type_handle_cp(array_type_handle_cp<K,CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     array_type_handle_cp &
     operator =(const array_type_handle_cp<K,CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     array_type_handle_cp &
     operator =(array_type_handle_cp<K,CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     const_managed_type_handle<K> element_type() const {
       return pointer()->element_type();
     }

     managed_array_handle<K>
     create_array(array_size_type<K> s,
                  iso_context_handle ctxt) const {
       return pointer()->create_array(s, ctxt.pointer());
     }

     template <bool CP>
     bool is_same_as(const array_type_handle_cp<K, CP> &rhs) const {
       if (pointer() == rhs.pointer()) {
         return true;
       } else if (!is_null()) {
         return pointer()->compare_types(rhs.pointer());
       } else {
         return false;
       }
     }
     
     template <bool CP>
     bool operator !=(const array_type_handle_cp<K, CP> &rhs) const {
       return !operator==(rhs);
     }

   };



//   template <typename FT> struct mv_wrapper<core::managed_type<FT>> : public use_handle<managed_type_handle<FT>> {};

#define _PRIM_TYPE_(K,name) \
  inline const_managed_type_handle<K> managed_##name##_type_handle() { \
   static const_managed_type_handle<K> \
   type((ensure_process_registered(), core::managed_##name##_type)); \
   return type; \
  } \
   \
  inline const_array_type_handle<K> managed_##name##_array_type_handle() { \
   static const_array_type_handle<K> \
     type((ensure_process_registered(), core::managed_##name##_type->in_array())); \
   return type; \
  }

   _PRIM_TYPE_(kind::BOOL,bool)
   _PRIM_TYPE_(kind::BYTE,byte)
   _PRIM_TYPE_(kind::UBYTE,ubyte)
   _PRIM_TYPE_(kind::SHORT,short)
   _PRIM_TYPE_(kind::USHORT,ushort)
   _PRIM_TYPE_(kind::INT,int)
   _PRIM_TYPE_(kind::UINT,uint)
   _PRIM_TYPE_(kind::LONG,long)
   _PRIM_TYPE_(kind::ULONG,ulong)
   _PRIM_TYPE_(kind::FLOAT,float)
   _PRIM_TYPE_(kind::DOUBLE,double)
   _PRIM_TYPE_(kind::STRING,string)

   template<kind KIND>
     inline const_managed_type_handle<KIND>
     managed_handle_by_kind ()
     {
	static const_managed_type_handle<KIND> type (
	    (ensure_process_registered (), core::global_managed_type<KIND>()));
	return type;
     }

   template<kind KIND>
     inline const_array_type_handle<KIND>
     managed_array_handle_by_kind ()
     {
       static const_array_type_handle<KIND> type (
            (ensure_process_registered (), core::global_managed_type<KIND>()->in_array ()));
   	return type;
     }

   template <bool ConstP>
   struct record_type_handle_cp : managed_type_handle_cp<kind::RECORD, ConstP, core::record_type>
   {
     using base = managed_type_handle_cp<kind::RECORD, ConstP, core::record_type>;
     using typename base::value_type;
     using non_const_type = record_type_handle_cp<false>;

     //     template <bool CP> using when_less_const = typename constness<ConstP>::when_less_const;
     template <bool CP> using when_less_const = std::enable_if_t<(CP <= ConstP)>;

     using base::base;
     using base::is_null;
     using base::pointer;

     record_type_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     record_type_handle_cp(const record_type_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     record_type_handle_cp(record_type_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     record_type_handle_cp &
     operator =(const record_type_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     record_type_handle_cp &
     operator =(record_type_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     managed_record_handle create_record(iso_context_handle ctxt) const {
       return pointer()->create_record(ctxt.pointer());
     }
     bool is_created() const {
       return is_null() ? false : pointer()->is_created();
     }

     interned_string_handle name() const {
       return is_null() ? interned_string_handle{} : pointer()->name();
     }

     const_record_type_handle super_type() const {
       return is_null() ? const_record_type_handle{} : pointer()->super_type();
     }

     /*
      * Returns a handle to the core object that represents this type.  It may be this handle or
      * a handle to another one that was created while we were making this one.  The old handle
      * will continue to work, but it may be more efficient to replace references with this one.
      * Similarly, we may want to ask again about fields and replace references.
      */
     const_record_type_handle ensure_created() const {
       // This is null if this is the correct one or a pointer to the one that was created between
       // the time we created ours and this call.  The caller may want to update references.
       core::gc_ptr<const core::record_type> r = pointer()->ensure_created();
       return r == nullptr ? *this : const_record_type_handle{r};
     }
     static const_record_type_handle find(const interned_string_handle &name) {
       ensure_process_registered();
       return core::record_type::find(name.pointer());
     }

     template <bool CP>
     bool is_same_as(const record_type_handle_cp<CP> &rhs) const {
       if (pointer() == rhs.pointer()) {
         return true;
       } else if (!is_null()) {
         return pointer()->compare_types(rhs.pointer());
       } else {
         return false;
       }
     }
     template <bool CP>
     bool operator !=(const record_type_handle_cp<CP> &rhs) const {
       return !operator==(rhs);
     }
     template <bool CP>
     bool is_super_of(const record_type_handle_cp<CP> &other) const {
       return is_null() ? false : pointer()->is_super_of(other.pointer());
     }

     /*
      * I'm going to punt on multiple inheritence for a while.  It's not needed for the initial
      * demo, and I can't figure out an efficient layout for doing the dispatch.
      */

     static record_type_handle declare(const interned_string_handle &name,
                                       const const_record_type_handle &super = const_record_type_handle{}) {
       ensure_process_registered();
       core::gc_ptr<core::record_type> rt = core::record_type::declare(name.pointer(), super.pointer());
       return rt;
     }

   };

   template <bool ConstP>
   inline
   const_record_type_handle
   managed_record_handle_cp<ConstP>::type() const {
     if (is_null()) {
       return nullptr;
     }
     return pointer()->r_type;
   }


   template <kind K, bool ConstP>
   inline
   const_record_type_handle
   record_field_handle_cp<K,ConstP>::rec_type() const {
     return pointer()->r_type;
   }

   template <kind K, bool ConstP>
   inline
   const_type_handle_for<K>
   record_field_handle_cp<K,ConstP>::field_type() const {
     return pointer()->f_type;
   }

   //   template <> struct mv_wrapper<core::record_type> : public use_handle<record_type_handle> {};
   //
   template <bool ConstP>
   struct namespace_handle_cp : public branch_independent_handle<htarget_<ConstP,core::name_space>> {
     using base = branch_independent_handle<htarget_<ConstP,core::name_space>>;
     using typename base::value_type;
     using non_const_type = namespace_handle_cp<false>;

     //     template <bool CP> using when_less_const = typename constness<ConstP>::when_less_const;
     template <bool CP> using when_less_const = std::enable_if_t<(CP <= ConstP)>;

     using base::base;
     using base::is_null;
     using base::pointer;

     namespace_handle_cp() = default;

     template <bool CP, typename = when_less_const<CP> >
     namespace_handle_cp(const namespace_handle_cp<CP> &rhs)
     : base{rhs}
     {}

     template <bool CP, typename = when_less_const<CP> >
     namespace_handle_cp(namespace_handle_cp<CP> &&rhs)
     : base{std::move(rhs)}
     {}

     template <bool CP, typename = when_less_const<CP> >
     namespace_handle_cp &
     operator =(const namespace_handle_cp<CP> &rhs) {
       base::operator =(rhs);
       return *this;
     }

     template <bool CP, typename = when_less_const<CP> >
     namespace_handle_cp &
     operator =(namespace_handle_cp<CP> &&rhs) {
       base::operator =(std::move(rhs));
       return *this;
     }

     template <bool C1, bool C2>
     namespace_handle child_namespace(const iso_context_handle_cp<C1> &ctxt,
                                      const interned_string_handle_cp<C2> &name, bool create_if_missing)
     {
       return namespace_handle{pointer()->child_namespace(name.pointer(), ctxt.pointer(), create_if_missing)};
     }
     /*
      * Throws unbound_name_ex if the name is unbound.
      * Throws incompatible_type_ex if the name is bound but not to something that can be considered to be of this
      * type (e.g., the same type or a record type of a subclass of this type).
      */
     template <kind K, bool C1, bool C2>
     api_type<K> _lookup(const iso_context_handle_cp<C1> &ctxt,
                         const interned_string_handle_cp<C2> &name) const {
       return pointer()->template read<K>(name.pointer(), ctxt.pointer());
     }
     template <kind K, typename LeafT, bool C1, bool C2, bool C3>
     api_type<K> lookup(const iso_context_handle_cp<C1> &ctxt,
                        const interned_string_handle_cp<C2> &name,
                        const managed_type_handle_cp<K,C3,LeafT> &type) const {
       return _lookup<K>(ctxt, name);
     }
     template <bool C1, bool C2, bool C3>
     managed_record_handle lookup(const iso_context_handle_cp<C1> &ctxt,
                                  const interned_string_handle_cp<C2> &name,
                                  const record_type_handle_cp<C3> &rt) const {
       managed_record_handle mrh = _lookup<kind::RECORD>(ctxt, name);
       /*
        * If we get here, it's bound to a record, but it might not be something
        * of the kind we expect.
        */
       const_record_type_handle old_rt = mrh.type();
       if (!rt.is_super_of(old_rt)) {
         throw incompatible_type_ex{};
       }
       return mrh;
     }

     // su - TODO error handling
     template <kind K, bool C1, bool C2, bool C3>
     managed_array_handle<K> lookup(const iso_context_handle_cp<C1> &ctxt,
                                    const interned_string_handle_cp<C2> &name,
                                    const array_type_handle_cp<K,C3> &at) const {
       managed_array_base_handle mabh = _lookup<kind::ARRAY>(ctxt, name);
       managed_array_handle<K>   mah  = 
         managed_array_handle<K>(
           mabh.pointer()->template downcast<K>(),
           mabh.branch()
           );

       return mah;
     }

     /*
      * Replaces binding of "name" with "val".
      * Returns false if name bound to namespace and replace_namespace is false, true otherwise.
      */
     template <kind K, bool C1, bool C2>
     bool bind(const iso_context_handle_cp<C1> &ctxt,
               const interned_string_handle_cp<C2> &name,
               const api_type<K> &val,
               res_mode resolving = non_resolving,
               bool replace_namespace = false) const {
       return pointer()->bind<K>(name.pointer(), api::to_core_val<K>(val), ctxt.pointer(), resolving, replace_namespace);
     }
     /*
      * Binds "name" to "val", but only if there is no prior binding.  Returns whether it bound
      */
     template <kind K, bool C1, bool C2>
     bool bind_new(const iso_context_handle_cp<C1> &ctxt,
                   const interned_string_handle_cp<C2> &name,
                   const api_type<K> &val) const {
       throw core::unimplemented{};
     }
     /*
      * Binds "name" to "val", but only if there was a prior binding.  Returns whether it bound
      */
     template <kind K, bool C1, bool C2>
     bool replace_binding(const iso_context_handle_cp<C1> &ctxt,
                          const interned_string_handle_cp<C2> &name,
                          const api_type<K> &val) const {
       throw core::unimplemented{};
     }
     /*
      * Binds "name" to "val", but only if it was bound to "expected".  Returns whether it bound
      */
     template <kind K, kind K2, bool C1, bool C2>
     bool replace_binding(const iso_context_handle_cp<C1> &ctxt,
                          const interned_string_handle_cp<C2> &name,
                          const api_type<K> &val,
                          const api_type<K2> &expected) const {
       throw core::unimplemented{};
     }

     template <bool C1, bool C2>
     bool is_bound(const iso_context_handle_cp<C1> &ctxt,
                   const interned_string_handle_cp<C2> &name) const {
       return pointer()->is_bound(name.pointer(), ctxt.pointer());
     }
     template <kind K, bool C1, bool C2>
     bool is_bound_to(const iso_context_handle_cp<C1> &ctxt,
                      const interned_string_handle_cp<C2> &name,
                      const api_type<K> &expected) const {
       throw core::unimplemented{};
     }

     template <bool C1, bool C2>
     bool unbind(const iso_context_handle_cp<C1> &ctxt,
                 const interned_string_handle_cp<C2> &name) const {
       throw core::unimplemented{};
     }
     template <kind K, bool C1, bool C2>
     bool unbind_from(const iso_context_handle_cp<C1> &ctxt,
                      const interned_string_handle_cp<C2> &name,
                      const api_type<K> &expected) const {
       throw core::unimplemented{};
     }

     struct illegal_path_ex {
       std::vector<interned_string_handle> valid_prefix;
       interned_string_handle not_namespace;
       template <typename Iter>
       illegal_path_ex(const Iter &start, const Iter &end, const interned_string_handle &name)
       : valid_prefix(start, end), not_namespace{name}
       {}
     };

     static namespace_handle global() {
       return namespace_handle{core::global_namespace};
     }
     /*
      * Throws illegal_path_ex if one of the segments on the path is not a namespace.
      * If one of the segments is unbound, returns a null namespace_handle.
      */
     template <typename Iter, bool C1>
     static namespace_handle
     from_existing_path(const iso_context_handle_cp<C1> &ctxt, const Iter &path_start, const Iter &path_end) {
       return _path(ctxt.pointer(), path_start, path_end, false);
     }

     /*
      * Throws illegal_path_ex if one of the segments on the path is not a namespace.
      * If a suffix is unbound, creates namespaces.
      */
     template <typename Iter, bool C1>
     static namespace_handle
     from_path(const iso_context_handle_cp<C1> &ctxt, const Iter &path_start, const Iter &path_end) {
       return _path(ctxt.pointer(), path_start, path_end, true);
     }

   private:
     template <typename Iter, bool C1>
     static namespace_handle _path(const iso_context_handle_cp<C1> &ctxt, const Iter &path_start, const Iter &path_end, bool create_namespaces) {
       core::gc_ptr<core::name_space> d = core::global_namespace;
       for (Iter p = path_start; d != nullptr && p != path_end; p++) {
         interned_string_handle name = *p;
         try {
           d = d->child_namespace(name, ctxt, create_namespaces);
         } catch (incompatible_type_ex &) {
           /*
            * We found something that wasn't a namespace.
            */
           throw illegal_path_ex{path_start, p, name};
         }
       }
       return namespace_handle{d};
     }


   };

   struct merge_result: public core::conflict_sink {
   private:
     iso_context_handle _source_context;
     core::timestamp_t _merge_time;
     bool _merge_succeeded;
     mutable iso_context_handle _target_context;
     mutable iso_context_handle _last_common_snapshot;
     mutable iso_context_handle _source_at_merge;
     mutable iso_context_handle _target_at_merge;
     template <bool ConstP> friend void iso_context_handle_cp<ConstP>::publish(merge_result &cs) const;
//     friend void iso_context_handle::publish(merge_result &) const;

     /*
      * Returns false if there were conflicts in the parameter, but all
      * were resolved before they could be added here, so the publish should
      * be resolved.
      */
     bool inject(const core::merge_result &mr) {
       // std::cerr << "Injecting context : " << mr.merging_context << std::endl;
       _source_context = iso_context_handle{mr.merging_context};
       // std::cerr << "Injected context : " << &_source_context << std::endl;
       _merge_time = mr.merge_timestamp;
       _merge_succeeded = mr.conflicts == nullptr;
       if (_merge_succeeded) {
//         std::cerr << "Merge succeeded" << std::endl;
         merge_succeeded();
         return true;
       }
//       std::cerr << "Merge failed " << std::endl;
//       std::cerr << "merge_result inject conflicts" << std::endl;
       bool saw_conflict = false;
       if (mr.conflicts != nullptr) {
         mr.conflicts->for_each([&](const core::gc_ptr<core::conflict> &c){
           if (!c->is_resolved()) {
             if (!saw_conflict) {
               saw_conflict = true;
               merge_failed();
             }
             // reasserting original implementation: 
             // - dropping "new" call to add_conflict to add at core level
             // - re-establishing orig call to conflict to add_to merge_result
             //   resulting in addition of conflict to java-level PubResult
             // add_conflict(c);
             c->add_to(*this);
           }
         });
       }
       if (!saw_conflict) {
         return false;
       }
       merge_conflicts_complete();
       return true;
     }
     static managed_record_handle at(const core::gc_ptr<core::managed_record> &r,
                                     const core::gc_ptr<core::branch> &b) {
       return core::kind_mv<kind::RECORD>{r,b};
     }

     template <kind K>
     void add_field_conflict(const core::gc_ptr<core::managed_record> &r,
                             const core::gc_ptr<core::branch> &b,
                             const core::gc_ptr<const core::record_field<K>> &f) {
        // ss: reasserting original implementation: 
        // either this code is called by merge_result add_conflict specialisations
        // or it is never called because it is overridden by pr_merge_result
        // add_conflict specialisations instead
        // adding print statements to both to see where the code goes...
       //        std::cout << "merge_result::add_field_conflict: invoked!" << std::endl;
        managed_record_handle rh = at(r,b);
        record_field_handle<K> fh{f};
        add_conflict(rh, fh);

        // std::cout << "merge_result::add_field_conflict: no longer implemented" << std::endl;

        // // ss: rather than generating record/field handles at this point, 
        // // create a list of core::conflict objects using existing code
        // // but only ever pass a confict_handle thro the API. 
        // // and only ever expose record/field via their handles 
        // // at the point they are accessed thro the API.
        // // 
        // // managed_record_handle rh = at(r,b);
        // // record_field_handle<K> fh{f};
        // // add_conflict(rh, fh);
        // // 
        // // have to create a new conflict at this level
        // // to avoid modifying the existing linked list of conflicts from below
        // // - adding this conflict to mds::api::merge_result::conflicts

        // std::cout << "merge_result::add_field_conflict: on b " << b << " r: " << r << " f: " << f << std::endl;
        // conflict *conflict = new typename field_conflict<K>::data_type{b,r,f};
        // _conflicts = conflict->prepend_to(_conflicts);
     }


     // ss: reasserting original implementation: 
     // these calls to add_conflict are invoked for each conflict type
     // from core_conflict call to sink.add_conflict

     void add_conflict(const core::gc_ptr<core::managed_record> &r,
                       const core::gc_ptr<core::branch> &b,
                       const core::gc_ptr<const core::record_field<kind::BOOL>> &f) override {
       //       std::cout << "merge_result::add_conflict record_field BOOL: invoked!" << std::endl;
       add_field_conflict(r, b, f);
     }
     void add_conflict(const core::gc_ptr<core::managed_record> &r,
                       const core::gc_ptr<core::branch> &b,
                       const core::gc_ptr<const core::record_field<kind::BYTE>> &f) override {
       add_field_conflict(r, b, f);
     }
     void add_conflict(const core::gc_ptr<core::managed_record> &r,
                       const core::gc_ptr<core::branch> &b,
                       const core::gc_ptr<const core::record_field<kind::UBYTE>> &f) override {
       add_field_conflict(r, b, f);
     }
     void add_conflict(const core::gc_ptr<core::managed_record> &r,
                       const core::gc_ptr<core::branch> &b,
                       const core::gc_ptr<const core::record_field<kind::SHORT>> &f) override {
       add_field_conflict(r, b, f);
     }
     void add_conflict(const core::gc_ptr<core::managed_record> &r,
                       const core::gc_ptr<core::branch> &b,
                       const core::gc_ptr<const core::record_field<kind::USHORT>> &f) override {
       add_field_conflict(r, b, f);
     }
     void add_conflict(const core::gc_ptr<core::managed_record> &r,
                       const core::gc_ptr<core::branch> &b,
                       const core::gc_ptr<const core::record_field<kind::INT>> &f) override {
       //       std::cout << "merge_result::add_conflict record_field INT: invoked!" << std::endl;
       add_field_conflict(r, b, f);
     }
     void add_conflict(const core::gc_ptr<core::managed_record> &r,
                       const core::gc_ptr<core::branch> &b,
                       const core::gc_ptr<const core::record_field<kind::UINT>> &f) override {
       add_field_conflict(r, b, f);
     }
     void add_conflict(const core::gc_ptr<core::managed_record> &r,
                       const core::gc_ptr<core::branch> &b,
                       const core::gc_ptr<const core::record_field<kind::LONG>> &f) override {
       add_field_conflict(r, b, f);
     }
     void add_conflict(const core::gc_ptr<core::managed_record> &r,
                       const core::gc_ptr<core::branch> &b,
                       const core::gc_ptr<const core::record_field<kind::ULONG>> &f) override {
       add_field_conflict(r, b, f);
     }
     void add_conflict(const core::gc_ptr<core::managed_record> &r,
                       const core::gc_ptr<core::branch> &b,
                       const core::gc_ptr<const core::record_field<kind::FLOAT>> &f) override {
       add_field_conflict(r, b, f);
     }
     void add_conflict(const core::gc_ptr<core::managed_record> &r,
                       const core::gc_ptr<core::branch> &b,
                       const core::gc_ptr<const core::record_field<kind::DOUBLE>> &f) override {
       add_field_conflict(r, b, f);
     }
     void add_conflict(const core::gc_ptr<core::managed_record> &r,
                       const core::gc_ptr<core::branch> &b,
                       const core::gc_ptr<const core::record_field<kind::STRING>> &f) override {
       //       std::cout << "merge_result::add_conflict record_field STRING: invoked!" << std::endl;
       add_field_conflict(r, b, f);
     }
     void add_conflict(const core::gc_ptr<core::managed_record> &r,
                       const core::gc_ptr<core::branch> &b,
                       const core::gc_ptr<const core::record_field<kind::RECORD>> &f) override {
       add_field_conflict(r, b, f);
     }
     void add_conflict(const core::gc_ptr<core::managed_record> &r,
                       const core::gc_ptr<core::branch> &b,
                       const core::gc_ptr<const core::record_field<kind::ARRAY>> &f) override {
       add_field_conflict(r, b, f);
     }
     void add_conflict(const core::gc_ptr<core::name_space> &ns,
                       const core::gc_ptr<core::interned_string> &name) override {
       // std::cout << "merge_result::add_conflict(namespace,name): no longer implemented" << std::endl;
       // see add_conflict(conflict) above instead - ss

       // // commenting out this implementation until namespace branch issue sorted
       // // 
       // // ss: as for field_conflict above, 
       // // rather than generating namespace/name handles at this point, 
       // // create a list of core::conflict objects using existing code
       // // but only ever pass a confict_handle thro the API. 
       // // and only ever expose namespace/name via their handles 
       // // at the point they are accessed thro the API.
       // // 
       // // add_conflict(namespace_handle{ns}, interned_string_handle{name});
       // // have to create a new conflict at this level
       // // to avoid modifying the existing linked list of conflicts from below
       // // - adding this conflict to mds::api::merge_result::conflicts
       // // new code: 
       // // conflict *conflict = new bound_name_conflict::data_type{b,ns,name};
       // // _conflicts = conflict->prepend_to(_conflicts);

       // ss: re-establishing orig impl:
       add_conflict(namespace_handle{ns}, interned_string_handle{name});
     }

     template <kind K>
     void add_array_elmt_conflict(const core::gc_ptr<core::managed_array<K>> &a,
                                  const core::gc_ptr<core::branch> &b,
                                  const array_index_type i) {
       managed_array_handle<K> ah{a,b};
       add_conflict(ah, i);
     }
     void add_conflict(const core::gc_ptr<core::managed_array<kind::BOOL>> &a,
                       const core::gc_ptr<core::branch> &b,
                       const array_index_type i) override {
       add_array_elmt_conflict(a, b, i);
     }

     void add_conflict(const core::gc_ptr<core::managed_array<kind::BYTE>> &a,
                       const core::gc_ptr<core::branch> &b,
                       const array_index_type i) override {
       add_array_elmt_conflict(a, b, i);
     }

     void add_conflict(const core::gc_ptr<core::managed_array<kind::UBYTE>> &a,
                       const core::gc_ptr<core::branch> &b,
                       const array_index_type i) override {
       add_array_elmt_conflict(a, b, i);
     }

     void add_conflict(const core::gc_ptr<core::managed_array<kind::SHORT>> &a,
                       const core::gc_ptr<core::branch> &b,
                       const array_index_type i) override {
       add_array_elmt_conflict(a, b, i);
     }

     void add_conflict(const core::gc_ptr<core::managed_array<kind::USHORT>> &a,
                       const core::gc_ptr<core::branch> &b,
                       const array_index_type i) override {
       add_array_elmt_conflict(a, b, i);
     }

     void add_conflict(const core::gc_ptr<core::managed_array<kind::INT>> &a,
                       const core::gc_ptr<core::branch> &b,
                       const array_index_type i) override {
       add_array_elmt_conflict(a, b, i);
     }

     void add_conflict(const core::gc_ptr<core::managed_array<kind::UINT>> &a,
                       const core::gc_ptr<core::branch> &b,
                       const array_index_type i) override {
       add_array_elmt_conflict(a, b, i);
     }

     void add_conflict(const core::gc_ptr<core::managed_array<kind::LONG>> &a,
                       const core::gc_ptr<core::branch> &b,
                       const array_index_type i) override {
       add_array_elmt_conflict(a, b, i);
     }

     void add_conflict(const core::gc_ptr<core::managed_array<kind::ULONG>> &a,
                       const core::gc_ptr<core::branch> &b,
                       const array_index_type i) override {
       add_array_elmt_conflict(a, b, i);
     }

     void add_conflict(const core::gc_ptr<core::managed_array<kind::FLOAT>> &a,
                       const core::gc_ptr<core::branch> &b,
                       const array_index_type i) override {
       add_array_elmt_conflict(a, b, i);
     }

     void add_conflict(const core::gc_ptr<core::managed_array<kind::DOUBLE>> &a,
                       const core::gc_ptr<core::branch> &b,
                       const array_index_type i) override {
       add_array_elmt_conflict(a, b, i);
     }

     void add_conflict(const core::gc_ptr<core::managed_array<kind::STRING>> &a,
                       const core::gc_ptr<core::branch> &b,
                       const array_index_type i) override {
       add_array_elmt_conflict(a, b, i);
     }

     void add_conflict(const core::gc_ptr<core::managed_array<kind::RECORD>> &a,
                       const core::gc_ptr<core::branch> &b,
                       const array_index_type i) override {
       add_array_elmt_conflict(a, b, i);
     }

     void add_conflict(const core::gc_ptr<core::managed_array<kind::ARRAY>> &a,
                       const core::gc_ptr<core::branch> &b,
                       const array_index_type i) override {
       add_array_elmt_conflict(a, b, i);
     }


   public:
     virtual ~merge_result() {}

     iso_context_handle source_context() const {
       return _source_context;
     }

     iso_context_handle target_context() const {
       if (_target_context.is_null()) {
         if (!_source_context.is_null()) {
           _target_context = _source_context.new_child(view_type::parent_view, mod_type::read_only);
         }
       }
       return _target_context;
     }

     iso_context_handle last_common_snapshot() const {
       if (_last_common_snapshot.is_null()) {
         if (!_source_context.is_null()) {
           core::gc_ptr<core::iso_context> sc = _source_context.pointer();
           core::timestamp_t ts = sc->merge_before(_merge_time);
           _last_common_snapshot = target_context().ro_snapshot_at(ts);
         }
       }
       return _last_common_snapshot;
     }

     iso_context_handle source_at_merge() const {
       if (_source_at_merge.is_null()) {
         if (!_source_context.is_null()) {
           _source_at_merge = _source_context.ro_snapshot_at(_merge_time);
         }
       }
       return _source_at_merge;
     }
     iso_context_handle target_at_merge() const {
       if (_target_at_merge.is_null()) {
         if (!_source_context.is_null()) {
           _target_at_merge = target_context().ro_snapshot_at(_merge_time);
         }
       }
       return _target_at_merge;
     }

     virtual void merge_succeeded() = 0;
     virtual void merge_failed() = 0;
     virtual void merge_conflicts_complete() {}

     virtual void add_conflict(const managed_record_handle &r,
                               const record_field_handle<kind::BOOL> &f) = 0;
     virtual void add_conflict(const managed_record_handle &r,
                               const record_field_handle<kind::BYTE> &f) = 0;
     virtual void add_conflict(const managed_record_handle &r,
                               const record_field_handle<kind::UBYTE> &f) = 0;
     virtual void add_conflict(const managed_record_handle &r,
                               const record_field_handle<kind::SHORT> &f) = 0;
     virtual void add_conflict(const managed_record_handle &r,
                               const record_field_handle<kind::USHORT> &f) = 0;
     virtual void add_conflict(const managed_record_handle &r,
                               const record_field_handle<kind::INT> &f) = 0;
     virtual void add_conflict(const managed_record_handle &r,
                               const record_field_handle<kind::UINT> &f) = 0;
     virtual void add_conflict(const managed_record_handle &r,
                               const record_field_handle<kind::LONG> &f) = 0;
     virtual void add_conflict(const managed_record_handle &r,
                               const record_field_handle<kind::ULONG> &f) = 0;
     virtual void add_conflict(const managed_record_handle &r,
                               const record_field_handle<kind::FLOAT> &f) = 0;
     virtual void add_conflict(const managed_record_handle &r,
                               const record_field_handle<kind::DOUBLE> &f) = 0;
     virtual void add_conflict(const managed_record_handle &r,
                               const record_field_handle<kind::STRING> &f) = 0;
     virtual void add_conflict(const managed_record_handle &r,
                               const record_field_handle<kind::RECORD> &f) = 0;
     virtual void add_conflict(const managed_record_handle &r,
                               const record_field_handle<kind::ARRAY> &f) = 0;
     virtual void add_conflict(const namespace_handle &ns,
                               const interned_string_handle &name) = 0;
     virtual void add_conflict(const managed_array_handle<kind::BOOL> &a,
                               const array_index_type i) = 0;
     virtual void add_conflict(const managed_array_handle<kind::BYTE> &a,
                               const array_index_type i) = 0;
     virtual void add_conflict(const managed_array_handle<kind::UBYTE> &a,
                               const array_index_type i) = 0;
     virtual void add_conflict(const managed_array_handle<kind::SHORT> &a,
                               const array_index_type i) = 0;
     virtual void add_conflict(const managed_array_handle<kind::USHORT> &a,
                               const array_index_type i) = 0;
     virtual void add_conflict(const managed_array_handle<kind::INT> &a,
                               const array_index_type i) = 0;
     virtual void add_conflict(const managed_array_handle<kind::UINT> &a,
                               const array_index_type i) = 0;
     virtual void add_conflict(const managed_array_handle<kind::LONG> &a,
                               const array_index_type i) = 0;
     virtual void add_conflict(const managed_array_handle<kind::ULONG> &a,
                               const array_index_type i) = 0;
     virtual void add_conflict(const managed_array_handle<kind::FLOAT> &a,
                               const array_index_type i) = 0;
     virtual void add_conflict(const managed_array_handle<kind::DOUBLE> &a,
                               const array_index_type i) = 0;
     virtual void add_conflict(const managed_array_handle<kind::STRING> &a,
                               const array_index_type i) = 0;
     virtual void add_conflict(const managed_array_handle<kind::RECORD> &a,
                               const array_index_type i) = 0;
     virtual void add_conflict(const managed_array_handle<kind::ARRAY> &a,
                               const array_index_type i) = 0;
   };

   template <bool ConstP>
   inline
   void
   iso_context_handle_cp<ConstP>::publish(merge_result &cs) const {
     bool done;
     // std::cout << "iso_context_handle: publish" << std::endl;
     do {
       core::merge_result mr = pointer()->merge();
       done = cs.inject(mr);
     } while (!done);
     cs._source_context = *this;
   }

   template <kind K, bool ConstP, typename LeafT, typename Enable>
   inline
   record_field_handle<K>
   managed_type_handle_cp<K,ConstP,LeafT,Enable>::
   field_in(const record_type_handle &rtype, const interned_string_handle &name, bool create_if_absent) const {
     //     return nc_value()->field_in(rtype.nc_value(), name.value, create_if_absent);
     return pointer()->field_in(rtype.pointer(), name.pointer(), create_if_absent);
   }

   /*
    * This is a convenience class to allow stashing handles someplace so that you can refer to them
    * by an index, suitable for storing in a Java object.  If you do so, remember to call free() when the
    * last use of the handle is gone (e.g., in a native finalize() method).  If you can hold the handle
    * directly, it will be more efficient.  No effort is made to determine that the handle is not already
    * in the store.  What is returned is a copy of the handle, so modifications are not preserved.
    *
    * index 0 is reserved to indicate a value of T{} (null handle, null pointer, or zero value).
    * Otherwise, index i refers to the (i-1)th element of the vector.
    */
   template <typename T>
   class handle_store {
   public:
     using index_type = std::size_t;
   private:
     std::stack<std::size_t> _free_list;
     std::vector<T> _handles;
     mutable std::mutex _mutex;
     static handle_store &_store() {
       static handle_store hs;
       return hs;
     }
     index_type _store(const T &handle) {
       if (handle == T{}) {
         return 0;
       }
       std::lock_guard<std::mutex> lock{_mutex};
       if (_free_list.empty()) {
         _handles.push_back(handle);
         index_type i = _handles.size();
         return i;
       } else {
         index_type i = _free_list.top();
         _free_list.pop();
         _handles[i-1] = handle;
         return i;
       }
     }

     void _free(index_type i) {
       if (i != 0) {
         std::lock_guard<std::mutex> lock{_mutex};
         _free_list.push(i);
         _handles[i-1] = T{};
       }
     }

     T _get(index_type i) {
       if (i == 0) {
         return T{};
       }
       std::lock_guard<std::mutex> lock{_mutex};
       return _handles[i-1];
     }
   public:
     static index_type store(const T &handle) {
       return _store()._store(handle);
     }
     static void free(index_type i) {
       _store()._free(i);
     }
     static T get(index_type i) {
       return _store()._get(i);
     }

   };

   /*
    * This is a convenience class to allow stashing handles someplace so that you can refer to them
    * by an index, suitable for storing in a Java object.  If you do so, remember to call free() when the
    * last use of the handle is gone (e.g., in a native finalize() method).  If you can hold the handle
    * directly, it will be more efficient.
    *
    * In this variant (unlike in handle_store), only one instance of each handle is kept, so identical indices
    * imply identical handles.  Note that this only applies while the handle is in the store.  Each entry in
    * the store keeps a reference count, incremented by calls to store(h) and decremented by calls to free(i).
    * When this count hits zero, free() returns true, and the index may be reused for another handle.
    *
    * Calls to store(h), by default, assume that the returned index will be used to create a new wrapper object
    * (which will call free() in its finalize method), so the reference count is incremented.  Users who maintain
    * a side table of objects, so they can be reused, should pass in a second parameter of false, which indicates
    * that the reference count should not be incremented if the handle exists in the table.  The return value from
    * store() includes an indication of whether the handle was added to the store by this operation.
    *
    * No effort is made to determine that the handle is not already
    * in the store.  What is returned is a copy of the handle, so modifications are not preserved.
    *
    * index 0 is reserved to indicate a value of T{} (null handle, null pointer, or zero value).
    * Otherwise, index i refers to the (i-1)th element of the vector.
    */
   template <typename T>
   class unique_handle_store {
   public:
     using index_type = std::size_t;
     struct return_type {
       bool is_new_index;
       index_type index;
       return_type(bool nip, index_type i) : is_new_index{nip}, index{i} {}
       operator index_type() const {
         return index;
       }
     };
   private:
     struct counted_handle {
       std::size_t count;
       T handle;
       counted_handle(const T &h) : count{0}, handle{h} {}
     };
     std::stack<std::size_t> _free_list;
     std::vector<counted_handle> _handles;
     std::unordered_map<T,index_type> _known;
     mutable std::mutex _mutex;
     static unique_handle_store &_store() {
       static unique_handle_store hs;
       return hs;
     }
     return_type _store(const T &handle, bool inc_if_existsp) {
       if (handle == T{}) {
         return return_type{false, 0};
       }
       std::lock_guard<std::mutex> lock{_mutex};
       index_type &i = _known[handle];
       bool is_new = i==0;
       if (is_new) {
         // This one was not in the map.
         if (_free_list.empty()) {
           _handles.push_back(handle);
           i = _handles.size();
         } else {
           i = _free_list.top();
           _free_list.pop();
           _handles[i-1] = handle;
         }
       }
       if (is_new || inc_if_existsp) {
         _handles[i-1].count++;
       }
       return return_type{is_new, i};
     }

     bool _free(index_type i) {
       if (i != 0) {
         std::lock_guard<std::mutex> lock{_mutex};
         counted_handle &h = _handles[i-1];
         if (--h.count == 0) {
           _free_list.push(i);
           _known.erase(h.handle);
           h.handle = T{};
           return true;
         } else {
           return false;
         }
       }
       return false;
     }

     T _get(index_type i) {
       if (i == 0) {
         return T{};
       }
       std::lock_guard<std::mutex> lock{_mutex};
       return _handles[i-1].handle;
     }

     void _add_ref(index_type i) {
       if (i != 0) {
	 std::lock_guard<std::mutex> lock{_mutex};
	 _handles[i-1].count++;
       }
     }
   public:
     static return_type store(const T &handle, bool inc_if_existsp = true) {
       return _store()._store(handle, inc_if_existsp);
     }
     static bool free(index_type i) {
       return _store()._free(i);
     }
     static T get(index_type i) {
       return _store()._get(i);
     }
     static void add_ref(index_type i) {
       _store()._add_ref(i);
     }

   };
 }

}

namespace ruts {

 template <bool CP>
 struct hash1<mds::api::interned_string_handle_cp<CP>>
   : intrinsic_hash1<mds::api::interned_string_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::interned_string_handle_cp<CP>>
   : intrinsic_hash2<mds::api::interned_string_handle_cp<CP>> {};

 template <bool CP>
 struct hash1<mds::api::iso_context_handle_cp<CP>>
   : intrinsic_hash1<mds::api::iso_context_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::iso_context_handle_cp<CP>>
   : intrinsic_hash2<mds::api::iso_context_handle_cp<CP>> {};

 template <bool CP>
 struct hash1<mds::api::managed_record_handle_cp<CP>>
   : intrinsic_hash1<mds::api::managed_record_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::managed_record_handle_cp<CP>>
   : intrinsic_hash2<mds::api::managed_record_handle_cp<CP>> {};

 template <bool CP>
 struct hash1<mds::api::managed_array_base_handle_cp<CP>>
   : intrinsic_hash1<mds::api::managed_array_base_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::managed_array_base_handle_cp<CP>>
   : intrinsic_hash2<mds::api::managed_array_base_handle_cp<CP>> {};

 template <mds::api::kind K, bool CP>
 struct hash1<mds::api::managed_array_handle_cp<K,CP>>
   : intrinsic_hash1<mds::api::managed_array_handle_cp<K,CP>> {};
 template <mds::api::kind K, bool CP>
 struct hash2<mds::api::managed_array_handle_cp<K,CP>>
   : intrinsic_hash2<mds::api::managed_array_handle_cp<K,CP>> {};

 template <mds::api::kind K, bool CP>
 struct hash1<mds::api::record_field_handle_cp<K,CP>>
   : intrinsic_hash1<mds::api::record_field_handle_cp<K,CP>> {};
 template <mds::api::kind K, bool CP>
 struct hash2<mds::api::record_field_handle_cp<K,CP>>
   : intrinsic_hash2<mds::api::record_field_handle_cp<K,CP>> {};

 template <mds::api::kind K, bool CP, typename L>
 struct hash1<mds::api::managed_type_handle_cp<K,CP,L>>
   : intrinsic_hash1<mds::api::managed_type_handle_cp<K,CP,L>> {};
 template <mds::api::kind K, bool CP, typename L>
 struct hash2<mds::api::managed_type_handle_cp<K,CP,L>>
   : intrinsic_hash2<mds::api::managed_type_handle_cp<K,CP,L>> {};

 template <bool CP>
 struct hash1<mds::api::record_type_handle_cp<CP>>
   : intrinsic_hash1<mds::api::record_type_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::record_type_handle_cp<CP>>
   : intrinsic_hash2<mds::api::record_type_handle_cp<CP>> {};

 template <bool CP>
 struct hash1<mds::api::array_type_base_handle_cp<CP>>
   : intrinsic_hash1<mds::api::array_type_base_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::array_type_base_handle_cp<CP>>
   : intrinsic_hash2<mds::api::array_type_base_handle_cp<CP>> {};

 template <mds::api::kind K, bool CP>
 struct hash1<mds::api::array_type_handle_cp<K,CP>>
   : intrinsic_hash1<mds::api::array_type_handle_cp<K,CP>> {};
 template <mds::api::kind K, bool CP>
 struct hash2<mds::api::array_type_handle_cp<K,CP>>
   : intrinsic_hash2<mds::api::array_type_handle_cp<K,CP>> {};

 template <bool CP>
 struct hash1<mds::api::namespace_handle_cp<CP>>
   : intrinsic_hash1<mds::api::namespace_handle_cp<CP>> {};
 template <bool CP>
 struct hash2<mds::api::namespace_handle_cp<CP>>
   : intrinsic_hash2<mds::api::namespace_handle_cp<CP>> {};

}

namespace std {
  template <bool CP>
  struct hash<mds::api::iso_context_handle_cp<CP>> : ruts::delegate_hash<mds::api::iso_context_handle_cp<CP>> {};

  template <bool CP>
  struct hash<mds::api::interned_string_handle_cp<CP>> : ruts::delegate_hash<mds::api::interned_string_handle_cp<CP>> {};

  template <bool CP>
  struct hash<mds::api::managed_record_handle_cp<CP>> : ruts::delegate_hash<mds::api::managed_record_handle_cp<CP>> {};

  template <mds::api::kind K, bool CP>
  struct hash<mds::api::record_field_handle_cp<K,CP>> : ruts::delegate_hash<mds::api::record_field_handle_cp<K,CP>> {};

  template <bool CP>
  struct hash<mds::api::managed_array_base_handle_cp<CP>> : ruts::delegate_hash<mds::api::managed_array_base_handle_cp<CP>> {};

  template <mds::api::kind K, bool CP>
  struct hash<mds::api::managed_array_handle_cp<K,CP>> : ruts::delegate_hash<mds::api::managed_array_handle_cp<K,CP>> {};

  template <mds::api::kind K, bool CP, typename L>
  struct hash<mds::api::managed_type_handle_cp<K,CP,L>> : ruts::delegate_hash<mds::api::managed_type_handle_cp<K,CP,L>> {};

  template <bool CP>
  struct hash<mds::api::record_type_handle_cp<CP>> : ruts::delegate_hash<mds::api::record_type_handle_cp<CP>> {};

  template <bool CP>
  struct hash<mds::api::array_type_base_handle_cp<CP>> : ruts::delegate_hash<mds::api::array_type_base_handle_cp<CP>> {};

  template <mds::api::kind K, bool CP>
  struct hash<mds::api::array_type_handle_cp<K,CP>> : ruts::delegate_hash<mds::api::array_type_handle_cp<K,CP>> {};

  template <bool CP>
  struct hash<mds::api::namespace_handle_cp<CP>> : ruts::delegate_hash<mds::api::namespace_handle_cp<CP>> {};

  template <typename T>
  inline
  void swap(mds::api::branch_independent_handle<T> &lhs, mds::api::branch_independent_handle<T> &rhs) {
    lhs.swap(rhs);
  }
  template <typename T>
  inline
  void swap(mds::api::branch_relative_handle<T> &lhs, mds::api::branch_relative_handle<T> &rhs) {
    lhs.swap(rhs);
  }

//  template <typename T, typename E>
//  struct hash<mds::api::branch_relative_handle<T,E>> : ruts::delegate_hash<mds::api::branch_relative_handle<T,E>> {};

  template <typename C, typename Tr, typename T, typename E>
  basic_ostream<C,Tr> &
  operator <<(basic_ostream<C,Tr> &os, const mds::api::branch_independent_handle<T,E> &h) {
    return os << h.pointer();
  }

  template <typename C, typename Tr, typename T, typename E>
  basic_ostream<C,Tr> &
  operator <<(basic_ostream<C,Tr> &os, const mds::api::branch_relative_handle<T,E> &h) {
    return os << h.pointer() << "{" << h.branch() << "}";
  }


}


#endif /* MDS_API_H_ */
