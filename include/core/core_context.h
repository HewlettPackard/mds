/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * core_context.h
 *
 *  Created on: Oct 21, 2014
 *      Author: evank
 */

#ifndef CORE_CONTEXT_H_
#define CORE_CONTEXT_H_

#include "mpgc/external_gc_ptr.h"
#include "mpgc/gc_stack.h"
#include "core/core_fwd.h"
#include "core/core_globals.h"
#include "core/core_conflict.h"
#include "core/core_task.h"
#include "ruts/weak_key.h"
#include <unordered_map>
#include <cassert>

namespace mds {
  namespace core {
    class view : public gc_allocated, public with_uniform_id {
    public:
      const gc_ptr<iso_context> context;
      gc_ptr<view> parent;
      const gc_array_ptr<view> ancestors;

      static const auto &descriptor() {
        static gc_descriptor d =
	  GC_DESC(view)
	  .WITH_SUPER(gc_allocated)
	  .WITH_SUPER(with_uniform_id)
	  .WITH_FIELD(&view::context)
	  .WITH_FIELD(&view::parent)
	  .WITH_FIELD(&view::ancestors)
          ;
        return d;
      }

      view(gc_token &gc, const gc_ptr<iso_context> &ctxt, const gc_ptr<view> &p)
        : gc_allocated{gc}, context(ctxt), parent{p},
          ancestors((p == nullptr || p->parent == nullptr) ? 0 : p->ancestors.size()+1)
      {
        std::size_t n = ancestors.size();
        if (n > 0) {
          const auto &parray = p->ancestors;
          std::copy(parray.begin(), parray.end(), ancestors.begin());
          ancestors[n-1] = p;
        }
        // std::cout << "View "<< GC_THIS << " created"
        //   //                  << " in " << ctxt
        //           << " off of " << p
        //           << std::endl;
      }

      std::size_t level() const {
        if (parent == nullptr) {
          return 0;
        } else {
          return ancestors.size()+1;
        }
      }

      /* 
       * If there's no MSV when we do a read, do we need to create
       * one?  The value of the read is going to be the default value,
       * but live views will need to do work to freeze and publishable
       * snapshots will need to do work to see parent values as
       * inducing conflicts.
       */
      bool need_msv_on_initial_read() const;
    }; // view

    class shadow_cache;

    static gc_ptr<view> shadow_cache_lookup(const gc_ptr<iso_context> &c,
                                            const gc_ptr<view> &v);



    class publication_attempt : public exportable, public with_uniform_id {
      class redo_graph;
      
      const gc_ptr<iso_context> _context;
      const conflict_list _conflicts;
      const timestamp_t _at_time;
      mutable std::atomic<gc_ptr<redo_graph>> _redo_graph{nullptr};

      gc_ptr<redo_graph> get_redo_graph() const;
      std::vector<gc_ptr<task>> get_redo_task_list() const;
    public:
      publication_attempt(gc_token &gc,
                          const gc_ptr<iso_context> &c,
                          const conflict_list &conflicts,
                          timestamp_t ts)
        : exportable{gc}, _context{c}, _conflicts{conflicts}, _at_time{ts}
      {}
      static const auto &descriptor() {
        static gc_descriptor d =
	  GC_DESC(publication_attempt)
	  .WITH_SUPER(exportable)
	  .WITH_SUPER(with_uniform_id)
	  .WITH_FIELD(&publication_attempt::_context)
	  .WITH_FIELD(&publication_attempt::_conflicts)
	  .WITH_FIELD(&publication_attempt::_at_time)
	  .WITH_FIELD(&publication_attempt::_redo_graph)
          ;
        return d;
      }
      
      bool succeeded() const {
        return _conflicts.empty();
      }
      gc_ptr<iso_context> context() const {
        return _context;
      }

      conflict_list conflicts() const {
        return _conflicts;
      }

      timestamp_t timestamp() const {
        return _at_time;
      }

      std::size_t n_to_redo() const;

      std::vector<gc_ptr<task>> redo_tasks_by_start_time() const;

      bool prepare_for_redo() const;

      void redo(const gc_ptr<task> &) const;

    }; // publication_attempt

    class iso_context : public exportable, public with_uniform_id {

    public:
      using modified_vc_list = gc_threaded_list<gc_ptr<modified_value_chain>>;
      using blocking_mod_list = gc_threaded_list<gc_ptr<blocking_mod>>;

      struct in_process_inbound_publish;

      class published_state;
      class unpublished_state;
      enum class state_types { PUBLISHED, UNPUBLISHED };

      class state_t : public gc_allocated_with_virtuals<state_t,state_types> {
        using base = gc_allocated_with_virtuals<state_t,state_types>;
      public:
        static void init_vf_table(typename base::vf_table &);
        
        /*
         * The publish() method returns a pair containing the last
         * unpublished state processed and the published state to use
         * as the prior for the new published state.  It throws a
         * conflict list if it found conflicts.
         */
        
        using publish_return = std::pair<gc_ptr<const unpublished_state>,
                                         gc_ptr<const published_state>>;
        
        
        
        gc_ptr<const published_state> prior_published_state;

        struct virtuals : virtuals_base {
          virtual gc_ptr<const published_state> most_recent_published(const state_t *self) const = 0;
          
          virtual conflict_list conflicts(const state_t *self) const = 0;
          virtual gc_ptr<const state_t>
          add_conflict(const state_t *self, const gc_ptr<const conflict> &) const = 0;
          virtual gc_ptr<const state_t>
          add_modified(const state_t *self, const gc_ptr<modified_value_chain> &) const = 0;
          virtual gc_ptr<const state_t>
          add_blocker(const state_t *self, const gc_ptr<blocking_mod> &) const = 0;

          virtual gc_ptr<const state_t>
          note_resolved(const state_t *self, const conflict_list &conflicts) const = 0;
          virtual publish_return publish(const state_t *self,
                                         const gc_ptr<const published_state> &new_state,
                                         const gc_ptr<const unpublished_state> &last,
                                         iso_context &c) const = 0;

          /*
           * Used when rolling forward a snapshot.  Gives the context
           * a last published time as of the provided time, but leaves
           * any unpublished stuff in front of it.
           */
          virtual gc_ptr<state_t> roll_forward(const state_t *self, timestamp_t as_of) const = 0;
                                       

        }; // virtuals

        gc_ptr<const published_state> most_recent_published() const {
          return call_virtual(this, &virtuals::most_recent_published);
        }

        conflict_list conflicts() const {
          return call_virtual(this, &virtuals::conflicts);
        }

        gc_ptr<const state_t>
        add_conflict(const gc_ptr<const conflict> &c) const {
          return call_virtual(this, &virtuals::add_conflict, c);
        }

        gc_ptr<const state_t>
        add_modified(const gc_ptr<modified_value_chain> &mvc) const {
          return call_virtual(this, &virtuals::add_modified, mvc);
        }

        gc_ptr<const state_t>
        add_blocker(const gc_ptr<blocking_mod> &b) const {
          return call_virtual(this, &virtuals::add_blocker, b);
        }

        gc_ptr<const state_t>
        note_resolved(const conflict_list &conflicts) const {
          return call_virtual(this, &virtuals::note_resolved, conflicts);
        }

        publish_return publish(const gc_ptr<const published_state> &new_state,
                               const gc_ptr<const unpublished_state> &last,
                               iso_context &c) const
        {
          return call_virtual(this, &virtuals::publish, new_state, last, c);
        }

        gc_ptr<state_t> roll_forward(timestamp_t as_of) const {
          return call_virtual(this, &virtuals::roll_forward, as_of);
        }
        
        state_t(gc_token &gc,
                const gc_ptr<const published_state> &pps,
                discriminator_type d)
          : base{gc, d}, prior_published_state{pps}
        {
          if (pps != nullptr) {
            pps->mark_published();
          }
        }

        static auto &descriptor() {
          static gc_descriptor d =
	    GC_DESC(state_t)
            .WITH_SUPER(base)
            .WITH_FIELD(&state_t::prior_published_state);
          return d;
        }

        void set_prior(const gc_ptr<const published_state> &pps) {
          pps->mark_published();
          prior_published_state = pps;
        }
      }; // state_t

      friend class pending_rollup;

      class published_state : public state_t {
        friend class pending_rollup;
      public:
        enum class status_t { Pending, Published, Failed };
      private:
        mutable status_t _status;
        timestamp_t _timestamp;
      public:

        static constexpr discriminator_type discrim = state_types::PUBLISHED;

        published_state(gc_token &gc, timestamp_t ts,
                        const gc_ptr<const published_state> &pps = nullptr,
                        discriminator_type d = discrim)
          : state_t{gc, pps, d}, _status{status_t::Published}, _timestamp{ts}
        {}

        explicit published_state(gc_token &gc,
                                 discriminator_type d = discrim)
          : state_t{gc, nullptr, d}, _status{status_t::Pending}
        {}

        static auto &descriptor() {
          static gc_descriptor d =
            GC_DESC(published_state)
            .WITH_SUPER(state_t)
            .WITH_FIELD(&published_state::_status)
            .WITH_FIELD(&published_state::_timestamp);
          return d;
        }

        struct virtuals : state_t::virtuals {
          using impl = published_state;
          gc_ptr<const published_state> most_recent_published(const state_t *self) const override {
            return self->call_non_virtual(&impl::most_recent_published_impl);
          }
          conflict_list conflicts(const state_t *self) const override {
            return self->call_non_virtual(&impl::conflicts_impl);
          }
          gc_ptr<const state_t>
          add_conflict(const state_t *self,
                       const gc_ptr<const conflict> &c) const override
          {
            return self->call_non_virtual(&impl::add_conflict_impl, c);
          }
          gc_ptr<const state_t>
          add_modified(const state_t *self,
                       const gc_ptr<modified_value_chain> &m) const override
          {
            return self->call_non_virtual(&impl::add_modified_impl, m);
          }
          gc_ptr<const state_t>
          add_blocker(const state_t *self,
                      const gc_ptr<blocking_mod> &b) const override
          {
            return self->call_non_virtual(&impl::add_blocker_impl, b);
          }
          gc_ptr<const state_t>
          note_resolved(const state_t *self,
                        const conflict_list &conflicts) const override
          {
            return self->call_non_virtual(&impl::note_resolved_impl, conflicts);
          }
          publish_return publish(const state_t *self,
                                 const gc_ptr<const published_state> &new_state,
                                 const gc_ptr<const unpublished_state> &last,
                                 iso_context &c) const override
          {
            return self->call_non_virtual(&impl::publish_impl, new_state, last, c);
          }

          gc_ptr<state_t> roll_forward(const state_t *self,
                                       timestamp_t as_of)  const override
          {
            return self->call_non_virtual(&impl::roll_forward_impl, as_of);
          }
                                       
        }; // virtuals

        gc_ptr<const published_state> most_recent_published_impl() const {
          return GC_THIS;
        }
        conflict_list conflicts_impl() const {
          return conflict_list{};
        }
        gc_ptr<const state_t>
        add_conflict_impl(const gc_ptr<const conflict> &c) const; 
        gc_ptr<const state_t>
        add_modified_impl(const gc_ptr<modified_value_chain> &m) const;
        gc_ptr<const state_t>
        add_blocker_impl(const gc_ptr<blocking_mod> &b) const;

        gc_ptr<const state_t>
        note_resolved_impl(const conflict_list &conflicts) const {
          return GC_THIS;
        }
        publish_return publish_impl(const gc_ptr<const published_state> &new_state,
                                    const gc_ptr<const unpublished_state> &last,
                                    iso_context &c) const
        {
          return std::make_pair(last, GC_THIS);
        }

        gc_ptr<state_t> roll_forward_impl(timestamp_t as_of) const {
          return make_gc<published_state>(as_of, GC_THIS);
        }

        timestamp_t timestamp() const {
          return _timestamp;
        }

        void set_timestamp(timestamp_t ts) {
          _timestamp = ts;
        }

        void set_ts_and_prior(timestamp_t ts,
                              const gc_ptr<const published_state> &pps)
        {
          set_timestamp(ts);
          set_prior(pps);
        }

        void mark_published() const {
          _status = status_t::Published;
        }

        status_t status(const gc_ptr<iso_context> &ctxt) const {
          if (_status == status_t::
              Pending && ctxt->current_state() == GC_THIS)
            {
              mark_published();
            }
          return _status;
        }

      }; // published_state

    private:

      struct shadow_node : public gc_allocated {
        const weak_gc_ptr<view> base;
        const weak_gc_ptr<view> shadow;
        gc_ptr<shadow_node> next;
        shadow_node(gc_token &gc, const gc_ptr<view> &b,
                    const gc_ptr<view> &s,
                    const gc_ptr<shadow_node> &n)
          : gc_allocated{gc}, base{b}, shadow{s}, next{n}
        {}
        static const auto &descriptor() {
          static gc_descriptor d =
            GC_DESC(shadow_node)
            .WITH_FIELD(&shadow_node::base)
            .WITH_FIELD(&shadow_node::shadow)
            .WITH_FIELD(&shadow_node::next);
          return d;
        }
      }; // shadow_node

      const gc_ptr<iso_context>  _parent;
      const gc_ptr<task> _creation_task;
      mutable std::atomic<gc_ptr<task>> _top_level_task{nullptr};
      std::atomic<gc_ptr<const state_t> > _state;
      const view_type _view_type;
      const mod_type _mod_type;
      std::atomic<gc_ptr<shadow_node>> _shadows;
      gc_atomic_stack<gc_ptr<blocking_mod>> _block_inbound;
      gc_atomic_stack<gc_ptr<in_process_inbound_publish>> _in_process;
      std::atomic<bool> _has_publishable_children;
      gc_atomic_stack<gc_ptr<task>> _unconditional_redo_tasks;
        

      class private_ctor {};
      friend class control;
      class global_context_t {};

      void drain_inbound_blockers(const gc_ptr<iso_context> &child);

      static gc_ptr<task> compute_creation_task(const gc_ptr<iso_context> &p) {
        gc_ptr<task> t = task::prevailing();
        if (t->get_context() == p) {
          return t;
        } else {
          return p->top_level_task();
        }
      }

    public:
      static const auto &descriptor() {
        static gc_descriptor d =
	  GC_DESC(iso_context)
          .WITH_SUPER(exportable)
	  .WITH_SUPER(with_uniform_id)
	  .WITH_FIELD(&iso_context::_parent)
	  .WITH_FIELD(&iso_context::_creation_task)
	  .WITH_FIELD(&iso_context::_top_level_task)
	  .WITH_FIELD(&iso_context::_state)
	  .WITH_FIELD(&iso_context::_view_type)
	  .WITH_FIELD(&iso_context::_mod_type)
          .WITH_FIELD(&iso_context::_shadows)
          .WITH_FIELD(&iso_context::_block_inbound)
          .WITH_FIELD(&iso_context::_in_process)
          .WITH_FIELD(&iso_context::_has_publishable_children)
          .WITH_FIELD(&iso_context::_unconditional_redo_tasks)
          ;
        return d;
      }

      iso_context(gc_token &gc,
                  private_ctor, const gc_ptr<iso_context> &p,
		  view_type vt, mod_type mt)
        : exportable(gc),
          _parent{p},
          _creation_task{compute_creation_task(p)},
          _state{make_gc<published_state>(vt == view_type::snapshot ? new_value_timestamp(GC_THIS)
                                          : current_value_timestamp())},
          _view_type{vt}, _mod_type{mt},
          _shadows{nullptr}, _has_publishable_children{false}
          {
            // std::cout << "Created a context [" << vt << "," << mt << "]: "
            //           << GC_THIS << std::endl;
            if (is_publishable()) {
              p->_has_publishable_children = true;
            }
          }


      iso_context(gc_token &gc, private_ctor, global_context_t)
        : exportable{gc},
          _parent{nullptr},
          _creation_task{},
          _state{make_gc<published_state>(0)},
          _view_type{view_type::live}, _mod_type{mod_type::detached},
          _shadows{nullptr}, _has_publishable_children{false}
          {}

      static gc_ptr<iso_context> prevailing() {
        return task::prevailing()->get_context();
      }

      gc_ptr<task> push_prevailing() {
        return top_level_task()->push();
      }
      
      gc_ptr<iso_context> parent() const {
        return _parent;
      }

      gc_ptr<task> creation_task() const {
        return _creation_task;
      }

      gc_ptr<task> top_level_task() const {
        gc_ptr<task> t = _top_level_task;
        if (t != nullptr) {
          return t;
        } else {
          t = task::for_context(std::const_pointer_cast<iso_context>(GC_THIS));
          auto rr = ruts::try_change_value(_top_level_task, nullptr, t);
          return rr.resulting_value();
        }
      }

      bool is_global() const {
        return _parent == nullptr;
      }

      static constexpr global_context_t global{};

      gc_ptr<view> shadow(const gc_ptr<view> &v) {
        assert(v != nullptr);
        if (v->context == this) {
          return v;
        }
        return shadow_cache_lookup(GC_THIS, v);
      }

      static gc_ptr<view> shadowed(const gc_ptr<view> &v) {
        return prevailing()->shadow(v);
      }

      gc_ptr<view> find_shadow(const gc_ptr<view> &v);

      template <typename T>
      vd_value<T> shadowed_val(const vd_value<T> &val) {
	return val.in_view == nullptr ? vd_value<T>() : vd_value<T>(val.value, shadow(val.in_view));
      }

      template <typename T>
      const T &shadowed_val(const T &val) {
	return val;
      }

      mod_type get_mod_type() const {
        return _mod_type;
      }

      view_type get_view_type() const {
        return _view_type;
      }

      std::pair<mod_type, view_type> get_mod_and_view_types() const {
        return std::make_pair(_mod_type, _view_type);
      }

      bool is_snapshot() const {
        return _view_type == view_type::snapshot;
      }

      bool is_read_only() const {
        return _mod_type == mod_type::read_only;
      }

      bool is_publishable() const {
        return _mod_type == mod_type::publishable;
      }

      bool is_detached() const {
        return !is_publishable();
      }

      gc_ptr<const state_t> current_state() const {
        return _state.load();
      }

      gc_ptr<const published_state> most_recent_published_state() const {
        return current_state()->most_recent_published();
      }

      timestamp_t last_stable_time() const {
        return most_recent_published_state()->timestamp();
      }

      timestamp_t stable_time_before(timestamp_t ts) const {
        gc_ptr<const published_state> s = last_publish_before(ts);
        return s == nullptr ? 0 : s->timestamp();
      }

      gc_ptr<const published_state> first_publish_after(timestamp_t ts) const {
        gc_ptr<const published_state> best = most_recent_published_state();
        if (best->timestamp() <= ts) {
          return nullptr;
        }
        for (gc_ptr<const published_state> s = best->prior_published_state;
             s != nullptr && s->timestamp() > ts;
             s = s->prior_published_state)
          {
            best = s;
          }
        return best;
      }

      gc_ptr<const published_state> last_publish_before(timestamp_t ts) const
      {
        for (gc_ptr<const published_state> s = most_recent_published_state();
             s != nullptr;
             s = s->prior_published_state)
          {
            if (s->timestamp() < ts) {
              return s;
            }
          }
        return nullptr;
      }

      timestamp_t publish_time_before(timestamp_t ts) const {
        gc_ptr<const published_state> s = last_publish_before(ts);
        return s == nullptr ? 0 : s->timestamp();
      }

      gc_ptr<iso_context> new_child(view_type vt, mod_type mt) {
        if (mt == mod_type::publishable && is_read_only()) {
          throw read_only_context_ex{};
        }
        /*
         * Parent needs to be non-const.
         * TODO: Should this method be non-const?
         */
        iso_context *nc_this = const_cast<iso_context*>(this);
        return make_gc<iso_context>(private_ctor{}, this_as_gc_ptr(nc_this), vt, mt);
      }

      gc_ptr<publication_attempt> publish();

      void block_inbound_publication(const gc_ptr<blocking_mod> &bm);

    protected:
      gc_ptr<in_process_inbound_publish> prepare_for_publish(const gc_ptr<iso_context> &child);

    public:
      template <typename Fn>
      void update_state(Fn &&fn) {
        ruts::cas_loop(_state, [fn=std::forward<Fn>(fn)](const auto &old) {
            return fn(old);
          });
      }

      void add_conflict(const gc_ptr<conflict> &c) {
        if (is_publishable()) {
          update_state([&](const auto &old) {
              return old->add_conflict(c);
            });
        }
      }
      void add_modification(const gc_ptr<modified_value_chain> &mvc)
      {
        if (is_publishable()) {
          update_state([&](const auto &old) {
              return old->add_modified(mvc);
            });
        }
      }
      void block_publication(const gc_ptr<blocking_mod> &bm) {
        if (is_publishable()) {
          update_state([&](const auto &old) {
              return old->add_blocker(bm);
            });
        }
      }

      void unconditionally_redo(const gc_ptr<task> &t) {
        _unconditional_redo_tasks.push(t);
      }

      template <typename Fn>
      void for_each_unconditional_redo(Fn &&fn) {
        _unconditional_redo_tasks.for_each(std::forward<Fn>(fn));
      }

      void note_resolved(const conflict_list &conflicts) {
        /*
         * If there are more conflicts already we don't bother.  We'll
         * catch them next time.
         */
        if (current_state()->conflicts() == conflicts) {
          update_state([&](const auto &old) {
              return old->note_resolved(conflicts);
            });
        }
      }

      bool has_conflicts() const {
        return !current_state()->conflicts().empty();
      }

      void roll_snapshot_forward(timestamp_t as_of) {
        assert(is_snapshot());
        ruts::try_cas(_state,
                      [=](const auto &current) {
                        auto ts = current->prior_published_state->timestamp();
                        /*
                         * We don't do anything if it's been published
                         * or rolled forward past the point we want.
                         */
                        return ts < as_of;
                      },
                      [=](const auto &current) {
                        return current->roll_forward(as_of);
                      });
      }

    }; // iso_context

    /*
     * If there's no MSV when we do a read, do we need to create one?
     *
     * For the top-level view, the answer is no.  For live views, the
     * answer is yes, since we have to freeze because the parent might
     * change.  For detached and read-only snapshots, the answer is
     * no, because the value is established by the timestamp, which is
     * necessarily in the past, and future parent values are
     * irrelevant.  For publishable snapshots, the answer is yes,
     * because the value chain needs to be plugged in as a contingent
     * child of its parent so that it can see future parent
     * modifications as meaning that it should get a conflict.
     */
    inline
    bool
    view::need_msv_on_initial_read() const {
      return (parent != nullptr)
        && (!context->is_snapshot()
            || context->is_publishable());
    }
  }
}

namespace ruts {
  template <> struct stable_key<mds::core::iso_context>
    : uniform_id_stable_key<mds::core::iso_context> {};
  template <> struct stable_key<mds::core::view>
    : uniform_id_stable_key<mds::core::view> {};
}

namespace mds {
  namespace core {
    class shadow_cache {
      /*
       * The keys of these maps should be weak as well.
       */
      using shadow_map = std::unordered_map<ruts::weak_key<external_weak_gc_ptr<view>>,
                                            external_weak_gc_ptr<view>>;
      using context_map = std::unordered_map<ruts::weak_key<external_weak_gc_ptr<iso_context>>,
                                             shadow_map>;

      struct recent : gc_allocated {
        weak_gc_ptr<iso_context> _last_context = nullptr;
        weak_gc_ptr<view> _last_view = nullptr;
        weak_gc_ptr<view> _last_shadow = nullptr;
        explicit recent(gc_token &tok) : gc_allocated{tok} {}
        static const auto &descriptor() {
          static gc_descriptor d =
            GC_DESC(recent)
            .WITH_SUPER(gc_allocated)
            .WITH_FIELD(&recent::_last_context)
            .WITH_FIELD(&recent::_last_view)
            .WITH_FIELD(&recent::_last_shadow)
            ;
          return d;
        }
        
      };
      const external_gc_ptr<recent> _recent = make_gc<recent>();
      shadow_map *_last_shadow_map = nullptr;
      context_map _context_map;
    public:
      gc_ptr<view> lookup(const gc_ptr<iso_context> &c,
                          const gc_ptr<view> &v);
      static shadow_cache &instance() {
        static thread_local shadow_cache sc;
        return sc;
      }
    }; //shadow_cache


    inline
    gc_ptr<view>
    shadow_cache::lookup(const gc_ptr<iso_context> &c,
                         const gc_ptr<view> &v)
    {
      gc_ptr<iso_context> last_context = _recent->_last_context.lock();
      if (c != last_context) {
        // ext_c = c;
        _last_shadow_map = &_context_map[c];
        _recent->_last_context = c;
        _recent->_last_view = nullptr;
      }
      gc_ptr<view> last_view = _recent->_last_view.lock();
      gc_ptr<view> last_shadow;
      if (v == last_view) {
        last_shadow = _recent->_last_shadow.lock();
      }
      if (last_shadow == nullptr) {
        external_gc_ptr<view> esv = (*_last_shadow_map)[v].lock();
        if (esv == nullptr) {
          /*
           * We have to be careful here, becase our call to
           * find_shadow() may wind up calling shadow(), which will
           * call us and may play with our cache values.  So we can't
           * assume past this call that any of them are still valid
           * and that none of the maps have changed.  If _last_context
           * is still right, then _last_shadow_map will also be right,
           * but it might have changed.  So we have to put the new
           * value in explicitly.
           */
          esv = c->find_shadow(v);
          if (c != _recent->_last_context.lock()) {
            _last_shadow_map = &_context_map[c];
            _recent->_last_context = c;
          }
          (*_last_shadow_map)[v] = esv;
        }
        last_shadow = esv;
        _recent->_last_shadow = esv;
        _recent->_last_view = v;
      }
      return last_shadow;
    }

    inline
    gc_ptr<view>
    shadow_cache_lookup(const gc_ptr<iso_context> &c,
                        const gc_ptr<view> &v)
    {
      return shadow_cache::instance().lookup(c, v);
    }
    

  }
}



#endif /* CORE_CONTEXT_H_ */

