/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * core_strings.h
 *
 *  Created on: Oct 21, 2014
 *      Author: evank
 */

#ifndef CORE_STRINGS_H_
#define CORE_STRINGS_H_

#include <iterator>
#include "core/core_globals.h"
#include "mpgc/gc_cuckoo_map.h"
#include "ruts/uniform_key.h"

namespace mds {
  namespace core {
    /*
     * interned_string is an immutable string along with a uniform hash of its
     * contents.
     */
    struct interned_string : gc_allocated, ruts::with_uniform_id {
      using char_type = char16_t;
    private:
      using rep_type = gc_array<char_type>;
      gc_ptr<rep_type> _value;
    public:
      using traits_type = std::char_traits<char_type>;
      using value_type = char_type;
      using size_type = std::size_t;
      using difference_type = std::ptrdiff_t;
      using const_reference = typename rep_type::const_reference;
      using const_iterator = typename rep_type::const_iterator;
      using const_pointer = typename std::iterator_traits<const_iterator>::pointer;
      using const_reverse_iterator = typename rep_type::const_reverse_iterator;
      using reference = const_reference;
      using pointer = const_pointer;
      using iterator = const_iterator;
      using reverse_iterator = const_reverse_iterator;

      constexpr static size_type npos = std::numeric_limits<size_type>::max();

      template <typename Iter>
      interned_string(gc_token &gc, const uniform_key &k,const Iter &from, const Iter &to)
      : gc_allocated{gc}, ruts::with_uniform_id{k}, _value{make_gc_array<char_type>(from, to)}
      {}
      static const auto &descriptor() {
        static gc_descriptor d =
	  GC_DESC(interned_string)
	  .WITH_SUPER(with_uniform_id)
	  .WITH_FIELD(&interned_string::_value);
        return d;
      }
      const uniform_key &key() const {
        return id;
      }

      const_iterator cbegin() const {
        return _value.cbegin();
      }
      const_iterator begin() const {
        return cbegin();
      }
      const_iterator cend() const {
        return _value.cend();
      }
      const_iterator end() const {
        return cend();
      }
      const_reverse_iterator crbegin() const {
        return _value.crbegin();
      }
      const_reverse_iterator rbegin() const {
        return crbegin();
      }
      const_reverse_iterator crend() const {
        return _value.crend();
      }
      const_reverse_iterator rend() const {
        return crend();
      }

      const_reference at(size_type pos) const {
        return _value[pos];
      }

      const_reference operator[](size_type pos) const {
        return _value[pos];
      }

      bool empty() const {
        return _value.empty();
      }

      size_type size() const {
        return _value.size();
      }

      size_type capacity() const {
        return size();
      }


      const_reference front() const {
        return _value[0];
      }

      const_reference back() const {
        return _value[size()];
      }


    };

    template <typename Traits>
    class interned_string_table : public gc_allocated {
    public:
      using char_type = char16_t;

    private:
      using key_type = ruts::uniform_key;
    public:
      //    using string_type = typename keyed_string_type::string_type;

      using value_type = gc_ptr<interned_string>;
    private:
      template <typename Iter>
      static uniform_key compute_key(const Iter &from, const Iter &to) {
        std::pair<ruts::masher::accumulator_type, ruts::masher::accumulator_type>
          accums = uniform_key::accumulators();
        for (char16_t c : ruts::range_over(from,to)) {
          accums.first.add(c);
          accums.second.add(c);
        }
        return uniform_key{accums};
      }

      using map_type = gc_cuckoo_map<key_type, value_type, Traits>;
      const gc_ptr<map_type> _map;
      constexpr static const char_type *ncp_() {
        return nullptr;
      }
//      constexpr static char_type *ncp = nullptr;
      const value_type _empty_string = make_gc<interned_string>(compute_key(ncp_(), ncp_()), ncp_(), ncp_());

    public:
      interned_string_table(gc_token &gc, std::size_t default_cap)
    : gc_allocated{gc},
      _map{make_gc<map_type>(default_cap)}
    {}

    static const auto &descriptor() {
      static gc_descriptor d =
	GC_DESC(interned_string_table)
	.template WITH_FIELD(&interned_string_table::_map)
	.template WITH_FIELD(&interned_string_table::_empty_string);
      return d;
    }

    value_type empty_string() const {
      return _empty_string;
    }

    template <typename Iter>
    value_type intern(const Iter &from, const Iter &to) {
      using namespace mds;
      if (from == to) {
        return _empty_string;
      }
      /*
       * Whatever the iterator, we want to treat it as if it's pointing to a char16_t;
       */
      uniform_key key = compute_key(from, to);
      gc_ptr<interned_string> s = _map->get(key);
      if (s != nullptr) {
        return s;
      }
      s = make_gc<interned_string>(key, from, to);
      auto rr = _map->put_new(key, s);
      // if
      if (rr.had_value) {
        // Somebody else put it in while we were constructing it
        return rr.old_value;
      } else {
        return s;
      }
    }

    value_type intern(const char *chars, std::size_t len) {
      return chars == nullptr ? _empty_string : intern(chars, chars+len);
    }

    // This is assumed to be a literal string (with a null byte at the end)
    template <std::size_t N>
    value_type intern(const char (&chars)[N]) {
      return N==0 ? _empty_string : intern(chars, N-1);
    }

    value_type intern(const char16_t *chars, std::size_t len) {
      return chars == nullptr ? _empty_string : intern(chars, chars+len);
    }
    // This is assumed to be a literal string (with a null byte at the end)
    template <std::size_t N>
    value_type intern(const char16_t (&chars)[N]) {
      return N==0 ? _empty_string : intern(chars, N-1);
    }

    value_type intern(const wchar_t *chars, std::size_t len) {
      return chars==nullptr ? _empty_string : intern(chars, chars+len);
    }
    // This is assumed to be a literal string (with a null byte at the end)
    template <std::size_t N>
    value_type intern(const wchar_t (&chars)[N]) {
      return N==0 ? _empty_string : intern(chars, N-1);
    }

    template <typename C, typename T, typename A>
    value_type intern(const std::basic_string<C,T,A> &s) {
      return intern(s.begin(), s.end());
    }

    };

//    template <std::size_t S>
//    constexpr typename interned_string_table<S>::char_type *
//    interned_string_table<S>::ncp;


    template <typename Iter>
    inline gc_ptr<interned_string> intern(const Iter &from, const Iter &to) {
      return string_table->intern(from, to);
    }

    inline gc_ptr<interned_string> intern(const char *chars, std::size_t len) {
      return string_table->intern(chars, len);
    }

    // This is assumed to be a literal string (with a null byte at the end)
    template <std::size_t N>
    inline gc_ptr<interned_string> intern(const char (&chars)[N]) {
      return string_table->intern(chars);
    }

    inline gc_ptr<interned_string> intern(const char16_t *chars, std::size_t len) {
      return string_table->intern(chars, len);
    }
    // This is assumed to be a literal string (with a null byte at the end)
    template <std::size_t N>
    inline gc_ptr<interned_string> intern(const char16_t (&chars)[N]) {
      return string_table->intern(chars);
    }

    inline gc_ptr<interned_string> intern(const wchar_t *chars, std::size_t len) {
      return string_table->intern(chars, len);
    }
    // This is assumed to be a literal string (with a null byte at the end)
    template <std::size_t N>
    inline gc_ptr<interned_string> intern(const wchar_t (&chars)[N]) {
      return string_table->intern(chars);
    }

    template <typename C, typename T, typename A>
    inline gc_ptr<interned_string> intern(const std::basic_string<C,T,A> &s) {
      return string_table->intern(s.begin(), s.end());
    }

      template <typename C, typename T>
      std::basic_ostream<C, T> &
      operator <<(std::basic_ostream<C, T> &os, const gc_ptr<interned_string> &s) {
	if (s != nullptr) {
	  std::for_each(s->cbegin(), s->cend(), [&](interned_string::char_type c) {
	      os.put(c);
	    });
	} else {
	  os << "NULL";
	}

	return os;
      }

  }

}




#endif /* CORE_STRINGS_H_ */
