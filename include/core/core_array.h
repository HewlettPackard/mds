/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * core_array.h
 *
 * Created on: June 01, 2015
 *     Author: uversky
 */

#ifndef CORE_ARRAY_H_
#define CORE_ARRAY_H_

#include "core/core_fwd.h"
#include "core/core_type.h"
#include "core/core_msv.h"
#include "core/core_globals.h"
#include "core/core_strings.h"
#include "ruts/uniform_key.h"
#include "ruts/cas_loop.h"
#include "mpgc/gc.h"
#include <atomic>

namespace mds {
  namespace core {

    class array_type_base : public managed_type<kind::ARRAY>
    {
      public:
        const kind elmt_kind;
        array_type_base(gc_token &gc, kind k) : managed_type<kind::ARRAY>{gc}, elmt_kind{k} {}
                      
        static const auto &descriptor() {
          static gc_descriptor d =
	    GC_DESC(array_type_base)
	    .WITH_SUPER(managed_type<kind::ARRAY>)
	    .WITH_FIELD(&array_type_base::elmt_kind);
          return d;
        }

        template <kind K>
        gc_ptr<array_type<K>> downcast() {
          assert(elmt_kind == K);
          return std::static_pointer_cast<array_type<K>>(GC_THIS);
        }

        template <kind K>
        gc_ptr<const array_type<K>> downcast() const {
          assert(elmt_kind == K);
          return std::static_pointer_cast<const array_type<K>>(GC_THIS);
        }
    };

    template <kind K>
    class array_type : public array_type_base
    {
      using atomic_msv      = std::atomic<gc_ptr<msv<K>>>;
      using rep_type        = gc_array<atomic_msv>;
      using arg_type        = typename rep_type::arg_type;
      constexpr static bool 
        holds_direct_values = rep_type::holds_direct_values;
      using value_type      = typename rep_type::value_type;
      using difference_type = typename rep_type::difference_type;
 
      private:
        const gc_ptr<const kind_type<K>> ele_type;

        class private_ctor {};

      public:
        using size_type = typename rep_type::size_type;
        array_type(gc_token &gc,
                   const gc_ptr<const kind_type<K>> &et) :
                   
          array_type_base{gc, K},
          ele_type{et}
          {}

        static const auto &descriptor() {
          static gc_descriptor d =
	    GC_DESC(array_type)
	    .template WITH_SUPER(array_type_base)
	    .template WITH_FIELD(&array_type::ele_type);
          return d;
        }

        bool compare_types(const gc_ptr<const array_type> &other) const {
          /*
           * array types are only the same if their elements are of the same type
           *  and they have the same bounds.
           */
          return other == this
              || (other != nullptr && this->ele_type == other->ele_type);
        }

        gc_ptr<const kind_type<K>> element_type() const {
          return ele_type;
        }

        managed_value<managed_array<K>> create_array(const size_type s, const gc_ptr<iso_context> &ctxt) const;
    };


    // su - the tricky thing is that arrays only have one kind, kind::ARRAY.
    //      any time an array is used somewhere, e.g. msv<kind::ARRAY> or
    //      record_field<kind::ARRAY>, you're not actually going to know
    //      what kind the array's elements are.
    class managed_array_base : public managed_composite, public with_uniform_id
    {
      // su - an array has (at least) the kind of its elements and a size
      //        the kind is distinct from the type of the array - it's just
      //        an enumeration.
      public:
        // using index_type  = std::ptrdiff_t;
        using index_type  = array_index_type;
        const kind elmt_kind;

        managed_array_base(
          gc_token &gc,
          kind k
        ) :
        managed_composite{gc},
        elmt_kind{k}
        {}

        static const auto &descriptor() {
          static gc_descriptor d =
	    GC_DESC(managed_array_base)
	    .WITH_SUPER(managed_composite)
	    .WITH_SUPER(with_uniform_id)
	    .WITH_FIELD(&managed_array_base::elmt_kind);
          return d;
        }

        template <kind K>
        gc_ptr<managed_array<K>> downcast() {
          assert(elmt_kind == K);
          return std::static_pointer_cast<managed_array<K>>(GC_THIS);
        }

        template <kind K>
        gc_ptr<const managed_array<K>> downcast() const {
          assert(elmt_kind == K);
          return std::static_pointer_cast<const managed_array<K>>(GC_THIS);
        }
    };

    template <kind K>
    class managed_array : public managed_array_base
    {
      // su - the following aliases make finding e.g. the type of the index
      //      a matter of mirroring the types found in gc_array
      using atomic_msv  = std::atomic<gc_ptr<msv<K>>>;
      using rep_type    = gc_array<atomic_msv>;

      public:
        using size_type = typename rep_type::size_type;

        const gc_ptr<const array_type<K>> a_type;
        const size_type                   size;
      
      private:
        gc_ptr<rep_type>                  array_gc;

      public:
        managed_array(
          gc_token &gc,
          const gc_ptr<const array_type<K>> &at,
          const size_type s,
          gc_ptr<rep_type> &a
        ) : 
        managed_array_base{gc, K},
        a_type{at},
        size{s},
        array_gc{a}
        {}

        // su - descriptor allows gc to find fields it cares about
        static const auto &descriptor() {
          static gc_descriptor d =
	    GC_DESC(managed_array)
	    .template WITH_SUPER(managed_array_base)
            .template WITH_FIELD(&managed_array::a_type)
	    .template WITH_FIELD(&managed_array::size)
	    .template WITH_FIELD(&managed_array::array_gc);
          return d;
        }

        gc_ptr<msv<K>> lookup(index_type i, bool create_if_null = false) const;

        // su - need to have analogues of the record_field operations here.
        //      largely identical, except gc_ptrs to managed_records replaced with indexes

        kind_mv<K> read(index_type i,
                        const gc_ptr<branch> &b,
                        const gc_ptr<iso_context> &ctxt) const;
        kind_mv<K> read_frozen(index_type i,
                               const gc_ptr<branch> &b,
                               const gc_ptr<iso_context> &ctxt) const;
        bool has_value(index_type i,
                       const gc_ptr<branch> &b,
                       const gc_ptr<iso_context> &ctxt) const;
      kind_mv<K> modify(index_type i,
                    const gc_ptr<branch> &b,
                    const gc_ptr<iso_context> &ctxt,
                    modify_op op,
                    const kind_mv<K> &arg,
                    res_mode resolving = res_mode::non_resolving) const;
      kind_mv<K> write(index_type i,
                   const gc_ptr<branch> &b,
                   const gc_ptr<iso_context> &ctxt,
                   const kind_mv<K> &val,
                   res_mode resolving = res_mode::non_resolving) const 
        {
          return modify(i, b, ctxt, modify_op::set, val, resolving);
        }
        template <typename T = kind_mv<K>, 
                  typename = std::enable_if_t<std::is_arithmetic<T>::value>>
        kind_mv<K> add(index_type i,
                 const gc_ptr<branch> &b,
                 const gc_ptr<iso_context> &ctxt,
                 const kind_mv<K> &delta,
                 res_mode resolving = res_mode::non_resolving) const
        {
          return modify(i, b, ctxt, modify_op::add, delta, resolving);
        }
        template <typename T = kind_mv<K>,
                  typename = std::enable_if_t<std::is_arithmetic<T>::value>>
	  kind_mv<K> sub(index_type i,
                 const gc_ptr<branch> &b,
                 const gc_ptr<iso_context> &ctxt,
                 const kind_mv<K> &delta,
                 res_mode resolving = res_mode::non_resolving) const
        {
          return modify(i, b, ctxt, modify_op::sub, delta, resolving);
        }
        template <typename T = kind_mv<K>,
                  typename = std::enable_if_t<std::is_arithmetic<T>::value>>
	  kind_mv<K> mul(index_type i,
                 const gc_ptr<branch> &b,
                 const gc_ptr<iso_context> &ctxt,
                 const kind_mv<K> &delta,
                 res_mode resolving = res_mode::non_resolving) const
        {
          return modify(i, b, ctxt, modify_op::mul, delta, resolving);
        }
        template <typename T = kind_mv<K>,
                  typename = std::enable_if_t<std::is_arithmetic<T>::value>>
	  kind_mv<K> div(index_type i,
                 const gc_ptr<branch> &b,
                 const gc_ptr<iso_context> &ctxt,
                 const kind_mv<K> &delta,
                 res_mode resolving = res_mode::non_resolving) const
        {
          return modify(i, b, ctxt, modify_op::div, delta, resolving);
        }

      kind_mv<K> set_to_parent(index_type i,
                           const gc_ptr<branch> &b,
                           const gc_ptr<iso_context> &ctxt,
                           res_mode resolving = res_mode::non_resolving) const
        {
          return modify(i, b, ctxt, modify_op::parent_val, kind_mv<K>{}, resolving);
        }
      kind_mv<K> resolve_to_parent(index_type i,
                               const gc_ptr<branch> &b,
                               const gc_ptr<iso_context> &ctxt) const
        {
          return set_to_parent(i, b, ctxt, res_mode::resolving);
        }
      kind_mv<K> resolve_to_current(index_type i,
                                const gc_ptr<branch> &b,
                                const gc_ptr<iso_context> &ctxt) const
        {
          return modify(i, b, ctxt, modify_op::current_val, kind_mv<K>{}, res_mode::resolving);
        }
      kind_mv<K> roll_back(index_type i,
                       const gc_ptr<branch> &b,
                       const gc_ptr<iso_context> &ctxt,
                       res_mode resolving = res_mode::non_resolving) const
        {
          return modify(i, b, ctxt, modify_op::last_stable_val, kind_mv<K>{}, resolving);
        }
      kind_mv<K> resolve_by_rollback(index_type i,
                                 const gc_ptr<branch> &b,
                                 const gc_ptr<iso_context> &ctxt) const
        {
          return roll_back(i, b, ctxt, res_mode::resolving);
        }
    };

    template <kind K> inline
    managed_value<managed_array<K>>
    array_type<K>::create_array(const size_type s, const gc_ptr<iso_context> &ctxt) const
    {
      using atomic_msv  = std::atomic<gc_ptr<msv<K>>>;
      using rep_type    = gc_array<atomic_msv>;

      // create underlying gc_array
      gc_ptr<rep_type> array_gc = make_gc_array<atomic_msv>(s);

      gc_ptr<managed_array<K>> a = make_gc<managed_array<K>>(GC_THIS, s, array_gc);
      gc_ptr<branch> b = ctxt->shadow(top_level_branch);
      return managed_value<managed_array<K>>{a, b};
    }

    template <kind K> inline
    gc_ptr<msv<K>> 
    managed_array<K>::lookup(index_type i, bool create_if_null) const {
      atomic_msv &a = array_gc->at(i);
      gc_ptr<msv_base> vb = a.load();
      if (vb != nullptr) {
        return vb->downcast<K>();
      } else if (create_if_null) {
        /*
         * Need a non-const version of this in order to create the conflict generator.
         */
        managed_array *nc_this = const_cast<managed_array *>(this);
	auto cg = make_gc<typename array_elmt_conflict<K>::generator>(this_as_gc_ptr(nc_this), i);
        gc_ptr<msv<K>> new_msv = make_gc<msv<K>>(cg);
        auto rr = ruts::try_change_value(a, nullptr, new_msv);
        /*
         * If that didn't work, someone else got there first.
         */
        if (rr) {
          return new_msv;
        } else {
//          managed_space::destroy(new_msv);
          return rr.prior_value->template downcast<K>();
        }
      } else {
        return nullptr;
      }
    }

    // su - TODO - error handling / exceptions for the following
    template <kind K> inline
    kind_mv<K> 
    managed_array<K>::read(index_type i,
                           const gc_ptr<branch> &b,
                           const gc_ptr<iso_context> &ctxt) const {

      gc_ptr<msv<K>> val = lookup(i, false);
      if (val == nullptr) {
        return kind_mv<K>{};
      }

      gc_ptr<branch> sb = ctxt->shadow(b);
      return val->read(sb, ctxt);
    }
    
    template <kind K> inline
    kind_mv<K>
    managed_array<K>::read_frozen(index_type i,
                                  const gc_ptr<branch> &b,
                                  const gc_ptr<iso_context> &ctxt) const {
 
      gc_ptr<msv<K>> val = lookup(i, false);
      if (val == nullptr) {
        return kind_mv<K>{};
      }

      gc_ptr<branch> sb = ctxt->shadow(b);
      return val->read_frozen(sb, ctxt);
    }

    template <kind K> inline
    bool
    managed_array<K>::has_value(index_type i,
                                const gc_ptr<branch> &b,
                                const gc_ptr<iso_context> &ctxt) const {
 
      gc_ptr<msv<K>> val = lookup(i, false);
      if (val == nullptr) {
        return false;
      }

      gc_ptr<branch> sb = ctxt->shadow(b);
      return val->has_value(sb, ctxt);
    }

    template <kind K> inline
    kind_mv<K>
    managed_array<K>::modify(index_type i,
                             const gc_ptr<branch> &b,
                             const gc_ptr<iso_context> &ctxt,
                             modify_op op,
                             const kind_mv<K> &arg,
                             res_mode resolving) const {
 
      gc_ptr<msv<K>> val = lookup(i, true);
      gc_ptr<branch> sb = ctxt->shadow(b);
      return val->modify(sb, ctxt, op, resolving, arg);
    }

    template <kind K>
    gc_ptr<array_type<K>>
    managed_type<K>::in_array() const {
      gc_ptr<array_type<K>> at = _in_array_type;
      if (at != nullptr) {
	return at;
      }
      at = make_gc<array_type<K>>(downcast());
      auto clrv = ruts::try_change_value(_in_array_type, nullptr, at);
      return clrv.resulting_value();
    }
  }

}

#endif /* CORE_ARRAY_H_ */

// su - if you find yourself looking at an array_type_base and need to do a downcast
//      (do some behavior that is kind-dependent), can add extra methods to kind_dispatch
//      object in order to emulate dynamic dispatch
