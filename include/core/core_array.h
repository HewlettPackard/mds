/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * core_array.h
 *
 * Created on: June 01, 2015
 *     Author: uversky
 */

#ifndef CORE_ARRAY_H_
#define CORE_ARRAY_H_

#include "core/core_fwd.h"
#include "core/core_type.h"
#include "core/core_msv.h"
#include "core/core_globals.h"
#include "core/core_strings.h"
#include "ruts/uniform_key.h"
#include "ruts/cas_loop.h"
#include "mpgc/gc.h"
#include <atomic>

namespace mds {
  namespace core {

    class array_type_base : public managed_type<kind::ARRAY>
    {
      public:
        const kind elmt_kind;
        array_type_base(gc_token &gc, kind k) : managed_type<kind::ARRAY>{gc}, elmt_kind{k} {}
                      
        static const auto &descriptor() {
          static gc_descriptor d =
	    GC_DESC(array_type_base)
	    .WITH_SUPER(managed_type<kind::ARRAY>)
	    .WITH_FIELD(&array_type_base::elmt_kind);
          return d;
        }

        template <kind K>
        gc_ptr<array_type<K>> downcast() {
          assert(elmt_kind == K);
          return std::static_pointer_cast<array_type<K>>(GC_THIS);
        }

        template <kind K>
        gc_ptr<const array_type<K>> downcast() const {
          assert(elmt_kind == K);
          return std::static_pointer_cast<const array_type<K>>(GC_THIS);
        }
    };

    template <kind K>
    class array_type : public array_type_base
    {
      using atomic_msv      = std::atomic<gc_ptr<typed_msv<K>>>;
      using rep_type        = gc_array<atomic_msv>;
      using arg_type        = typename rep_type::arg_type;
      constexpr static bool 
        holds_direct_values = rep_type::holds_direct_values;
      using value_type      = typename rep_type::value_type;
      using difference_type = typename rep_type::difference_type;
 
      private:
        const gc_ptr<const kind_type<K>> ele_type;

        class private_ctor {};

      public:
        using size_type = typename rep_type::size_type;
        array_type(gc_token &gc,
                   const gc_ptr<const kind_type<K>> &et) :
                   
          array_type_base{gc, K},
          ele_type{et}
          {}

        static const auto &descriptor() {
          static gc_descriptor d =
	    GC_DESC(array_type)
	    .template WITH_SUPER(array_type_base)
	    .template WITH_FIELD(&array_type::ele_type);
          return d;
        }

        bool compare_types(const gc_ptr<const array_type> &other) const {
          /*
           * array types are only the same if their elements are of the same type
           *  and they have the same bounds.
           */
          return other == this
              || (other != nullptr && this->ele_type == other->ele_type);
        }

        gc_ptr<const kind_type<K>> element_type() const {
          return ele_type;
        }

        managed_value<managed_array<K>> create_array(const size_type s) const;
    };


    // su - the tricky thing is that arrays only have one kind, kind::ARRAY.
    //      any time an array is used somewhere, e.g. typed_msv<kind::ARRAY> or
    //      record_field<kind::ARRAY>, you're not actually going to know
    //      what kind the array's elements are.
    class managed_array_base : public managed_composite, public with_uniform_id
    {
      // su - an array has (at least) the kind of its elements and a size
      //        the kind is distinct from the type of the array - it's just
      //        an enumeration.
      public:
        // using index_type  = std::ptrdiff_t;
        using index_type  = array_index_type;
        const kind elmt_kind;

        managed_array_base(
          gc_token &gc,
          kind k
        ) :
        managed_composite{gc},
        elmt_kind{k}
        {}

        static const auto &descriptor() {
          static gc_descriptor d =
	    GC_DESC(managed_array_base)
	    .WITH_SUPER(managed_composite)
	    .WITH_SUPER(with_uniform_id)
	    .WITH_FIELD(&managed_array_base::elmt_kind);
          return d;
        }

        template <kind K>
        gc_ptr<managed_array<K>> downcast() {
          assert(elmt_kind == K);
          return std::static_pointer_cast<managed_array<K>>(GC_THIS);
        }

        template <kind K>
        gc_ptr<const managed_array<K>> downcast() const {
          assert(elmt_kind == K);
          return std::static_pointer_cast<const managed_array<K>>(GC_THIS);
        }
    };

    template <kind K>
    class managed_array : public managed_array_base
    {
      // su - the following aliases make finding e.g. the type of the index
      //      a matter of mirroring the types found in gc_array
      using atomic_msv  = std::atomic<gc_ptr<typed_msv<K>>>;
      using rep_type    = gc_array<atomic_msv>;

      public:
        using size_type = typename rep_type::size_type;

        const gc_ptr<const array_type<K>> a_type;
        const size_type                   size;
      
      private:
        gc_ptr<rep_type>                  array_gc;

      public:
        managed_array(
          gc_token &gc,
          const gc_ptr<const array_type<K>> &at,
          const size_type s,
          gc_ptr<rep_type> &a
        ) : 
        managed_array_base{gc, K},
        a_type{at},
        size{s},
        array_gc{a}
        {}

        // su - descriptor allows gc to find fields it cares about
        static const auto &descriptor() {
          static gc_descriptor d =
	    GC_DESC(managed_array)
	    .template WITH_SUPER(managed_array_base)
            .template WITH_FIELD(&managed_array::a_type)
	    .template WITH_FIELD(&managed_array::size)
	    .template WITH_FIELD(&managed_array::array_gc);
          return d;
        }

      template <typename Fn>
      gc_ptr<typed_msv<K>> lookup(index_type i, Fn&& create_if_null) const;

      kind_mv<K> free_read(index_type i, const gc_ptr<view> &v) const;
      kind_mv<K> frozen_read(index_type i, const gc_ptr<view> &v) const;
      bool has_value(index_type i, const gc_ptr<view> &v) const;
      kind_mv<K> modify(index_type i,
                        const gc_ptr<view> &v,
                        modify_op op,
                        const kind_mv<K> &arg,
                        ret_mode returning = ret_mode::resulting_val,
                        const gc_ptr<mod_condition<K>> &guard = nullptr) const;
      kind_mv<K> write(index_type i,
                       const gc_ptr<view> &v,
                       const kind_mv<K> &val,
                       ret_mode returning = ret_mode::resulting_val,
                       const gc_ptr<mod_condition<K>> &guard = nullptr) const
      {
        return modify(i, v, modify_op::set, val, returning, guard);
      }
      template <typename T = kind_mv<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value>>
	kind_mv<K> add(index_type i,
                       const gc_ptr<view> &v,
                       const kind_mv<K> &delta,
                       ret_mode returning = ret_mode::resulting_val,
                       const gc_ptr<mod_condition<K>> &guard = nullptr) const
      {
        return modify(i, v, modify_op::add, delta, returning, guard);
      }
      template <typename T = kind_mv<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value>>
	kind_mv<K> sub(index_type i,
                       const gc_ptr<view> &v,
                       const kind_mv<K> &delta,
                       ret_mode returning = ret_mode::resulting_val,
                       const gc_ptr<mod_condition<K>> &guard = nullptr) const
      {
        return modify(i, v, modify_op::sub, delta, returning, guard);
      }
      template <typename T = kind_mv<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value>>
	kind_mv<K> mul(index_type i,
                       const gc_ptr<view> &v,
                       const kind_mv<K> &delta,
                       ret_mode returning = ret_mode::resulting_val,
                       const gc_ptr<mod_condition<K>> &guard = nullptr) const
      {
        return modify(i, v, modify_op::mul, delta, returning, guard);
      }
      template <typename T = kind_mv<K>, typename = std::enable_if_t<std::is_arithmetic<T>::value>>
	kind_mv<K> div(index_type i,
                       const gc_ptr<view> &v,
                       const kind_mv<K> &delta,
                       ret_mode returning = ret_mode::resulting_val,
                       const gc_ptr<mod_condition<K>> &guard = nullptr) const
      {
        return modify(i, v, modify_op::div, delta, returning, guard);
      }

    };

    template <kind K> inline
    managed_value<managed_array<K>>
    array_type<K>::create_array(const size_type s) const
    {
      using atomic_msv  = std::atomic<gc_ptr<typed_msv<K>>>;
      using rep_type    = gc_array<atomic_msv>;

      // create underlying gc_array
      gc_ptr<rep_type> array_gc = make_gc_array<atomic_msv>(s);

      gc_ptr<managed_array<K>> a = make_gc<managed_array<K>>(GC_THIS, s, array_gc);
      gc_ptr<view> v = iso_context::shadowed(top_level_view);
      return managed_value<managed_array<K>>{a, v};
    }

    template <kind K> template <typename Fn> inline
    gc_ptr<typed_msv<K>> 
    managed_array<K>::lookup(index_type i, Fn &&create_if_null) const {
      atomic_msv &a = array_gc->at(i);
      gc_ptr<typed_msv<K>> vb = a.load();
      if (vb != nullptr) {
        return vb;
      } else if (std::forward<Fn>(create_if_null)()) {
        /*
         * Need a non-const version of this in order to create the conflict generator.
         */
        gc_ptr<typed_msv<K>> new_msv = make_gc<typed_msv<K>>();
        auto rr = ruts::try_change_value(a, nullptr, new_msv);
        /*
         * If that didn't work, someone else got there first.
         */
        return rr.resulting_value()->template downcast<K>();
      } else {
        return nullptr;
      }
    }

    // su - TODO - error handling / exceptions for the following
    template <kind K> inline
    kind_mv<K> 
    managed_array<K>::free_read(index_type i, const gc_ptr<view> &v) const {

      gc_ptr<typed_msv<K>> val = lookup(i, []{ return false; });
      if (val == nullptr) {
        return kind_mv<K>{};
      }

      gc_ptr<view> sv = iso_context::shadowed(v);
      return val->free_read(sv);
    }
    
    template <kind K> inline
    kind_mv<K>
    managed_array<K>::frozen_read(index_type i, const gc_ptr<view> &v) const {
 
      gc_ptr<view> sv = iso_context::shadowed(v);
      gc_ptr<typed_msv<K>> val = lookup(i, [&]{ return sv->need_msv_on_initial_read(); });
      if (val == nullptr) {
        return kind_mv<K>{};
      }

      return val->frozen_read(sv);
    }

    template <kind K> inline
    bool
    managed_array<K>::has_value(index_type i, const gc_ptr<view> &v) const {
 
      gc_ptr<typed_msv<K>> val = lookup(i, []{ return false; });
      if (val == nullptr) {
        return false;
      }

      gc_ptr<view> sv = iso_context::shadowed(v);
      return val->has_value(sv);
    }

    template <kind K> inline
    kind_mv<K>
    managed_array<K>::modify(index_type i,
                             const gc_ptr<view> &v,
                             modify_op op,
                             const kind_mv<K> &arg,
                             ret_mode returning,
                             const gc_ptr<mod_condition<K>> &guard) const
    {
      gc_ptr<typed_msv<K>> val = lookup(i, []{ return true; });
      gc_ptr<view> sv = iso_context::shadowed(v);
      return val->modify(sv, op, arg, returning, guard);
    }

    template <kind K>
    gc_ptr<array_type<K>>
    managed_type<K>::in_array() const {
      gc_ptr<array_type<K>> at = _in_array_type;
      if (at != nullptr) {
	return at;
      }
      at = make_gc<array_type<K>>(downcast());
      auto clrv = ruts::try_change_value(_in_array_type, nullptr, at);
      return clrv.resulting_value();
    }
  }

}

#endif /* CORE_ARRAY_H_ */

// su - if you find yourself looking at an array_type_base and need to do a downcast
//      (do some behavior that is kind-dependent), can add extra methods to kind_dispatch
//      object in order to emulate dynamic dispatch
