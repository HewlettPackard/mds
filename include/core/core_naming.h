/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * core_naming.h
 *
 *  Created on: Oct 22, 2014
 *      Author: evank
 */

#ifndef CORE_NAMING_H_
#define CORE_NAMING_H_

#include "core/core_msv.h"
#include "core/core_kind.h"
#include "core/core_globals.h"
#include "ruts/ms_forward.h"
#include "mpgc/gc_cuckoo_map.h"
#include <tuple>


namespace mds {
  namespace core {

    template <kind K> class ks_bound_val;

    struct bound_val : gc_allocated {
      kind _kind;
      /*
       * Throws incompatible_type_ex if wrong kind
       */
      template <kind K> kind_mv<K> value() const;
    protected:
      bound_val(gc_token &gc, kind k) : gc_allocated{gc}, _kind{k} {}
    public:
      static const auto &descriptor() {
        static gc_descriptor d =
	  GC_DESC(bound_val)
	  .WITH_FIELD(&bound_val::_kind);
        return d;
      }
    };

    template <kind K>
    struct ks_bound_val : public bound_val {
      kind_mv<K> _val;
      ks_bound_val(gc_token &gc, const kind_mv<K> &v) : bound_val{gc, K}, _val{v} {}
      static const auto &descriptor() {
        static gc_descriptor d =
	  GC_DESC(ks_bound_val)
	  .template WITH_SUPER(bound_val)
	  .template WITH_FIELD(&ks_bound_val::_val);
        return d;
      }
    };

    template <kind K>
    kind_mv<K>
    bound_val::value() const {
      if (_kind != K) {
        throw incompatible_type_ex{};
      }
      const ks_bound_val<K> *self = static_cast<const ks_bound_val<K>*>(this);
      return self->_val;
    }

    class binding {
      enum class state : char { UNBOUND, NAMESPACE, BOUND };
      state _state = state::UNBOUND;
      gc_ptr<bound_val> _val = nullptr;
    protected:
      constexpr static binding unbound() {
        return binding{state::UNBOUND};
      }
      constexpr static binding sub_namespace() {
        return binding{state::NAMESPACE};
      }
    public:
      static const auto &descriptor() {
        static gc_descriptor d =
	  GC_DESC(binding)
	  .template WITH_FIELD(&binding::_state)
	  .template WITH_FIELD(&binding::_val);
        return d;
      }
      explicit constexpr binding(state s = state::UNBOUND) : _state{s}, _val{nullptr} {}
      static constexpr binding for_namespace() {
        return binding{state::NAMESPACE};
      }
      template <kind K>
      static binding bound_to(const kind_mv<K> &val) {
        binding b{state::BOUND};
        b._val = make_gc<ks_bound_val<K>>(val);
        return b;
      }

      bool is_bound() const {
        return _state != state::UNBOUND;
      }
      bool is_namespace() const {
        return _state == state::NAMESPACE;
      }
      template <kind K>
      kind_mv<K>
      value() const {
        if (_state == state::UNBOUND) {
          throw unbound_name_ex{};
        }
        if (_state == state::NAMESPACE) {
          throw incompatible_type_ex{};
        }
        return _val->value<K>();
      }

    };

    class name_space : public exportable, public with_uniform_id {
      using msv_t = msv<kind::BINDING>;
      struct bound_name : gc_allocated {
        std::atomic<gc_ptr<name_space>>_sub_namespace{nullptr};
        gc_ptr<msv_t> _vals;

        bound_name(gc_token &gc, const gc_ptr<name_space> &ns, const gc_ptr<interned_string> &name)
	  : gc_allocated{gc},
	    _vals(make_gc<msv_t>(make_gc<bound_name_conflict::generator>(ns, name)))
        {}
        static const auto &descriptor() {
          static gc_descriptor d =
	    GC_DESC(bound_name)
	    .WITH_FIELD(&bound_name::_sub_namespace)
	    .WITH_FIELD(&bound_name::_vals);
          return d;
        }
        gc_ptr<name_space> sub_namespace() {
          gc_ptr<name_space> ns = _sub_namespace;
          if (ns != nullptr) {
            return ns;
          }
          ns = make_gc<name_space>();
          auto rr = ruts::try_change_value(_sub_namespace, nullptr, ns);
          return rr.resulting_value();
        }
      };
      using map_t = small_gc_cuckoo_map<gc_ptr<interned_string> , gc_ptr<bound_name>>;
      gc_ptr<map_t> _map;

      constexpr static std::size_t initial_map_size() {
	return 10;
      }

      using lookup_t = std::tuple<gc_ptr<bound_name>, binding>;
      lookup_t lookup(const gc_ptr<interned_string> &name, const gc_ptr<iso_context> &ctxt) const {
        gc_ptr<bound_name> bn = _map->get(name);
        if (bn == nullptr) {
          return lookup_t{nullptr, binding{}};
        }
        gc_ptr<branch> sb = ctxt->shadow(top_level_branch);
        binding b = bn->_vals->read(sb, ctxt);
        return lookup_t{bn, b};
      }

      lookup_t lookup_or_create(const gc_ptr<interned_string> &name, const gc_ptr<iso_context> &ctxt) {
        lookup_t res = lookup(name, ctxt);
        gc_ptr<bound_name> &bn = std::get<0>(res);
        if (bn != nullptr) {
          return res;
        }
        bn = make_gc<bound_name>(GC_THIS, name);
        _map->put_new(name, bn);
        return lookup(name, ctxt);
      }


    public:
      name_space(gc_token &gc) : exportable{gc}, _map{make_gc<map_t>(initial_map_size())} {}

      static const auto &descriptor() {
        static gc_descriptor d =
	  GC_DESC(name_space)
	  .WITH_SUPER(with_uniform_id)
	  .WITH_FIELD(&name_space::_map);
        return d;
      }
      /*
       * Throws incompatible_type_ex if the proffered type isn't a
       * superclass of the actual one
       * 
       * Throws unbound_name_ex if the name is unbound
       */
      template <kind K> kind_mv<K> read(const gc_ptr<interned_string> &name,
                                        const gc_ptr<iso_context> &ctxt) const {
        binding b;
        std::tie(std::ignore, b) = lookup(name, ctxt);
        /*
         * If there's no bound_name, the binding will be unbound
         */
        if (!b.is_bound()) {
          throw unbound_name_ex{};
        }
        if (b.is_namespace()) {
          throw incompatible_type_ex{};
        }
        return b.value<K>();
      }
      template <kind K> bool bind(const gc_ptr<interned_string> &name,
                                  const kind_mv<K> &val,
                                  const gc_ptr<iso_context> &ctxt,
                                  res_mode resolvep,
                                  bool replace_namespace) {
        gc_ptr<bound_name> bn;
        binding old_b;
        std::tie(bn, old_b) = lookup_or_create(name, ctxt);
        if (old_b.is_namespace() && !replace_namespace) {
          return false;
        }
        binding new_b = binding::bound_to<K>(val);
        gc_ptr<branch> sb = ctxt->shadow(top_level_branch);
        bn->_vals->write(sb, ctxt, resolvep, new_b);
        return true;
      }
      bool is_bound(const gc_ptr<interned_string> &name,
                    const gc_ptr<iso_context> &ctxt) const {
        binding b;
        std::tie(std::ignore, b) = lookup(name, ctxt);
        /*
         * If there's no bound_name, the binding will be unbound
         */
        return b.is_bound();
      }
      gc_ptr<name_space> child_namespace(const gc_ptr<interned_string> &name,
                                         const gc_ptr<iso_context> &ctxt,
                                         bool create_if_missing) {
        gc_ptr<bound_name> bn;
        binding b;
        std::tie(bn, b) = create_if_missing ? lookup_or_create(name, ctxt) : lookup(name, ctxt);
        if (bn == nullptr) {
          /*
           * This would only happen if we weren't asking to create it.
           */
          return nullptr;
        }
        if (b.is_bound()) {
//          std::cout << "Found " << ruts::to_utf8(name->as_string()) << std::endl;
          if (!b.is_namespace()) {
            throw incompatible_type_ex{};
          }
        } else if (!create_if_missing) {
          return nullptr;
        } else {
//          std::cout << "Creating " << ruts::to_utf8(name->as_string()) << std::endl;
          gc_ptr<branch> sb = ctxt->shadow(top_level_branch);
          bn->_vals->write(sb, ctxt, res_mode::non_resolving, binding::for_namespace());
        }
        return bn->sub_namespace();
      }


    };
  }
}



#endif /* CORE_NAMING_H_ */
