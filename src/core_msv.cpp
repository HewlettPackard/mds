/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * core_msv.cpp
 *
 *  Created on: Nov 13, 2014
 *      Author: evank
 */

#include "core/core_msv.h"
#include <vector>
#include <list>
#include <algorithm>
#include "mpgc/gc_vector.h"

namespace mds {
  namespace core {
    struct pending_rollup::process_state {
      struct time_marked {
        timestamp_t timestamp;
        gc_ptr<pending_rollup> rollup;

        time_marked(timestamp_t ts, const gc_ptr<pending_rollup> &pr)
          : timestamp{ts}, rollup{pr}
        {}

        bool operator <(const time_marked &rhs) const {
          return timestamp < rhs.timestamp;
        }
      }; // time_marked
      
      std::vector<time_marked> published;
      std::list<gc_ptr<pending_rollup>> unknown;
      external_gc_vector<gc_ptr<pending_rollup>> rollups_processed;
      /*
       * Everything in published or unknown is held by
       * rollups_processed, possibly through the next pointer.  So
       * we're never allowed to change a next pointer.  clear() is
       * called when we're done.
       */

      void clear() {
        published.clear();
        unknown.clear();
        rollups_processed.clear();
      }
      void add_to_unknown(const gc_ptr<pending_rollup> &pr) {
        unknown.push_back(pr);
      }
      void add_to_published(timestamp_t ts,
                            const gc_ptr<pending_rollup> &pr) {
        published.emplace_back(ts, pr);
      }
      void new_rollup(const gc_ptr<value_chain> &v,
                      const gc_ptr<const iso_context::published_state> &s) {
        gc_ptr<pending_rollup> pr = make_gc<pending_rollup>(v, s);
        rollups_processed.push_back(pr);
        pr->add_to_published(*this);
      }
      void process_new(const gc_ptr<pending_rollup> &from,
                       const gc_ptr<pending_rollup> &to)
      {
        for (gc_ptr<pending_rollup> pr = from;
             pr != nullptr && pr != to;
             pr=pr->next())
          {
            if (pr->triage(*this)) {
              return;
            }
          }
      }

      bool process_unknown() {
        bool any_moved = false;
        unknown.remove_if([&,this](const auto &pr) {
            return pr->triage_unknown(*this, any_moved);
          });
        return any_moved;
      }
      void process(gc_ptr<pending_rollup> prs,
                   std::atomic<gc_ptr<pending_rollup>> &msv_rollups);
    }; // process_state

    void pending_rollup::process_state::process(gc_ptr<pending_rollup> prs,
                                                std::atomic<gc_ptr<pending_rollup>> &msv_rollups)
    {
      /*
       * First, we process everything in the list
       */
      process_new(prs, nullptr);

      gc_ptr<pending_rollup> old_prs = prs;

      /*
       * We pretend we moved some from the unknown list to ensure that
       * we process the unknowns at least once.
       */
      bool moved_from_unknown = true;
      bool are_new = true;
      while (true) {
        gc_ptr<pending_rollup> new_prs = msv_rollups.load();
        if (new_prs == nullptr) {
          /*
           * If we read a null, that means that everything in our
           * vectors must have been taken care of, so we're done.
           */
          return;
        }
        are_new = new_prs != old_prs;
        if (!are_new && !moved_from_unknown) {
          /*
           * If there are no new ones and we didn't find any published
           * ones in our unknown list, all the remaining roll-ups in
           * the list will either fail or succeed later than all those
           * that are in the published vector and all that will be
           * added to the MSV.
           */
          break;
        }
        if (are_new) {
          rollups_processed.push_back(old_prs);
          process_new(new_prs, old_prs);
          old_prs = new_prs;
        }
        moved_from_unknown = process_unknown();
        if (!are_new && !moved_from_unknown) {
          /*
           * If there were no new ones when we last looked and we
           * didn't find any published ones in the unknown list, then
           * in addition to the prior condition, any rollups that have
           * been added to the MSV since we last looked will succeed
           * or fail after all those in the the published vector.
           */
          break;
        }
      }

      std::sort(published.begin(), published.end());
      std::for_each(published.begin(), published.end(),
                    [](const time_marked &tm) {
                      tm.rollup->do_rollup();
                    });
      if (unknown.empty()) {
        /*
         * If the unknown list is empty, everything we've seen has
         * been handled one way or another.  So the last one we
         * processed can be marked to be skipped.  (We could do
         * everything in rollups_processed, but that's probably
         * overkill.  Then we try to swing the MSV's rollups from that
         * pointer to null.  If we fail, that means that somebody else
         * added something afterwards, which is okay.
         */
        old_prs->mark_following_processed();
        msv_rollups.compare_exchange_strong(old_prs, nullptr);
        /*
         * If that fails, a rollup was added afterward, but it can't
         * affect this state.  We're good up to the last thing we
         * processed.
         */
      }
    }



    bool pending_rollup::triage(process_state &pstate) {
      if (processed()) {
        return following_processed();
      }
      switch (status()) {
      case status_t::Published:
        {
          add_to_published(pstate);
          break;
        }
      case status_t::Pending:
        pstate.add_to_unknown(GC_THIS);
        break;
      case status_t::Failed:
        break;
      }
      return false;
    }

    bool pending_rollup::triage_unknown(process_state &pstate, bool &moved) {
      if (processed()) {
        return true;
      }
      switch (status()) {
      case status_t::Published:
        {
          add_to_published(pstate);
          moved = true;
          return true;
        }
      case status_t::Pending:
        return false;
      case status_t::Failed:
      default:
        return true;
      }
    }

    void pending_rollup::add_to_published(process_state &pstate)
    {
      gc_ptr<value_chain> parent = _value_chains.lock_control();
      //      if (parent != nullptr && parent->is_publishable() && parent->is_closed()) {
      /*
       * If we lock to null, that means that there's no reason to roll up.
       */
      if (parent != nullptr) {
        /*
         * publish_time() requires that the pending state lock to
         * non-null.  If we're here, it's published and so lives as
         * long as the context, and if we locked the control (the
         * parent VC), then the source VC (the controlled pointer) is
         * still here, and it's holding onto the context.
         */
        const timestamp_t ts = publish_time();
        pstate.add_to_published(ts, GC_THIS);
        /*
         * If the parent VC is closed and was published after this one,
         * we need to create a new rollup and call it recursively.
         */
        //        gc_ptr<const iso_context::published_state>
        //          s = parent->get_view()->context->first_publish_after(ts);
        gc_ptr<const iso_context::published_state> s = parent->pub_state_after(ts);
        if (s != nullptr) {
          pstate.new_rollup(parent, s);
        }
      }
    }

    void pending_rollup::do_rollup()
    {
      if (processed()) {
        return;
      }
      gc_ptr<value_chain> vc = _value_chains.lock();
      if (vc != nullptr) {
        // assert(vc->get_context()->is_publishable());
        vc->do_rollup(publish_time());
      }
      mark_processed();
    }

    void pending_rollup::process(const gc_ptr<pending_rollup> &prs,
                                 std::atomic<gc_ptr<pending_rollup>> &msv_rollups)
    {
      static thread_local process_state pstate;

      pstate.process(prs, msv_rollups);
      pstate.clear();
    }
  }
}
