/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * core_context.cpp
 *
 *  Created on: Nov 13, 2014
 *      Author: evank
 */

#include "core/core_context.h"

namespace mds {
  namespace core {

    constexpr iso_context::global_context_t iso_context::global;

    gc_ptr<branch>
    iso_context::create_shadow(const gc_ptr<branch> &b) {
      /*
       * We actually branch off our parent's shadow branch, so we can
       * determine conflicts if somebody else merges back into our parent.
       */
      const gc_ptr<branch> &sbp = _parent.context == nullptr ? b : _parent.context->shadow(b);
      /*
       * Maybe we have a branch off that one, but we haven't yet noted
       * that it shadows the one we're looking for.
       */
      gc_ptr<branch> sb = (sbp == b) ? gc_ptr<branch>() :  (*_shadow_map)[sbp];
      if (sb == nullptr) {
        /*
         * No, we'll try to create one.
         */
//        bool delete_on_fail;
        if (_view_type == view_type::parent_view) {
          sb =  sbp == top_level_branch ? sbp : sbp->parent;
//          delete_on_fail = false;
        } else {
          sb = make_gc<branch>(GC_THIS, sbp);
//          delete_on_fail = true;
        }
        auto rr = _shadow_map->put_new(sbp, sb);
        if (rr.had_value) {
          /*
           * Somebody else beat us to it.  Delete the one we made
           * and use the one we found
           */
//          if (delete_on_fail) {
//            managed_space::destroy(sb);
//          }
          sb = rr.old_value;
        }
      }
      /*
       * Originally, I walked up the chain and cached at each level from sbp's parent
       * to b, but that actually winds up doing O(d^2) work for a context d below b's
       * context.  What we'll do instead is cache it at the bottom (so we try to do another
       * one) and at the top, so we find it quickly.  If we look for one in the middle, it'll
       * have the same shadow parent, so we'll find it above.  It may or may not already have
       * been cached.  If it has, it had better have the same value.
       */
      if (sbp != b) {
        auto rr = _shadow_map->put_new(b, sb);
        if (rr.had_value) {
          assert(rr.old_value == sb);
        }
      }
      return sb;
    }

  }
}
