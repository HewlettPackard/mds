/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * mds_common.h
 *
 *  Created on: Mar 13, 2015
 *      Author: evank
 */

#ifndef MDS_COMMON_H_
#define MDS_COMMON_H_

#include "mds_types.h"
#include "mds_core_api.h"

namespace mds {
  template <typename T, typename Enable = void>
  struct is_managed_type : std::false_type {};

  template <> struct is_managed_type<bool_t> : std::true_type{};
  template <> struct is_managed_type<byte_t> : std::true_type{};
  template <> struct is_managed_type<ubyte_t> : std::true_type{};
  template <> struct is_managed_type<short_t> : std::true_type{};
  template <> struct is_managed_type<ushort_t> : std::true_type{};
  template <> struct is_managed_type<int_t> : std::true_type{};
  template <> struct is_managed_type<uint_t> : std::true_type{};
  template <> struct is_managed_type<long_t> : std::true_type{};
  template <> struct is_managed_type<ulong_t> : std::true_type{};
  template <> struct is_managed_type<float_t> : std::true_type{};
  template <> struct is_managed_type<double_t> : std::true_type{};

  template <typename T> class mds_array;

  template <typename T, typename Enable = std::enable_if_t<is_managed_type<T>::value>>
  struct mds_traits {

  };

  using unbound_name_ex = api::unbound_name_ex;
  using incompatible_type_ex = api::incompatible_type_ex;

  using uniform_key = ruts::uniform_key;

  template <typename H>
  class __delegator {
  protected:
    using handle_type = H;
    handle_type _handle;
    __delegator(const handle_type &h) : _handle{h} {}
  public:
    __delegator() = default;
    __delegator(nullptr_t) {}
    handle_type handle() const {
      return _handle;
    }
    bool is_null() const {
      return _handle == nullptr;
    }
    bool operator ==(const __delegator &rhs) const {
      return _handle == rhs._handle;
    }
    bool operator !=(const __delegator &rhs) const {
      return _handle != rhs._handle;
    }
    bool operator ==(nullptr_t) const {
      return _handle == nullptr;
    }
    bool operator !=(nullptr_t) const {
      return _handle != nullptr;
    }
    std::size_t hash() const noexcept {
      return std::hash<handle_type>()(_handle);
    }
  };

  template <typename T>
  struct __intrinsic_hash {
    auto operator()(const T &val) const noexcept {
      return val.hash();
    }
  };

  template <typename H>
  class weak_handle {
    typename H::handle_type::weak_handle _wh;
  public:
    weak_handle() = default;
    weak_handle(const weak_handle &) = default;
    weak_handle(weak_handle&&) = default;
    weak_handle(const H &h) : _wh{h.handle()} {}
    weak_handle &operator=(const weak_handle &) = default;
    weak_handle &operator=(weak_handle &&) = default;
    weak_handle &operator=(const H &h) {
      _wh = h.handle();
      return *this;
    }
    H lock() const {
      return H(_wh.lock());
    }
  };

}

namespace std {
  template <typename H>
  struct hash<mds::__delegator<H>> : mds::__intrinsic_hash<mds::__delegator<H>> {};

  template <typename C, typename Tr, typename H>
  basic_ostream<C,Tr> &
  operator <<(basic_ostream<C,Tr> &os, const mds::__delegator<H> &h) {
    return os << h.handle();
  }
}



#endif /* MDS_COMMON_H_ */
