/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * iso_ctxt.h
 *
 *  Created on: Mar 16, 2015
 *      Author: evank
 */

#ifndef MDS_MEM_STATS_H_
#define MDS_MEM_STATS_H_

#include "mds_common.h"
#include <ostream>
#include <string>

namespace mds {
  namespace memory {
    constexpr static std::size_t DEFAULT_PRECISION = 2;
    constexpr static std::size_t K = 1024;
    constexpr static std::size_t M = 1024*K;
    constexpr static std::size_t G = 1024*M;
    constexpr static std::size_t T = 1024*G;

    static std::string readable(long size,
                                std::size_t decimal_places = 2,
                                const std::string &unit = "B")
    {
      if (size < 0) {
        return "-"+readable(-size, decimal_places, unit);
      }
      double val = size;
      std::string prefix;
      if (val >= T) {
        val /= T;
        prefix = "T";
      } else if (val >= G) {
        val /= G;
        prefix = "G";
      } else if (val >= M) {
        val /= M;
        prefix = "M";
      } else if (val >= K) {
        val /= K;
        prefix = "k";
      }
      return ruts::format([&](auto &os){
          os << std::setprecision(decimal_places)
             << std::fixed
             << val << " " << prefix << unit;
            
        });
    }
  }
  
  struct mem_stats {
    const std::size_t gc_cycle_number;
    const std::size_t bytes_in_heap;
    const std::size_t bytes_in_use;
    const std::size_t bytes_free;
    const std::size_t n_processes;
    const std::size_t n_objects;

  private:
    mem_stats()
      : gc_cycle_number{api::mem_stats::gc_cycle_number()},
        bytes_in_heap{api::mem_stats::bytes_in_heap()},
        bytes_in_use{api::mem_stats::bytes_in_use()},
        bytes_free{api::mem_stats::bytes_free()},
        n_processes{api::mem_stats::n_processes()},
        n_objects{api::mem_stats::n_objects()}
    {
    }

  public:

    mem_stats(const mem_stats &) = default;
    mem_stats(mem_stats &&) = default;

    std::string in_heap(std::size_t dp = 2) const {
      return memory::readable(bytes_in_heap, dp);
    }

    std::string in_use(std::size_t dp = 2) const {
      return memory::readable(bytes_in_use, dp);
    }

    std::string free(std::size_t dp = 2) const {
      return memory::readable(bytes_free, dp);
    }

    static mem_stats now() {
      while (true) {
        mem_stats m;
        if (m.gc_cycle_number == api::mem_stats::gc_cycle_number()) {
          return m;
        }
      }
    }
  };

  template <typename C, typename T>
  std::basic_ostream<C,T> &
  operator<<(std::basic_ostream<C,T> &s, const mem_stats &ms) {
    return s << "MemStats["
             << ms.gc_cycle_number << ": "
             << ms.in_use() << " used of " << ms.in_heap()
             << ", " << ruts::comma_sep(ms.n_objects)
             << " object" << (ms.n_objects!=1 ? "s" : "")
             << ", " << ruts::comma_sep(ms.n_processes)
             << " process" << (ms.n_processes!=1 ? "es" : "")
             << "]";
  }
}
#endif // MDS_MEM_STATS_H_  

