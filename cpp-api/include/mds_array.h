/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * managed_record.h
 *
 *  Created on: Aug 28, 2015
 *      Author: Evan
 */

#ifndef MDS_ARRAY_H_
#define MDS_ARRAY_H_

#include "mds_ptr.h"
#include "managed_type.h"
#include "ruts/util.h"

namespace mds {

  template <typename T> using mds_array_ptr = mds_ptr<mds_array<T>>;
  template <typename T> mds_array_ptr<T> new_array(std::size_t n);

  template <typename T>
  struct managed_type<mds_array<T>>
    : public managed_type_base__<api::kind::ARRAY, mds_array_ptr<T>>
  {
    using super = managed_type_base__<api::kind::ARRAY, mds_array_ptr<T>>;
    using typename super::mds_type;
    using const_mds_type = mds_ptr<const mds_array<T>>;
    using elt_type = managed_type<T>;
    using core_api_type = api::managed_array_handle<elt_type::kind>;
    using handle_type = api::array_type_handle<elt_type::kind>;

    static const handle_type &cached_handle() {
      static const handle_type h = elt_type().handle().pointer()->in_array();
      return h;
    }

    handle_type handle() const {
      return cached_handle();
    }

    mds_type from_core(const core_api_type &handle) const {
      auto sp = std::make_shared<mds_array<T>>(typename mds_array<T>::private_ctor{},
                                               handle);
      return mds_type::__from_shared(sp);
    }
    // /*
    //  * When we get the value from a field, we only get it as the base
    //  * array pointer, so we need to downcast.  This should be safe
    //  */
    // mds_type from_core(const typename super::core_api_type &handle) const {
    //   return from_core(static_cast<const core_api_type &>(handle));
    // }
    
    core_api_type to_core(const mds_type &p) const {
      return p == nullptr ? core_api_type{} : p->_handle;
    }
  };

  
  template <typename T>
  class mds_array : public std::enable_shared_from_this<mds_array<T>>
  {
  public:
    using elt_type = managed_type<T>;
    using value_type = typename elt_type::mds_type;
    using handle_type = api::managed_array_handle<elt_type::kind>;
    using std::enable_shared_from_this<mds_array<T>>::shared_from_this;
  private:
    class private_ctor {};
    friend mds_array_ptr<T> new_array<T>(std::size_t);
    friend managed_type<mds_array>;
    constexpr static std::size_t unset_size = ~0UL;
    
    const handle_type _handle;
    mutable std::size_t _size = unset_size;



    mds_array(const mds_array &) = delete;
    mds_array(mds_array &&) = delete;


    using core_api_type = typename elt_type::core_api_type;
    static value_type from_core(const core_api_type &val) {
      return elt_type().from_core(val);
    }

    static core_api_type to_core(const value_type &val) {
      return elt_type().to_core(val);
    }
    
  public:
    mds_array(private_ctor, const handle_type &h) : _handle{h} {}
    mds_array(private_ctor, handle_type &&h) : _handle{std::move(h)} {}
    mds_array(private_ctor, std::size_t n)
      : _handle{managed_type<mds_array>().handle().create_array(n)},
      _size{n}
    {}

    static mds_ptr<mds_array> create(std::size_t n) {
      return new_array<T>(n);
    }
    uniform_key uuid() const {
      return _handle.uuid();
    }
    std::size_t size() const {
      if (_size == unset_size) {
        _size = _handle.size();
      }
      return _size;
    }
    bool empty() const {
      return size() == 0;
    }

    bool operator ==(const mds_array &other) const {
      return _handle == other._handle;
    }

    bool operator !=(const mds_array &other) const {
      return _handle != other._handle;
    }



    class const_reference {
    protected:
      friend class mds_array;
      const handle_type _array_handle;
      std::size_t _offset;
      const_reference(const handle_type &h, std::size_t i)
        : _array_handle{h}, _offset{i}
      {}
    public:
      value_type read() const {
        return from_core(_array_handle.frozen_read(_offset));
      }
      value_type peek() const {
        return from_core(_array_handle.free_read(_offset));
      }

      operator value_type() const {
        return read();
      }

      template <typename RHS>
      bool operator ==(RHS&& rhs) const {
        return read() == std::forward<RHS>(rhs);
      }

      template <typename RHS>
      bool operator !=(RHS&& rhs) const {
	return read() != std::forward<RHS>(rhs);
      }

      template <typename V=value_type, typename RT=decltype(V{}.operator->())>
      auto operator->() const {
        return read();
      }
    };
    
    class reference : public const_reference {
      friend class mds_array;
      reference(const handle_type &h, std::size_t i)
        : const_reference{h, i}
      {}
      using const_reference::_array_handle;
      using const_reference::_offset;

    public:
      reference &operator =(const value_type &rhs)  {
	_array_handle.write(_offset, to_core(rhs));
	return *this;
      }
      reference &operator =(value_type &&rhs)  {
	_array_handle.write(_offset, to_core(std::move(rhs)));
	return *this;
      }

      template <typename T2>
      reference &operator =(const typename mds_array<T2>::const_reference &rhs) {
	return (*this) = static_cast<value_type>(rhs);
      }
      reference &operator =(const reference &rhs) {
	return (*this) = static_cast<value_type>(rhs);
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator +=(value_type rhs) {
	return from_core(_array_handle.add(_offset, to_core(rhs)));
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type fetch_addsub(value_type rhs)  {
	return from_core(_array_handle.add(_offset, to_core(rhs),
                                           api::ret_mode::prior_val));
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator ++() {
	return (*this) += 1;
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator ++(int) {
	return ++(*this) - 1;
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator -=(value_type rhs) {
	return from_core(_array_handle.sub(_offset, to_core(rhs)));
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type fetch_sub(value_type rhs)  {
	return from_core(_array_handle.sub(_offset, to_core(rhs),
                                           api::ret_mode::prior_val));
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator --() {
	return (*this) -= 1;
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator --(int) {
	return --(*this) + 1;
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator *=(value_type rhs) {
	return from_core(_array_handle.mul(_offset, to_core(rhs)));
      }
      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator /=(value_type rhs) {
	return from_core(_array_handle.div(_offset, to_core(rhs)));
      }
      value_type exchange(const value_type &rhs)  {
        return from_core(_array_handle.write(_offset,
                                             to_core(rhs),
                                             api::ret_mode::prior_val));
      }

    };

    reference at(std::size_t i) {
      return reference(_handle, i);
    }      
    
    const_reference at(std::size_t i) const {
      return reference(_handle, i);
    }      
    
    reference operator[](std::size_t i) {
      return at(i);
    }
    const_reference operator[](std::size_t i) const {
      return at(i);
    }



    class const_iterator {
    public:
      using difference_type = std::ptrdiff_t;
      using value_type = mds_array::value_type;
      using pointer = const_iterator;
      using reference = mds_array::const_reference;
      using iterator_category = std::random_access_iterator_tag;

    protected:
      friend class mds_array;
      mds_array::handle_type _array_handle;
      difference_type _offset;
      const_iterator(const mds_array::handle_type &h, difference_type i)
        : _array_handle{h}, _offset{i}
      {}
    public:
      const_iterator() = default;
      const_iterator(nullptr_t) : _array_handle{nullptr}, _offset{0} {}
      const_iterator(const const_iterator &other) = default;
      // const_iterator(const iterator &other)
      //   : _array_handle(other._array_handle), _offset(other._offset)
      // {}

      bool operator ==(const const_iterator &rhs) const {
        return (_array_handle == rhs._array_handle
                && _offset == rhs._offset);
      }
          
      bool operator !=(const const_iterator &rhs) const {
        return (_array_handle != rhs._array_handle
                || _offset != rhs._offset);
      }

      bool operator <(const const_iterator &rhs) const {
        if (_array_handle != rhs._array_handle) {
          return _array_handle.pointer() < rhs._array_handle.pointer();
        }
        return _offset < rhs._offset;
      }

      bool operator >(const const_iterator &rhs) const {
        if (_array_handle != rhs._array_handle) {
          return _array_handle.pointer() > rhs._array_handle.pointer();
        }
        return _offset > rhs._offset;
      }

      bool operator <=(const const_iterator &rhs) const {
        return !((*this) > rhs);
      }

      bool operator >=(const const_iterator &rhs) const {
        return !((*this) < rhs);
      }

      const_reference operator *() const {
        if (_offset < 0) {
          throw std::out_of_range{
            "Attempt to dereference before beginning of MDS array: "+ruts::to_string(_offset)
              };
        }
        return const_reference{_array_handle, static_cast<std::size_t>(_offset)};
      }
          

      const_iterator &operator+=(difference_type d) {
        _offset += d;
        return *this;
      }
      
      const_iterator &operator-=(difference_type d) {
        _offset -= d;
        return *this;
      }

      const_iterator operator +(difference_type d) const {
        const_iterator temp = *this;
        temp += d;
        return temp;
      }

      const_iterator &operator++() {
        _offset++;
        return *this;
      }

      const_iterator operator++(int) {
        const_iterator temp = *this;
        _offset++;
        return temp;
      }
      
      const_iterator &operator--() {
        _offset--;
        return *this;
      }

      const_iterator operator--(int) {
        const_iterator temp = *this;
        _offset--;
        return temp;
      }
      
      const_iterator operator -(difference_type d) const {
        const_iterator temp = *this;
        temp -= d;
        return temp;
      }

      difference_type operator -(const const_iterator &rhs) const {
        assert(_array_handle == rhs._array_handle);
        return _offset - rhs._offset;
      }

      const_reference operator[](difference_type n) const {
        return const_reference{_array_handle, _offset+n};
      }
      
    };

    class iterator : public const_iterator {
      friend class mds_array;
      iterator(const mds_array::handle_type &h,
               typename const_iterator::difference_type i)
        : const_iterator{h, i}
      {}
    public:
      using difference_type = typename const_iterator::difference_type;
      using value_type = mds_array::value_type;
      using pointer = iterator;
      using reference = mds_array::reference;
      using iterator_category = std::random_access_iterator_tag;
      using const_iterator::_array_handle;
      using const_iterator::_offset;
      iterator() = default;
      iterator(nullptr_t) : const_iterator{nullptr} {}
      iterator(const iterator &other) : const_iterator{other} {}

      reference operator *() const {
        if (_offset < 0) {
          throw std::out_of_range{
            "Attempt to dereference before beginning of MDS array: "+ruts::to_string(_offset)
              };
        }
        return reference{_array_handle, static_cast<std::size_t>(_offset)};
      }

      iterator &operator+=(difference_type d) {
        _offset += d;
        return *this;
      }
      
      iterator &operator-=(difference_type d) {
        _offset -= d;
        return *this;
      }

      iterator operator +(difference_type d) const {
        iterator temp = *this;
        temp += d;
        return temp;
      }

      iterator &operator++() {
        _offset++;
        return *this;
      }

      iterator operator++(int) {
        iterator temp = *this;
        _offset++;
        return temp;
      }
      
      iterator &operator--() {
        _offset--;
        return *this;
      }

      iterator operator--(int) {
        iterator temp = *this;
        _offset--;
        return temp;
      }
      
      using const_iterator::operator-;
      iterator operator -(difference_type d) const {
        iterator temp = *this;
        temp -= d;
        return temp;
      }

      reference operator[](difference_type n) const {
        return reference{_array_handle, _offset+n};
      }
    };

    const_iterator cbegin() const {
      return const_iterator{_handle, 0};
    }
    const_iterator begin() const {
      return cbegin();
    }
    const_iterator cend() const {
      return const_iterator(_handle,
                            static_cast<typename const_iterator::difference_type>(size()));
    }
    const_iterator end() const {
      return cend();
    }
    iterator begin() {
      return iterator{_handle, 0};
    }
    iterator end() {
      return iterator(_handle, static_cast<typename iterator::difference_type>(size()));
    }

    void fill(const value_type &v) {
      for (auto slot : *this) {
        slot = v;
      }
      // std::size_t n = size();
      // for (std::size_t i=0; i<n; i++) {
      //   at(i) = v;
      // }
    }

    mds_ptr<mds_array> as_mds_ptr() {
      return mds_ptr<mds_array>::__from_shared(shared_from_this());
    }
    mds_ptr<mds_array> as_mds_ptr() const {
      return mds_ptr<const mds_array>::__from_shared(shared_from_this());
    }
    

    template <typename First, typename...Cpts>
    void bind(First &&first, Cpts &&...cpts) const {
      mds_namespace::current()->at(std::forward<First>(first),
                                   std::forward<Cpts>(cpts)...)
        .template as<mds_array>().bind(as_mds_ptr());
    }
    

  };

  template <typename T>
  typename mds_array<T>::const_iterator
  operator +(typename mds_array<T>::const_iterator::difference_type n,
             const typename mds_array<T>::const_iterator i)
  {
    return i+n;
  }

  template <typename T>
  typename mds_array<T>::iterator
  operator +(typename mds_array<T>::const_iterator::difference_type n,
             const typename mds_array<T>::iterator i)
  {
    return i+n;
  }


  template <typename T>
  inline
  mds_array_ptr<T>
  new_array(std::size_t n) {
    ensure_thread_initialized();
    auto sp = std::make_shared<mds_array<T>>(typename mds_array<T>::private_ctor{}, n);
    return mds_array_ptr<T>::__from_shared(sp);
  }
    
  template <typename T, typename Iter>
  inline
  mds_array_ptr<T>
  new_array(Iter from, Iter to) {
    std::size_t n = std::distance(from, to);
    mds_array_ptr<T> array = new_array<T>(n);
    for (std::size_t i=0; i<n; i++) {
      array->at(i) = *from++;
    }
    return array;
  }
    
  // template <typename T>
  // inline
  // typename managed_type<mds_array<T>>::mds_type
  // managed_type<mds_array<T>>::from_core(const core_api_type &handle) const {
  //   auto sp = std::make_shared<mds_array<T>>(handle);
  //   return mds_type::__from_shared(sp);
  // }

  // template <typename T>
  // inline
  // typename managed_type<mds_array<T>>::core_api_type
  // managed_type<mds_array<T>>::from_core(const mds_type &p) const {
  //   return p == nullptr ? core_api_type{} : p->handle;
  // }

}

#endif /* MDS_ARRAY_H_ */
