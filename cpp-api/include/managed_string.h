/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * managed_string.h
 *
 *  Created on: Mar 13, 2015
 *      Author: evank
 */

#ifndef MANAGED_STRING_H_
#define MANAGED_STRING_H_

#include "mds_common.h"
#include "managed_type.h"
#include <iostream>
#include <algorithm>
#include <locale>
#include <iostream>
#include "ruts/null_terminated.h"

namespace mds {
  template <typename T> struct is_char_type : std::false_type {};
  template <> struct is_char_type<char> : std::true_type {};
  template <> struct is_char_type<char16_t> : std::true_type {};
  template <> struct is_char_type<wchar_t> : std::true_type {};

  class mds_string {
    friend class managed_type<mds_string>;
    using handle_type = api::managed_string_handle;
    handle_type _handle;
    explicit mds_string(const handle_type &h) : _handle{h} {}
  public:
    using char_type = handle_type::char_type;
    using size_t = std::size_t;

    using traits_type = std::char_traits<char_type>;
    using value_type = typename traits_type::char_type;
    using size_type = handle_type::size_type;
    using difference_type = handle_type::difference_type;
    using const_iterator = handle_type::const_iterator;
    using const_reverse_iterator = handle_type::const_reverse_iterator;
    using const_reference = handle_type::const_reference;
    using const_pointer = handle_type::const_pointer;

    constexpr static size_type npos = -1;

    constexpr explicit mds_string(nullptr_t np = nullptr) {}
    mds_string(const mds_string &) = default;
    mds_string(mds_string &&) = default;

    template <typename Iter>
    mds_string(const Iter &from, const Iter &to)
    : mds_string{from==to ? handle_type{} : api::intern(from, to)} {}

    template <typename T, typename = std::enable_if_t<is_char_type<T>::value> >
    mds_string(const T *chars, size_t len)
    : mds_string{(chars == nullptr || len == 0) ? handle_type{} : api::intern(chars, len)} {}

    class null_terminated_t {};
    static constexpr null_terminated_t null_terminated = null_terminated_t{}; 

    template <typename T, typename = std::enable_if_t<is_char_type<T>::value> >
    mds_string(const T *chars, null_terminated_t)
    : mds_string{(chars == nullptr || *chars == T{}) ?
        handle_type{} :
        api::intern(ruts::null_terminated<const T *>(chars),
                    ruts::null_terminated<const T *>::end())}
    {}

    // This is assumed to be a null-terminated literal
    template <typename T, size_t N, typename = std::enable_if_t<is_char_type<T>::value> >
    mds_string(const T (&chars)[N])
    : mds_string{N==1 ? handle_type{} : api::intern(chars)} {}

    template <typename C, typename T, typename A>
    mds_string(const std::basic_string<C,T,A> &s)
    : mds_string{s.empty() ? handle_type{} : api::intern(s)} {}

    mds_string &operator =(const mds_string &) = default;
    mds_string &operator =(mds_string &&) = default;
    mds_string &operator =(nullptr_t) {
      _handle = handle_type{};
      return *this;
    }

    template <typename T, size_t N, typename = std::enable_if_t<is_char_type<T>::value> >
    mds_string &operator =(const char (&rhs)[N]) {
      return (*this) = mds_string{rhs};
    }
    template <typename C, typename T, typename A>
    mds_string &operator =(const std::basic_string<C,T,A> &rhs) {
      return (*this) = mds_string{rhs};
    }

    bool empty() const {
      return _handle.is_null();
    }

    bool operator ==(const mds_string &other) const {
      return _handle == other._handle;
    }
    bool operator ==(nullptr_t) const {
      return _handle == nullptr;
    }
    template <typename RHS>
    bool operator ==(const RHS &rhs) const {
      return compare(rhs) == 0;
    }
    bool operator !=(const mds_string &rhs) const {
      return _handle != rhs._handle;
    }
    template <typename RHS>
    bool operator !=(const RHS &rhs) const {
      return !operator ==(rhs);
    }
    template <typename RHS>
    bool operator <(const RHS &rhs) const {
      return compare(rhs) < 0;
    }
    template <typename RHS>
    bool operator >=(const RHS &rhs) const {
      return !operator <(rhs);
    }
    template <typename RHS>
    bool operator >(const RHS &rhs) const {
      return compare(rhs) > 0;
    }
    template <typename RHS>
    bool operator <=(const RHS &rhs) const {
      return !operator >(rhs);
    }

    size_type size() const {
      return empty() ? 0 : _handle.size();
    }
    size_type length() const {
      return empty() ? 0 : _handle.length();
    }

    char_type operator[](size_t i) const {
      return _handle[i];
    }

    char_type at(size_t i) const {
      if (empty()) {
        throw std::out_of_range{"Attempted dereference of empty string"};
      }
      return _handle.at(i);
    }

    const_iterator begin() const {
      return _handle.begin();
    }
    const_iterator cbegin() const {
      return begin();
    }
    const_iterator end() const {
      return _handle.end();
    }
    const_iterator cend() const {
      return end();
    }
    std::string utf8_copy() const {
      return empty() ? std::string() : _handle.utf8();
    }

    handle_type handle() const {
      return _handle;
    }

    char_type front() const {
      return at(0);
    }

    char_type back() const {
      return at(length()-1);
    }


    constexpr static int case_sensitive(char_type a, char_type b) {
      return a-b;
    }
    constexpr static int case_insensitive(char_type a, char_type b) {
      return case_sensitive(std::towlower(a), std::towlower(b));
    }

    template <typename CMP, typename Iter>
    int compare_using(const CMP &cmp,
                      size_type pos, size_type count,
                      const Iter &from, const Iter &to) const {
      Iter p = from;
      const_iterator q = cbegin()+pos;
      const const_iterator qend = count == npos ? cend() : q+count;
      for (; ; q++, p++) {
        if (p == to) {
          return q==qend ? 0 : 1;
        } else if (q == qend) {
          return -1;
        }
        auto mine = *q;
        auto theirs = *p;
        int v = cmp(mine, theirs);
//        std::wcout << "  " << mine << " <=> " << theirs << " : " << v << std::endl;
        if (v != 0) {
          return v;
        }
      }
    }

    template <typename CMP>
    int compare_using(const CMP &cmp,
                      size_type pos1, size_type count1,
                      const mds_string &str,
                      size_type pos2=0, size_type count2 = npos) const {
      if ((*this) == str && pos1==pos2 && count1==count2) {
        return 0;
      }
      auto from = str.cbegin()+pos2;
      auto to = count2==npos ? str.cend() : from+count2;
      return compare_using(cmp, pos1, count1, from, to);
    }
    template <typename CMP, typename C, typename T, typename A>
    int compare_using(const CMP &cmp, size_type pos1, size_type count1,
                      const std::basic_string<C,T,A> &str,
                      typename std::basic_string<C,T,A>::size_type pos2=0,
                      typename std::basic_string<C,T,A>::size_type count2 = std::basic_string<C,T,A>::npos) const {
      auto from = str.cbegin()+pos2;
      auto to = count2==std::basic_string<C,T,A>::npos ? str.cend() : from+count2;
      return compare_using(cmp, pos1, count1, from, to);
    }
    /*
     * Omitting, because this becomes ambiguous with the const T* one
    template <typename CMP, typename T, size_t N, typename = std::enable_if_t<is_char_type<T>::value> >
    int compare_using(const CMP &cmp, size_type pos1, size_type count1,
                      const T (&str)[N],
                      size_t pos2, size_t count2) const {
      return compare_using(cmp, pos1, count1, str+pos2, str+count2);
    }
    template <typename CMP, typename T, size_t N, typename = std::enable_if_t<is_char_type<T>::value> >
    int compare_using(const CMP &cmp, size_type pos1, size_type count1,
                      const T (&str)[N],
                      size_t pos2=0) const {
      // -1 because N includes the (assumed) trailing null.
      return compare_using(cmp, pos1, count1, str, pos2, N-pos2-1);
    }
    */
    template <typename CMP, typename T, typename = std::enable_if_t<is_char_type<T>::value> >
    int compare_using(const CMP &cmp, size_type pos1, size_type count1,
                      const T *str, size_t count2) const {
      return compare_using(cmp, pos1, count1, str, str+count2);
    }
    template <typename CMP, typename T, typename = std::enable_if_t<is_char_type<T>::value> >
    int compare_using(const CMP &cmp, size_type pos1, size_type count1,
                      const T *str) const {
      using nti = ruts::null_terminated<const T *>;
      return compare_using(cmp, pos1, count1, nti{str}, nti::end());
    }

    /*
     * If there are two or three params or the 2nd and 3rd can't be position and count, then we
     * add position and count params.
     */

    template <typename CMP, typename A>
    int compare_using(const CMP &cmp, A&&a) const {
      return compare_using(cmp, 0, npos, std::forward<A>(a));
    }
    template <typename CMP, typename A, typename B>
    int compare_using(const CMP &cmp, A&& a, B&& b) const {
      return compare_using(cmp, 0, npos, std::forward<A>(a), std::forward<B>(b));
    }
    template <typename CMP, typename A, typename B, typename C, typename...Args,
    typename = std::enable_if_t<!(std::is_assignable<size_type&, A>::value
        && std::is_assignable<size_type&, B>::value)> >
    int compare_using(const CMP &cmp, A&& a, B&& b, C&& c, Args &&...args) const {
      return compare_using(cmp, 0, npos,
                           std::forward<A>(a),
                           std::forward<B>(b),
                           std::forward<C>(c),
                           std::forward<Args>(args)...);
    }

    template <typename...Args>
    int compare(Args&&... args) const {
      return compare_using(case_sensitive, std::forward<Args>(args)...);
    }

    mds_string substr(size_type pos = 0, size_type count = npos) const {
      if (pos > size()) {
        throw std::out_of_range("mds_string::substr: pos > size()");
      }
      const const_iterator from = cbegin()+pos;
      const const_iterator to = (count == npos || count+pos > size()) ? cend() : from+count;
      return mds_string(from, to);
    }

    template <typename CMP>
    size_type find_using(const CMP &cmp, char_type ch, size_type pos = 0) const {
      size_type s = size();
      for (; pos <= s; pos++) {
        if (cmp((*this)[pos], ch) == 0) {
          return pos;
        }
      }
      return npos;
    }

    template <typename CMP, typename Iter>
    size_type find_(const CMP &cmp, size_type pos, const Iter &from, size_type count) const {
      if (count == 0) {
        return pos;
      }
      const_iterator p = std::search(cbegin(), cend(), from, from+count,
                                     [&](auto a, auto b){return cmp(a,b) == 0;});
      return p == cend() ? npos : p-cbegin();
      /*
      const size_type sz = size();
      if (pos+count > sz) {
        return npos;
      }
      const char_type first_char = *from;
      const size_type last = sz-count;
      for (pos = find(first_char, pos);
          pos != npos && pos <= last;
          pos = find(first_char, pos+1))
      {
        const_iterator p = cbegin()+pos;
        if (std::equal(p, p+count, from)) {
          return pos;
        }
      }
      return npos;
      */
    }

    template <typename CMP>
    size_type find_using(const CMP &cmp, const mds_string &str, size_type pos = 0) const {
      return find_(cmp, pos, str.cbegin(), str.size());
    }

    template <typename CMP, typename C, typename T, typename A>
    size_type find_using(const CMP &cmp, const std::basic_string<C,T,A> &str, size_type pos = 0) const {
      return find_(cmp, pos, str.cbegin(), str.size());
    }

    template <typename CMP, typename T, typename = std::enable_if_t<is_char_type<T>::value> >
    size_type find_using(const CMP &cmp, const T *str, size_type pos, size_type count) const {
      return find_(cmp, pos, str, count);
    }
    template <typename CMP, typename T, typename = std::enable_if_t<is_char_type<T>::value> >
    size_type find_using(const CMP &cmp, const T *str, size_type pos = 0) const {
      const T *bound = str+size()-pos;
      const T *end = std::find(str, bound, T(0));
      if (end == bound) {
        // There were no nulls in a string that's no longer than us, so
        // the find couldn't work anyway.
        return npos;
      }
      return find_(cmp, pos, str, end-str);
    }

    template <typename A, typename...Args>
    size_type find(A&& first, Args&&...rest) const {
      return find_using(case_sensitive, std::forward<A>(first), std::forward<Args>(rest)...);
    }

    template <typename Iter>
    size_type copy(Iter dest, size_type count, size_type pos = 0) const {
      const size_type sz = size();
      if (pos > sz) {
        throw std::out_of_range("mds_string::copy: pos > size()");
      }
      if (count == npos || pos+count > sz) {
        count = sz-pos;
      }
      const const_iterator from = cbegin()+pos;
      const const_iterator to = from+count;
      Iter after = std::copy(from, to, dest);
      return count;
    }

    void swap(mds_string &other) {
      _handle.swap(other._handle);
    }

    std::uint64_t hash1() const {
      return _handle.hash1();
    }
    std::uint64_t hash2() const {
      return _handle.hash2();
    }




    // TODO: add rfind(), find_first/last_[not_]of()
    // TODO: add operator +
  };

  template <typename C, typename T>
  std::basic_ostream<C, T> &
  operator <<(std::basic_ostream<C, T> &os, const mds_string &s) {
    std::for_each(s.cbegin(), s.cend(), [&](mds_string::char_type c) {
      os.put(c);
    });
    return os;
  }

  /*
   * With these swapping comparisons here, if mds_string has an
   * implicit conversion from nullptr, GCC says "C++ says that these
   * are ambiguous, even though the worst conversion for the first is
   * better than the worst conversion for the second"
   */

  template <typename LHS>
  inline
  bool operator ==(const LHS &lhs, const mds_string &rhs) {
    return rhs == lhs;
  }
  template <typename LHS>
  inline
  bool operator !=(const LHS &lhs, const mds_string &rhs) {
    return rhs != lhs;
  }
  template <typename LHS>
  inline
  bool operator <(const LHS &lhs, const mds_string &rhs) {
    return rhs >= lhs;
  }
  template <typename LHS>
  inline
  bool operator >=(const LHS &lhs, const mds_string &rhs) {
    return rhs < lhs;
  }
  template <typename LHS>
  inline
  bool operator >(const LHS &lhs, const mds_string &rhs) {
    return rhs <= lhs;
  }
  template <typename LHS>
  inline
  bool operator <=(const LHS &lhs, const mds_string &rhs) {
    return rhs > lhs;
  }



  template <> struct is_managed_type<mds_string> : std::true_type{};
  template <> class managed_type<mds_string> : public managed_type_base__<api::kind::STRING, mds_string>
  {
    using base = managed_type_base__<api::kind::STRING, mds_string>;

    using typename base::handle_type;
    static const handle_type &cached_handle() {
      static handle_type h{api::managed_string_type_handle()};
      return h;
    }
  public:
    const handle_type &handle() const {
      return cached_handle();
    }
    mds_string from_core(const mds_string::handle_type &h) const {
      return mds_string{h};
    }
    mds_string::handle_type to_core(const mds_string &s) const {
      return s.handle();
    }
  };
  using mds_string_type = managed_type<mds_string>;



}

namespace ruts {
  template<> struct hash1<mds::mds_string> : intrinsic_hash1<mds::mds_string> {};
  template<> struct hash2<mds::mds_string> : intrinsic_hash2<mds::mds_string> {};
}  

namespace std {
  inline
  void swap(mds::mds_string &a, mds::mds_string &b) {
    a.swap(b);
  }

  template <> struct hash<mds::mds_string> : ruts::delegate_hash<mds::mds_string> {};

}



#endif /* MANAGED_STRING_H_ */
