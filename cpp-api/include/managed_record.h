/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * managed_record.h
 *
 *  Created on: Aug 28, 2015
 *      Author: Evan
 */

#ifndef MANAGED_RECORD_H_
#define MANAGED_RECORD_H_

#include <string>
#include <vector>
#include "mds_ptr.h"
#include "managed_type.h"
#include "managed_string.h"
#include "mds_array.h"
#include "iso_ctxt.h"
#include <unordered_map>
#include <mutex>

namespace mds {
  class mds_record;
  template <typename R, typename T> class record_field;
  template <typename R, typename T, record_field<R,T> &(*Field)()> class record_member;
  template <typename R, typename T, record_field<R,T> &(*Field)()> class record_const_member;

  template <typename B, typename D> using enable_if_base = std::enable_if_t<std::is_base_of<B,D>::value>;

  template <typename T, typename=void>
  struct is_record_type : std::false_type {};
  template <typename T>
      struct is_record_type<T,enable_if_base<mds_record, T>> : std::true_type {};

  template <typename T> using exists_if_record = meta::exists_if<is_record_type<T>::value>;
  template <typename T> using enable_if_record = std::enable_if_t<is_record_type<T>::value>;

  class record_field_base__ {
  public:
    virtual void declare(const mds_string &name, const api::record_type_handle h) = 0;
    virtual void ensure_type() const = 0;
  protected:
    virtual ~record_field_base__() {}
  };

  // template <typename R>
  // struct is_mds_ptr_target<R, std::enable_if_t<std::is_base_of<mds_record, std::decay_t<R> >::value>>
  //   : std::true_type
  // {};
  
  template <typename R>
  struct is_managed_type<R, std::enable_if_t<is_record_type<std::decay_t<R> >::value> >
    : std::true_type{};

  /*
   * Note that this only works for single inheritance.  For multiple
   * inheritance, we'd have multiple handles created and multiple
   * enable_shared_from_this bases (and who knows what that would do).
   * The latter can be solved with a virtual base, but that would
   * require a vft for all record classes.  The former could probably
   * be solved by caching in the token.  (You'd still get multiple
   * handles, but they'd all be the same.)
   *
   * TODO: Support multiple inheritence.
   */

  class mds_record : public std::enable_shared_from_this<mds_record> {
  public:
    using handle_type = api::managed_record_handle;
  private:
    const handle_type _handle;
    template <typename R, typename T> friend class record_field;
    template <typename R, typename T, record_field<R,T> &(*Field)()>
    friend class record_member;
    template <typename R, typename T, record_field<R,T> &(*Field)()>
    friend class record_const_member;
    template <typename R, typename E> friend class managed_type;

  protected:
    struct rc_token {
    protected:
      friend class mds_record;
      mutable std::shared_ptr<mds_record> _shared_ptr;
      virtual ~rc_token() {
        recent_stack().pop();
      }
      virtual handle_type create() const = 0;
      /*
       * If we create the initial shared ptr as a
       * shared_ptr<mds_record>, then when the last shared_ptr
       * goes away and the mds_record is destroyed, if there were
       * virtual functions added below, the wrong pointer to the
       * memory will be wrong.  So we indirect through the rc_token,
       * which knows the type to create the pointer to cache.
       */
      virtual void cache_shared(mds_record *) const = 0;
      rc_token() {
        recent_stack().push(nullptr);
      }

      static std::stack<mds_record *> &recent_stack() {
        static thread_local std::stack<mds_record *> s;
        return s;
      }
      
    };
    mds_record(const rc_token &tok, const handle_type &h)
      : _handle{h}
    {
      tok.cache_shared(this);
    }
    mds_record(const rc_token &tok, handle_type &&h)
      : _handle{std::move(h)}
    {
      tok.cache_shared(this);
    }

    explicit mds_record(const rc_token &tok)
      : _handle(tok.create())
      {
	/*
	 * By creating and caching a shared ptr, we make it possible
	 * for user ctors to call this_as_mds_ptr(), which requires
	 * shared_from_this(), which requires there to be an active
	 * shared pointer.
	 */
	tok.cache_shared(this);
      }
    template <typename R>
    mds_ptr<R> this_as_mds_ptr(R *rec) const {
      using namespace std;
      auto sp = static_pointer_cast<R>(rec->shared_from_this());
      return mds_ptr<R>::__from_shared(sp);
    }
    template <typename R>
    mds_ptr<const R> this_as_mds_ptr(const R *rec) const {
      using namespace std;
      auto sp = static_pointer_cast<const R>(rec->shared_from_this());
      return mds_ptr<const R>::__from_shared(sp);
    }
#define THIS_RECORD this_as_mds_ptr(this)    
  public:
    bool operator==(const mds_record &rhs) const {
      return _handle == rhs._handle;
    }
    bool operator!=(const mds_record &rhs) const {
      return _handle != rhs._handle;
    }

    uniform_key uuid() const {
      return _handle.uuid();
    }

    template <typename R>
    static void force() {
      static_assert(is_record_type<R>::value,
		    "mds_record::force<R> called on non-record class");
      managed_type<R>::ensure_complete();
    }

    template <typename First, typename Second, typename...Rest>
    static void force() {
      force<First>();
      force<Second, Rest...>();
    }

    template <typename First, typename...Cpts>
    void bind_in(const mds_ptr<mds_namespace> &ns, First &&first, Cpts &&...cpts) const {
      ns->at(std::forward<First>(first), std::forward<Cpts>(cpts)...)
        .template as<mds_record>().bind(THIS_RECORD);
    }

    template <typename First, typename...Cpts>
    void bind_to_name(First &&first, Cpts &&...cpts) const {
      bind_in(mds_namespace::current(),
              std::forward<First>(first),
              std::forward<Cpts>(cpts)...);
    }

  };

  inline bool operator<(const mds_ptr<mds_record> &lhs, const mds_ptr<mds_record> &rhs) {
    return lhs==nullptr ? rhs!=nullptr : lhs->uuid() < rhs->uuid();
  }
  inline bool operator>(const mds_ptr<mds_record> &lhs, const mds_ptr<mds_record> &rhs) {
    return rhs==nullptr ? lhs!=nullptr : lhs->uuid() > rhs->uuid();
  }
  inline bool operator<=(const mds_ptr<mds_record> &lhs, const mds_ptr<mds_record> &rhs) {
    return !(lhs > rhs);
  }
  inline bool operator>=(const mds_ptr<mds_record> &lhs, const mds_ptr<mds_record> &rhs) {
    return !(lhs < rhs);
  }



  // template <typename First, typename...Cpts>
  // inline void mds_record::bind(First &&first, Cpts &&...cpts) const {
  //   mds_namespace::current()->at(std::forward<First>(first),
  //                                std::forward<Cpts>(cpts)...)
  //     .template as<mds_record>().bind(THIS_RECORD);
  // }
    /*


    template <typename R, typename = enable_if_record<R> >
    static const creator &creator_for() {
      static leaf_creator<R> c;
      return c;
    }
    */

  template <typename R, typename = enable_if_record<R> >
  struct typed_rc_token : mds_record::rc_token {

    mds_record::handle_type create() const override {
      ensure_thread_initialized();
      return managed_type<R>().ensure_created().create_record();
    }
    std::shared_ptr<R> cached_shared_ptr() const {
      return std::static_pointer_cast<R>(_shared_ptr);
    }
    void cache_shared(mds_record *r) const override {
      /*
       * This is called from mds_record's ctor, so the actual
       * concrete class hasn't been constructed yet.  I'm assuming
       * that creating a shared_ptr to it won't involve anythnig more
       * than doing some adjustment to the this pointer.
       */
      R *dc_rec = static_cast<R *>(r);
      _shared_ptr = std::shared_ptr<R>(dc_rec);
      recent_stack().top() = r;
    }

    static R *being_constructed() {
      auto &recent = recent_stack();
      R *as_record = static_cast<R*>(recent.top());
      assert(recent.top() != nullptr);
      return as_record;
    }

  };
  

  template <typename R, typename...Args>
  inline mds_ptr<R> new_record(Args&&...args) {
    /*
     * We want to do a make_shared here, but that doesn't allow us to
     * use shared_from_this() inside the ctor, since that requires
     * that a shared pointer already be established, and make_shared
     * doesn't do that until the end.  (Why?)  So what we do instead
     * is to do a normal new and create a shared ptr in
     * mds_record's ctor, caching it in the token.  By the time
     * the user ctors are called, shared_from_this() is fine.  We drop
     * the result of new on the floor and just return the cached
     * shared ptr.
     *
     * Unfortunately, this means that we forgo the space compaction
     * we'd get with make_shared.
     */
    //return std::make_shared<R>(typed_rc_token<R>(), std::forward<Args>(args)...);
    typed_rc_token<R> tok;
    new R(tok, std::forward<Args>(args)...);
    return mds_ptr<R>::__from_shared(tok.cached_shared_ptr());
  }

  template <typename R, typename...Args, typename=enable_if_record<R>>
  inline mds_ptr<R> make_mds(Args&&...args) {
    return new_record<R>(std::forward<Args>(args)...);
  }

  struct creator_cache {
    using creation_fn = std::function<mds_ptr<mds_record> (const mds_record::handle_type &)>;
    using map_type = std::unordered_map<api::interned_string_handle, creation_fn>;
  private:
    static auto & global_map() {
      static map_type m;
      return m;
    }
    static std::mutex mtx;

  public:
    static void register_type(const api::const_record_type_handle &type_handle,
			      const creation_fn &fn)
    {
      using namespace std;
      std::lock_guard<std::mutex> lock{mtx};
      auto name = type_handle.name();
      global_map()[name] = fn;
      // cout << "Registering creator for " << type_handle.name().utf8()
      // 	   << "[" << type_handle.pointer().value().as_bare_pointer() << "]"
      // 	   << endl;
    }

    static
    mds_ptr<mds_record> create(api::const_record_type_handle type_handle,
				   const mds_record::handle_type &record_handle)
    {
      using namespace std;
      static thread_local map_type local_map;
      for (;
	   !type_handle.is_null();
	   type_handle = type_handle.super_type())
	{
	  // cout << "Looking for creator for " << type_handle.name().utf8()
	  //      << "[" << type_handle.pointer().value().as_bare_pointer() << "]"
	  //      << endl;
	  auto name = type_handle.name();
	  creation_fn fn = local_map[name];
	  if (fn == nullptr) {
	    {
	      // cout << "  Not found in local map" << endl;
	      std::lock_guard<std::mutex> lock{mtx};
	      fn = global_map()[name];
	    }
	    if (fn == nullptr) {
	      // cout << "  Not found in global map" << endl;
	      continue;
	    }
	    local_map[name] = fn;
	  }
	  return fn(record_handle);
	}
      return nullptr;
    }
    
  };

  template <typename R, typename = void>
  struct record_creator {
    static mds_ptr<R> create_from_handle(const mds_record::handle_type &h) {
      typed_rc_token<R> tok;
      new R(tok, h);
      return mds_ptr<R>::__from_shared(tok.cached_shared_ptr());
    }

    static void register_type(const api::const_record_type_handle &t) {
      creator_cache::register_type(t, &create_from_handle);
    }
  };
  template <typename R>
  struct record_creator<R, std::enable_if_t<std::is_abstract<R>::value> >
  {
    static mds_ptr<R> create_from_handle(const mds_record::handle_type &h) {
      return nullptr;
    }

    static void register_type(const api::const_record_type_handle &t) {}
  };

  template <typename R>
  struct managed_type<R, enable_if_record<R>>
  : public managed_type_base__<api::kind::RECORD, mds_ptr<R> >
  {
    using super = managed_type_base__<api::kind::RECORD, mds_ptr<R>>;
    using handle_type = api::record_type_handle;
    using const_handle_type = api::const_record_type_handle;
    using typename super::core_api_type;
    using typename super::mds_type;
    using const_mds_type = mds_ptr<const R>;

    const_handle_type handle() const {
      return R::type_decl().handle();
    }

    const_handle_type ensure_created() const {
      return R::type_decl().ensure_created();
    }

    static void ensure_complete() {
      R::type_decl().ensure_created();
    }


    /*
     * If there are no virtual functions we might as well just create
     * a new proxy object.  We could cache them, but this is probably
     * at least as efficient.
     */
    //    template <typename X=R, typename = std::enable_if_t<!std::is_abstract<X>::value> >
    //      static mds_ptr<R> from_handle(const mds_record::handle_type &h)
    //    {
    //      return create_from_handle(h);
    //    }


    /*
     * If there are virtual functions, we need to find the actual type
     * for the record.
     */

    //    template <typename X=R, typename = std::enable_if_t<std::is_abstract<X>::value> >
    static mds_ptr<R> from_handle(const mds_record::handle_type &h)
    {
      if (!std::is_abstract<R>::value) {
	/*
	 * If there are no virtual functions we might as well just create
	 * a new proxy object.  We could cache them, but this is probably
	 * at least as efficient.
	 */
	return record_creator<R>::create_from_handle(h);
      } else {
	/*
	 * If there are virtual functions, we need to find the actual type
	 * for the record.
	 */
	const_handle_type th = h.type();
	/*
	 * If it's ours, we can just create it here.
	 */
	if (th == managed_type().handle()) {
	  return record_creator<R>::create_from_handle(h);
	}
	mds_ptr<mds_record> r = creator_cache::create(th, h);
	/*
	 * We should be guaranteed of at least finding *this* class.
	 */
	assert(r != nullptr);
	return r.static_pointer_cast<R>();
      }
    }
    
    mds_ptr<R> from_core(const mds_record::handle_type &val) const {
      if (val == nullptr) {
	return nullptr;
      }
      return from_handle(val);
    }
    core_api_type to_core(const mds_ptr<R> &val) const {
      core_api_type tcv = val == nullptr ? core_api_type{} : val->_handle;
      return tcv;
    }
    core_api_type to_core(const mds_ptr<const R> &val) const {
      return val == nullptr ? core_api_type{} : val->_handle;
    }
  };

  template <typename R, typename T>
  class record_field : public record_field_base__
  {
    //    static_assert(is_record_type<R>::value, "Not a record type");
    using handle_type = typename managed_type<T>::field_handle_type;
    handle_type _handle;

    using mtype = managed_type<T>;
  public:
    using value_type = typename mtype::mds_type;
  private:
    using core_api_type = typename mtype::core_api_type;

    static value_type from_core(const core_api_type &val) {
      return mtype().from_core(val);
    }

    //    template <record_field<R,T> &(*Fld)()> friend class record_member<R,T,Fld>;

    /*
     * When we're and array field, the API read methods only get it as the base
     * array pointer, so we need to downcast.  This should be safe
     */
    template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    static value_type from_core(const api::managed_array_base_handle &handle) {
      using elt_type = typename mtype::elt_type;
      core_api_type h(handle.pointer()->template downcast<elt_type::kind>(),
                      handle.view());
      return from_core(h);
    }
    static core_api_type to_core(const value_type &val) {
      return mtype().to_core(val);
    }
    
  public:
    record_field(const record_field &) = delete;
    record_field(record_field &&) = delete;
    record_field &operator =(const record_field &) = delete;
    record_field &operator =(record_field &&) = delete;
    record_field() = default;

    void declare(const mds_string &name, const api::record_type_handle rt) override {
      assert(_handle.is_null());
      const auto &ft = managed_type<T>().handle();
      _handle = ft.field_in(rt, name.handle(), true);
    }

    void ensure_type() const override {
      managed_type<T>::ensure_complete();
    }

    class const_reference {
    protected:
      friend class record_field;
      const handle_type _field_handle;
      const mds_record::handle_type _record_handle;
      const_reference(const record_field &f, const mds_record &r)
	: _field_handle(f._handle),
	  _record_handle(r._handle)
      {}
    public:
      value_type read() const {
	return from_core(_field_handle.frozen_read(_record_handle));
      }
      
      value_type peek() const {
	return from_core(_field_handle.free_read(_record_handle));
      }

      operator value_type () const {
	return read();
      }

      template <typename RHS>
      bool operator ==(RHS&& rhs) const {
	return read() == std::forward<RHS>(rhs);
      }
      template <typename RHS>
      bool operator !=(RHS&& rhs) const {
	return read() != std::forward<RHS>(rhs);
      }

      template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
      auto cbegin() const {
        return read().cbegin();
      }
      template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
      auto begin() const {
        return read().cbegin();
      }

      template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
      auto cend() const {
        return read().cend();
      }
      template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
      auto end() const {
        return read().cend();
      }

      template <typename V=value_type, typename RT=decltype(V{}.operator->())>
      auto operator->() const {
        return read();
      }

      template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
      auto operator[](std::size_t i) const {
        return read()[i];
      }
    };

    class reference : public const_reference {
      friend class record_field;
      reference(const record_field &f, mds_record &r)
	: const_reference(f, r)
      {}
      using const_reference::_field_handle;
      using const_reference::_record_handle;

    public:
      value_type write(const value_type &rhs)  {
	_field_handle.write(_record_handle,
                            to_core(rhs));
        return rhs;
      }
      // value_type write(value_type &&rhs)  {
      //   return from_core(_field_handle.write(_record_handle,
      //                                        to_core(std::move(rhs))));
      // }

      value_type exchange(const value_type &rhs)  {
	return from_core(_field_handle.write(_record_handle,
                                             to_core(rhs),
                                             api::ret_mode::prior_val));
      }

      value_type operator =(const value_type &rhs)  {
        return write(rhs);
      }
      // value_type operator =(value_type &&rhs)  {
      //   return write(std::move(rhs));
      // }

      // template <typename R2, typename T2>
      // reference &operator =(const typename record_field<R2,T2>::const_reference &rhs) {
      //   return (*this) = static_cast<value_type>(rhs);
      // }
      // reference &operator =(const reference &rhs) {
      //   return (*this) = static_cast<value_type>(rhs);
      // }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator +=(value_type rhs) {
	return from_core(_field_handle.add(_record_handle,
					   to_core(rhs)));
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type fetch_add(const value_type &rhs)  {
	return from_core(_field_handle.add(_record_handle,
                                           to_core(rhs),
                                           api::ret_mode::prior_val));
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator ++() {
	return (*this) += 1;
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator ++(int) {
	return ++(*this) - 1;
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator -=(value_type rhs) {
	return from_core(_field_handle.sub(_record_handle,
					   to_core(rhs)));
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type fetch_sub(const value_type &rhs)  {
	return from_core(_field_handle.sub(_record_handle,
                                           to_core(rhs),
                                           api::ret_mode::prior_val));
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator --() {
	return (*this) -= 1;
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator --(int) {
	return --(*this) + 1;
      }

      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator *=(value_type rhs) {
	return from_core(_field_handle.mul(_record_handle,
					   to_core(rhs)));
      }
      template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
      value_type operator /=(value_type rhs) {
	return from_core(_field_handle.div(_record_handle,
					   to_core(rhs)));
      }



    };

    reference operator[](const mds_ptr<R> &r) const {
      R::type_decl().ensure_created();
      return reference(*this, *r);
    }
    reference operator[](R *r) const {
      R::type_decl().ensure_created();
      return reference(*this, *r);
    }

    const_reference operator[](const mds_ptr<const R> &r) const {
      R::type_decl().ensure_created();
      return const_reference(*this, *r);
    }
    const_reference operator[](const R *r) const {
      R::type_decl().ensure_created();
      return const_reference(*this, *r);
    }

  };


  template <typename R, typename T, record_field<R,T> &(*Field)()>
  class record_member {
    R &_enclosing;
    mds_ptr<const R> _enclosing_ptr() const {
      return _enclosing.this_as_mds_ptr(static_cast<const R *>(&_enclosing));
    }
    mds_ptr<R> _enclosing_ptr() {
      return _enclosing.this_as_mds_ptr(static_cast<R *>(&_enclosing));
    }
    auto _field_ref() const {
      return Field()[_enclosing_ptr()];
    }
    auto _field_ref() {
      return Field()[_enclosing_ptr()];
    }
  public:
    using value_type = typename record_field<R,T>::value_type;

    record_member()
      : _enclosing(*typed_rc_token<R>::being_constructed())
    {
      assert(&_enclosing != nullptr);
    }

    explicit record_member(const value_type &v)
      : record_member()
    {
      write(v);
    }

    explicit record_member(const record_member &other)
      : record_member()
    {
      write(other);
    }

    template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    explicit record_member(std::size_t n)
      : record_member()
    {
      write(T::create(n));
    }
    template <typename Iter, typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    explicit record_member(Iter from, Iter to) 
      : record_member()
    {
      write(T::create(from, to));
    }
    value_type operator =(const record_member &other)
    {
      return write(other);
    }

    value_type read() const {
      return _field_ref().read();
    }
    
    value_type peek() const {
      return _field_ref().peek();
    }
    
    operator value_type() const {
      return read();
    }

    template <typename RHS>
    bool operator ==(RHS&& rhs) const {
      return read() == std::forward<RHS>(rhs);
    }
    template <typename RHS>
    bool operator !=(RHS&& rhs) const {
      return read() != std::forward<RHS>(rhs);
    }
    template <typename RHS>
    bool operator <(RHS&& rhs) const {
      return read() < std::forward<RHS>(rhs);
    }
    template <typename RHS>
    bool operator <=(RHS&& rhs) const {
      return read() <= std::forward<RHS>(rhs);
    }
    template <typename RHS>
    bool operator >(RHS&& rhs) const {
      return read() > std::forward<RHS>(rhs);
    }
    template <typename RHS>
    bool operator >=(RHS&& rhs) const {
      return read() >= std::forward<RHS>(rhs);
    }

    template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    auto cbegin() const {
      return read().cbegin();
    }
    template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    auto begin() const {
      return read().cbegin();
    }

    template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    auto cend() const {
      return read().cend();
    }
    template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    auto end() const {
      return read().cend();
    }

    template <typename V=value_type, typename RT=decltype(V{}.operator->())>
    auto operator->() const {
      return read();
    }
    
    template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    auto operator[](std::size_t i) const {
      return read()[i];
    }

    value_type operator =(const value_type &rhs) {
      return write(rhs);
    }
    
    template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    auto size() const {
      return read().size();
    }
    // record_member &operator =(value_type &&rhs) {
    //   _field_ref() = std::move(rhs);
    //   return this;
    // }

    value_type write(const value_type &rhs) {
      return _field_ref().write(rhs);
    }

    value_type write(value_type &&rhs) {
      return _field_ref().write(std::move(rhs));
    }
    
    value_type exchange(const value_type &rhs) {
      _field_ref().exchange() = rhs;
    }

    template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
    value_type operator +=(value_type rhs) {
      return _field_ref() += rhs;
    }
    template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
    value_type fetch_add(value_type rhs) {
      return _field_ref().fetch_add(rhs);
    }
    template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
    value_type operator ++() {
      return (*this) += 1;
    }
    template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
    value_type operator ++(int) {
      return fetch_add(1);
    }
    template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
    value_type operator -=(value_type rhs) {
      return _field_ref() -= rhs;
    }
    template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
    value_type fetch_sub(value_type rhs) {
      return _field_ref().fetch_sub(rhs);
    }
    template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
    value_type operator --() {
      return (*this) -= 1;
    }
    template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
    value_type operator --(int) {
      return fetch_sub(1);
    }
    template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
    value_type operator *=(value_type rhs) {
      return _field_ref() *= rhs;
    }
    template <typename U=T, typename = std::enable_if_t<std::is_arithmetic<U>::value> >
    value_type operator /=(value_type rhs) {
      return _field_ref() /= rhs;
    }
    
  };
  
  template <typename R, typename T, record_field<R,T> &(*Field)()>
  class record_const_member {
  public:
    using value_type = typename record_field<R,T>::value_type;
  private:
    R &_enclosing;
    mutable value_type _cached_val;
    mutable bool _is_cached;

    mds_ptr<const R> _enclosing_ptr() const {
      return _enclosing.this_as_mds_ptr(static_cast<const R *>(&_enclosing));
    }
    mds_ptr<R> _enclosing_ptr() {
      return _enclosing.this_as_mds_ptr(static_cast<R *>(&_enclosing));
    }
    auto _field_ref() const {
      return Field()[_enclosing_ptr()];
    }
    auto _field_ref() {
      return Field()[_enclosing_ptr()];
    }
  public:
    record_const_member()
      : _enclosing(*typed_rc_token<R>::being_constructed()), _is_cached{false}
    {
      assert(&_enclosing != nullptr);
    }

    explicit record_const_member(const value_type &v)
      : _enclosing(*typed_rc_token<R>::being_constructed()),
        _cached_val(_field_ref().write(v)),
        _is_cached{true}
    {
    }

    explicit record_const_member(const record_const_member &other)
      : record_const_member(other.read())
    {
    }

    template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    explicit record_const_member(std::size_t n)
      : record_const_member(T::create(n))
    {
    }
    template <typename Iter, typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    explicit record_const_member(Iter from, Iter to) 
      : record_const_member(T::create(from, to))
    {
    }

    value_type read() const {
      if (!_is_cached) {
        _cached_val = _field_ref().read();
        _is_cached = true;
      }
      return _cached_val;
    }
    
    value_type peek() const {
      return read();
    }
    
    operator value_type() const {
      return read();
    }

    template <typename RHS>
    bool operator ==(RHS&& rhs) const {
      return read() == std::forward<RHS>(rhs);
    }
    template <typename RHS>
    bool operator !=(RHS&& rhs) const {
      return read() != std::forward<RHS>(rhs);
    }
    template <typename RHS>
    bool operator <(RHS&& rhs) const {
      return read() < std::forward<RHS>(rhs);
    }
    template <typename RHS>
    bool operator <=(RHS&& rhs) const {
      return read() <= std::forward<RHS>(rhs);
    }
    template <typename RHS>
    bool operator >(RHS&& rhs) const {
      return read() > std::forward<RHS>(rhs);
    }
    template <typename RHS>
    bool operator >=(RHS&& rhs) const {
      return read() >= std::forward<RHS>(rhs);
    }

    template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    auto cbegin() const {
      return read().cbegin();
    }
    template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    auto begin() const {
      return read().cbegin();
    }

    template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    auto cend() const {
      return read().cend();
    }
    template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    auto end() const {
      return read().cend();
    }

    template <typename V=value_type, typename RT=decltype(V{}.operator->())>
    auto operator->() const {
      return read();
    }
    
    template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    auto operator[](std::size_t i) const {
      return read()[i];
    }

    template <typename U=T, typename=std::enable_if_t<is_mds_array<U>::value> >
    auto size() const {
      return read().size();
    }

    
  };
  

#define RECORD_SETUP(name, super, tname, fields...)		   \
  name(const rc_token &tok, const typename super::handle_type &h) : super{tok, h} {} \
  name(const rc_token &tok, typename super::handle_type &&h) : super{tok, std::move(h)} {} \
  static rt_decl<name, super> &type_decl() {                    \
    static rt_decl<name, super> td__(tname, fields);            \
    return td__; \
  } \
  template <typename First, typename...Cpts> \
  static auto lookup_in(const mds_ptr<mds_namespace> &ns, First &&first, Cpts &&...cpts) { \
    return ns->at(std::forward<First>(first), std::forward<Cpts>(cpts)...) \
      .template as<name>().get(); \
  } \
  template <typename First, typename...Cpts> \
  static auto lookup_name(First &&first, Cpts &&...cpts) { \
    return lookup_in(mds_namespace::current(), \
                       std::forward<First>(first), \
                       std::forward<Cpts>(cpts)...); \
  }
    

#define FIELD_VAR(name) name##_fld_
#define DECLARE_FIELD(rtype, ftype, name)\
  static record_field<rtype, ftype> &FIELD_VAR(name)() {\
    static record_field<rtype, ftype> _field;\
    return _field;\
  }\
  record_member<rtype, ftype, &rtype::FIELD_VAR(name)> name;
#define DECLARE_CONST_FIELD(rtype, ftype, name)\
  static record_field<rtype, ftype> &FIELD_VAR(name)() {\
    static record_field<rtype, ftype> _field;\
    return _field;\
  }\
  record_const_member<rtype, ftype, &rtype::FIELD_VAR(name)> name;

#define REGISTER_FIELD_AS(field, name) std::make_pair(&FIELD_VAR(field)(), mds_string(name))
#define REGISTER_FIELD(name) REGISTER_FIELD_AS(name, #name)
#define NO_FIELDS rt_decl_no_fields{}  

  template <typename C, typename T, typename R, typename X>
  std::basic_ostream<C, T> &
  operator <<(std::basic_ostream<C, T> &os, const typename record_field<R,X>::reference &ref) {
    return os << ref.read();
  }

  // template <typename C, typename T, typename R, typename X>
  // std::basic_ostream<C, T> &
  // operator <<(std::basic_ostream<C, T> &os, const typename record_field<R,X>::reference &ref) {
  //   return os << ref.peek();
  // }

  struct rt_decl_no_fields{};

  template <typename R, typename ... Supers>
  class rt_decl {
    // static_assert(is_record_type<R>::value, "Not a record type");
    struct field_decl {
      mds_string name;
      record_field_base__*field;
      field_decl(const mds_string &n, record_field_base__*f)
      : name{n}, field{f}
      {}
    };
    std::vector<field_decl> _field_decls;
    const api::record_type_handle _declared_type;
    api::const_record_type_handle _created_type;
    std::once_flag _created;

    template <typename T, typename E> friend class managed_type;
    api::const_record_type_handle handle() const {
      return _created_type.is_null() ? _declared_type : _created_type;
    }

    api::record_type_handle declare(const mds_string &name) {
      return api::record_type_handle::declare(name.handle());
    }
    api::record_type_handle declare(const mds_string &name, managed_type<mds_record>) {
      return api::record_type_handle::declare(name.handle());
    }

    template <typename S>
    api::record_type_handle declare(const mds_string &name, managed_type<S> s) {
      static_assert(is_record_type<S>::value, "Super type not a record type");
      auto sp = s.ensure_created();
      return api::record_type_handle::declare(name.handle(), sp);
    }

    void note_fields() {}

    void note_fields(rt_decl_no_fields) {}

    template <typename ...More>
    void note_fields(const std::pair<record_field_base__*, const mds_string &> &fn_pair,
                     More&&...more) {
      _field_decls.emplace_back(fn_pair.second, fn_pair.first);
      note_fields(std::forward<More>(more)...);
    }
    //    template <typename ...More>
    //    void note_fields(record_field_base__*f, const std::string &name, More&&...more) {
    //      note_fields(f, mds_string{name}, std::forward<More>(more)...);
    //    }
  public:
    template <typename ...Fields>
    explicit rt_decl(const mds_string &name, Fields&&...fields)
    : _declared_type(declare(name, managed_type<Supers>()...))
    {
      note_fields(std::forward<Fields>(fields)...);
      // It's tempting to declare the fields here and set created_type
      // if the declared type is already created.  Unfortunately, for
      // recursive types (including mutually recursive types),
      // declaring the field would result in calling type_decl(),
      // which is declaring this object as a static local, which
      // results in the thread deadlocking with itself.
    }

    //    template <typename ...Fields>
    //    explicit rt_decl(const std::string &name, Fields&&...fields)
    //    : rt_decl(mds_string{name}, std::forward<Fields>(fields)...)
    //    {}

    void declare_fields() {
      for (const field_decl &fd : _field_decls) {
	fd.field->declare(fd.name, _declared_type);
      }
    }

    void ensure_field_types() {
      for (const field_decl &fd : _field_decls) {
	fd.field->ensure_type();
      }
    }

    api::const_record_type_handle
    ensure_created() {
      if (_created_type == nullptr) {
	/*
	 * This needs to work in two phases.  In the first, we declare
	 * the fields, and we have to be sure that this can't result
	 * in a recursive call to ensure_created() or we will have a
	 * deadlock.  But we have to make sure that any referenced
	 * types (including this one) are created, so we have a second
	 * pass that loops through the fields and does this.  But we
	 * go through the second pass after setting _created_type, and
	 * we use a check on _created_type to avoid locking.
	 *
	 * There is a failure window in between the internal call to
	 * ensure_created() and the end of this function.  If we die
	 * there, we will have a created record type that may have
	 * fields whose types are uncreated record types.  We will
	 * not, however, have actually created any instances of this
	 * record type (since we died).  This will result in an
	 * incompatible type exception, since the types won't be the
	 * same nor will one forward to the other.
	 *
	 * TODO: Make it possible for the next process to finish the
	 * job by overwriting the field type with its own.
	 */
	std::call_once(_created, [this]() {
	    declare_fields();
	    _created_type = _declared_type.ensure_created();
	    record_creator<R>::register_type(_created_type);
	    ensure_field_types();
	  });
      }
      return _created_type;
    }
  };

}

namespace std {
  template<>
  struct hash<mds::mds_ptr<mds::mds_record>>
  {
    std::size_t operator()(const mds::mds_ptr<mds::mds_record> &rp) const noexcept {
      return hash<ruts::uniform_key>{}(rp->uuid());
    }
  };
}

#endif /* MANAGED_RECORD_H_ */
