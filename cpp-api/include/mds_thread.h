/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * mds_thread.h
 *
 *  Created on: Mar 15, 2015
 *      Author: evank
 */

#ifndef MDS_THREAD_H_
#define MDS_THREAD_H_

#include "mds_common.h"
#include "ruts/linked_thread.h"
#include "iso_ctxt.h"

#include <thread>
#include <utility>

namespace mds {
  // mds::mds_thread is just like std::thread, but
  // it copies its thread-local context to the new thread

  class thread_local_data {
    task *current_task_ptr = &task::_current();

    thread_local_data() = default;
    thread_local_data(const thread_local_data &other) {
      *current_task_ptr = *other.current_task_ptr;
    }
    
    static thread_local_data &current() {
      static thread_local_data tld;
      return tld;
    }
    static void from_parent(const thread_local_data &tld) {
      current() = tld;
      ensure_thread_initialized();
    }

    friend class mds_thread;
  };
  
  class mds_thread : public ruts::linked_thread<thread_local_data>
  {
    using base = ruts::linked_thread<thread_local_data>;
  public:
    mds_thread() = default;
    mds_thread(mds_thread &&other) = default;
    template <class Function, class...Args>
    explicit mds_thread(Function&&f, Args&&... args)
      : base(thread_local_data::current,
             thread_local_data::from_parent,
             std::forward<Function>(f),
             std::forward<Args>(args)...)
    {
    }
    mds_thread &operator =(mds_thread &&other) = default;

  };

}



#endif /* MDS_THREAD_H_ */
