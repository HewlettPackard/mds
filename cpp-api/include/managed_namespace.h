/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * managed_namespace.h
 *
 *  Created on: Mar 14, 2015
 *      Author: evank
 */

#ifndef MANAGED_NAMESPACE_H_
#define MANAGED_NAMESPACE_H_


#include "mds_common.h"
#include "mds_ptr.h"
#include "managed_type.h"
#include "managed_string.h"
#include "iso_ctxt.h"
#include <type_traits>
#include <memory>
#include <vector>
#include <algorithm>
#include <iostream>

namespace mds {
  class path;
  class mds_namespace;

  struct absolute_t {};
  constexpr absolute_t absolute{};

  class path {
    template <typename C, typename T, typename A>
    using basic_string = std::basic_string<C,T,A>;
    using size_t = std::size_t;
    template <typename T> using vector = std::vector<T>;
    friend class mds_namespace;

  public:
    // needs to be public to allow subclasses
    struct impl;
    using impl_ptr = std::shared_ptr<const impl>;
    struct impl : std::enable_shared_from_this<impl> {
      bool absolutep = false;
      size_t initial_ups = 0;
      vector<mds_string> names;

      void up_levels(size_t levels) {
        size_t current = names.size();
        size_t new_size = current <= levels ? 0 : current-levels;
        names.resize(new_size);
        if (!absolutep && levels > current) {
          initial_ups += levels-current;
        }
      }

      void reset_to_root() {
        names.clear();
        initial_ups = 0;
        absolutep = true;
      }

      static const mds_string &self_cpt() {
        static mds_string s{"."};
        return s;
      }
      static const mds_string &up_cpt() {
        static mds_string s{".."};
        return s;
      }

      static const impl_ptr &self() {
        static impl_ptr i = std::make_shared<const impl>();
        return i;
      }
      void append(const mds_string &cpt) {
        if (cpt == self_cpt()) {
          return;
        } else if (cpt == up_cpt()) {
          up_levels(1);
        } else {
          names.push_back(cpt);
        }
      }

      bool is_absolute() const {
        return absolutep;
      }

      void extend() {
      }

      template <typename First, typename ...Rest>
      void extend(absolute_t, First&& first, Rest &&...rest) {
        reset_to_root();
        extend(std::forward<First>(first), std::forward<Rest>(rest)...);
      }
      template <typename First, typename ...Rest>
      void extend(First&& first, Rest &&...rest) {
        append_cpt(std::forward<First>(first));
        extend(std::forward<Rest>(rest)...);
      }

      template <typename ...Cpts>
      explicit impl(Cpts&&... cpts) {
        extend(std::forward<Cpts>(cpts)...);
      }

      template <typename ...Cpts>
      impl_ptr resolve(Cpts&&...cpts) {
        std::shared_ptr<impl> clone = std::make_shared<impl>(*this);
        clone->extend(std::forward<Cpts>(cpts)...);
        return clone;
      }


      void append_cpt(const path &cpt) {
        const impl *i = cpt._ptr.get();
        if (i->absolutep) {
          reset_to_root();
        } else {
          std::size_t ups = i->initial_ups;
          if (ups > 0) {
            up_levels(ups);
          }
        }
        std::copy(i->names.cbegin(), i->names.cend(), std::back_inserter(names));
      }
      template <typename T, size_t N, typename = std::enable_if_t<is_char_type<T>::value> >
      void append_cpt(const T (&cpt)[N]) {
        append_cpt(cpt, cpt+0, cpt+N-1);
      }
      template <typename C, typename T, typename A>
      void append_cpt(const basic_string<C,T,A> &cpt) {
        append_cpt(cpt, cpt.cbegin(), cpt.cend());
      }
      void append_cpt(const mds_string &cpt) {
        append_cpt(cpt, cpt.cbegin(), cpt.cend());
      }
      /*
       * TODO: This doesn't handle other delimiters and doesn't allow delimiters to
       * be escaped.
       */
      template <typename T, typename Iter>
      void append_cpt(T &&cpt, Iter from, Iter to) {
        using namespace std;
        char delim{'/'};
        Iter delim_pos = std::find(from, to, delim);
        // Is it the whole string?  then just use the component
        if (delim_pos == to) {
          append(mds_string{std::forward<T>(cpt)});
          return;
        }
        // Does it start with the delimiter?  It's absolute
        if (delim_pos == from) {
          reset_to_root();
          from++;
          delim_pos = std::find(from, to, delim);
        }
        // [from, delim_pos) contains a name
        while (true) {
          mds_string name{from, delim_pos};
          append(name);
          if (delim_pos == to) {
            return;
          }
          from = delim_pos+1;
          delim_pos = std::find(from, to, delim);
        }
      }

      template <typename C, typename T>
      std::basic_ostream<C,T> &print_on(std::basic_ostream<C,T> &os) {
        bool printsep = absolutep;
        for (size_t i=0; i<initial_ups; i++) {
          if (printsep) {
            os << '/';
          }
          os << "..";
          printsep = true;
        }
        for (const auto &n : names) {
          if (printsep) {
            os << '/';
          }
          os << n;
          printsep = true;
        }
        return os;
      }

    };

  private:
    impl_ptr _ptr;
    path(const impl_ptr &p) : _ptr{p} {}
  protected:
  public:
    path() : _ptr{impl::self()} {}
    path(const path &) = default;
    path(path&&) = default;
    template <typename ...Cpts>
    static path of(Cpts &&...cpts) {
      return path{std::make_shared<const impl>(std::forward<Cpts>(cpts)...)};
    }
    //    explicit path(const mds_string &p);
    //    template <typename C, typename T, typename A>
    //    explicit path(const basic_string<C,T,T> &p);
    //    template <typename T, size_t N, typename = std::enable_if_t<is_char_type<T>::value> >
    //    explicit path(const T (&chars)[N]);

    bool is_absolute() const {
      return _ptr->is_absolute();
    }
    template <typename ...Cpts>
    path resolve(Cpts&& ...cpts) {
      return path{_ptr->resolve(std::forward<Cpts>(cpts)...)};
    }

    template <typename C, typename T>
    std::basic_ostream<C,T> &print_on(std::basic_ostream<C,T> &os) {
      return _ptr->print_on(os);
    }

  };

  template <typename T, typename Enable = void> struct is_path_cpt : std::false_type {};
  template <> struct is_path_cpt<path> : std::true_type {};
  template <> struct is_path_cpt<absolute_t> : std::true_type {};
  template <typename T, size_t N>
  struct is_path_cpt<const T[N], std::enable_if_t<is_char_type<T>::value>> : std::true_type {};
  template <typename C, typename T, typename A>
  struct is_path_cpt<std::basic_string<C,T,A>> : std::true_type {};
  template <> struct is_path_cpt<mds_string> : std::true_type {};

  struct illegal_path_ex {
    const mds::path path;
    illegal_path_ex(const mds::path &p) : path{p} {}
  };

  class mds_namespace
      : public std::enable_shared_from_this<mds_namespace> {
    using handle_type = api::namespace_handle;

    handle_type _handle;
    mds_ptr<mds_namespace> _parent;
    mds_string _name;
    mds_ptr<mds_namespace> resolve(const path &p, bool include_last) const;
    mds_ptr<mds_namespace> resolve(const path &p) const {
      return resolve(p, true);
    }
        public:
    class name_binding;
        private:
    name_binding resolve_to_binding(const path &p) const;

    struct call_from_factory {};
  public:
    handle_type handle() const {
      return _handle;
    }
    /*
     * By requiring a (zero-size) call_from_factory object, which is private, we ensure that mds_namespaces
     * are only created using the make() factory method, which ensures that they are created shared.  We can't just
     * make the constructor private, or make_shared() wouldn't be able to see it.
     */
    mds_namespace(call_from_factory, const handle_type &h, const mds_ptr<mds_namespace> &p, const mds_string &n)
    : _handle{h}, _parent{p}, _name{n}
    {
    }
    /*
     * Assignment ops are deleted to avoid saying something like (*nsptr) = ...
     */
    mds_namespace operator=(const mds_namespace &) = delete;
    mds_namespace operator=(mds_namespace &&) = delete;
    /*
     * Move ctor is deleted to avoid clobbering shared pointers.
     */
    mds_namespace(mds_namespace &&) = delete;

    static mds_ptr<mds_namespace>
    make(const handle_type &h, const mds_ptr<mds_namespace> &p, const mds_string &n) {
      ensure_thread_initialized();
      auto sp = std::make_shared<mds_namespace>(call_from_factory{}, h, p, n);
      return mds_ptr<mds_namespace>::__from_shared(sp);
    }

    static const mds_ptr<mds_namespace> &root() {
      static mds_ptr<mds_namespace> ns = make([](){
          ensure_thread_initialized();
          return handle_type::global();
        }(), nullptr, mds_string{});
      return ns;
    }
    static mds_ptr<mds_namespace> &current() {
      static thread_local mds_ptr<mds_namespace> ns = root();
      return ns;
    }
    mds_ptr<mds_namespace> parent() {
      return is_root() ? root() : _parent;
    }
    mds_ptr<const mds_namespace> parent() const {
      return is_root() ? root() : _parent;
    }
    mds_string name() const {
      return _name;
    }
    bool is_root() const {
      return *this == *root();
    }

    template <typename T>
    using dc_t = std::remove_cv_t<std::remove_reference_t<T>>;

    template <typename First, typename ...Rest/*, typename = std::enable_if_t<is_path_cpt<dc_t<First>>::value>*/ >
    static mds_ptr<mds_namespace>
    from_path(First &&first, Rest&&...rest) {
      const path p = path::of(std::forward<First>(first), std::forward<Rest>(rest)...);
      const mds_ptr<mds_namespace> base = p.is_absolute() ? root() : current();
      return base->resolve(p);
    }

    template <typename First, typename ...Rest/*, typename = std::enable_if_t<is_path_cpt<dc_t<First>>::value> */>
    static mds_ptr<mds_namespace>
    from_absolute_path(First &&first, Rest&&...rest) {
      const path p = path::of(std::forward<First>(first), std::forward<Rest>(rest)...);
      return root()->resolve(p);
    }

    bool operator==(const mds_namespace &other) const {
      return _handle == other._handle;
    }
    bool operator!=(const mds_namespace &other) const {
      return !(*this == other);
    }

    template <typename T>
    class typed_name_binding {
      friend class name_binding;
      using value_type = typename managed_type<T>::mds_type;
      using const_value_type = typename managed_type<T>::const_mds_type;
      mds_ptr<mds_namespace> _namespace;
      mds_string _name;
      managed_type<T> _type;
      typed_name_binding(const mds_ptr<mds_namespace> &ns, const mds_string &n, const managed_type<T> &t)
      : _namespace{ns}, _name{n}, _type{t}
      {}
    public:
      // Passes through incompatible_type_ex
      value_type get() const {
        auto nhandle = _name.handle();
        auto thandle = _type.handle();
        auto h = _namespace->handle();
        try {
          return _type.from_core(h.lookup(nhandle, thandle));
        } catch (const unbound_name_ex &) {
          return value_type{};
        }
      }
      // Passes through incompatible_type_ex
      operator value_type() const {
        return get();
      }
      typed_name_binding &bind(const const_value_type&val) {
        auto nhandle = _name.handle();
        auto h = _namespace->handle();
        // TODO check for is namespace (false return)
        using type = managed_type<std::decay_t<T>>;
        h.bind<type::kind>(nhandle, type().to_core(val));
        return *this;
      }
      typed_name_binding &bind(const_value_type&&val) {
        auto nhandle = _name.handle();
        auto h = _namespace->handle();
        // TODO check for is namespace (false return)
        using type = managed_type<std::decay_t<T>>;
        h.bind<type::kind>(nhandle, type().to_core(std::move(val)));
        return *this;
      }
      typed_name_binding &operator=(const const_value_type&val) {
        return bind(val);
      }
      typed_name_binding &operator=(const_value_type&&val) {
        return bind(std::move(val));
      }
      // Returns true if bound and not incompatible.
      operator bool() const {
        return check(false);
      }

      bool check(bool allow_unbound = true) const {
        auto nhandle = _name.handle();
        auto thandle = _type.handle();
        auto h = _namespace->handle();
        try {
          h.lookup(nhandle, thandle);
          return true;
        } catch (const unbound_name_ex &) {
          return allow_unbound;
        } catch (const incompatible_type_ex &) {
          return false;
        }
      }

      bool is_bound() const {
        return _namespace->handle().is_bound(_name.handle());
      }

      template<typename V=value_type, typename = decltype(*std::declval<V>)>
      auto operator *() const {
	return *get();
      }
      template<typename V=value_type, typename = decltype(*std::declval<V>)>
      auto operator ->() const {
	return get();
      }


    };

    class name_binding {
      template <typename T> friend class typed_name_binding;
      friend class mds_namespace;
      mds_ptr<mds_namespace> _namespace;
      mds_string _name;
      bool _root_binding = false;
      name_binding(const mds_ptr<mds_namespace> &ns, const mds_string &n)
      : _namespace{ns}, _name{n}
      {
        if (n.empty()) {
          if (ns->is_root()) {
            _root_binding = true;
            _namespace = nullptr;
          } else {
            _name = ns->name();
            _namespace = ns->parent();
          }
        }
      }
    public:
      template <typename T>
      typed_name_binding<T> as(const managed_type<T> &t) const {
        if (_root_binding) {
          // throw exception
        }
        return typed_name_binding<T>{_namespace, _name, t};
      }
      auto as_mds_string() const {
        return as(mds_string_type());
      }
      auto as_int() const {
        return as(managed_int_type());
      }
      template <typename T>
      auto as() const {
	return as(managed_type<T>());
      }
      // and similarly for others.  If we go to C++14, we can just use auto for return
      template <typename T, typename = std::enable_if_t<is_managed_type<std::decay_t<T>>::value> >
      name_binding &bind(T&& val) {
        if (_root_binding) {
          // Throw exception
        }
        auto nhandle = _name.handle();
        auto h = _namespace->handle();
        // TODO check for is namespace (false return)
        h.bind<managed_type<T>::kind>(nhandle, std::forward<T>(val));
        return *this;
      }
      template <typename T, typename = std::enable_if_t<is_managed_type<std::decay_t<T>>::value> >
      name_binding &operator =(T&&val) {
        return bind<T>(std::forward<T>(val));
      }
      bool is_bound() const {
        return _namespace->handle().is_bound(_name.handle());
      }
      operator bool() const {
        return is_bound();
      }
      bool is_namespace() const;
      const mds::path &path() const;
      mds_ptr<mds_namespace> as_namespace() const {
        if (_root_binding) {
          return mds_namespace::root();
        }
        auto nhandle = _name.handle();
        auto h = _namespace->handle();
        // TODO catch incompatible_type_ex if bound to something else
        // TODO should we refuse to create if we're called on a const name_binding?  Probably

        mds_namespace::handle_type ch = h.child_namespace(nhandle, true);

        // TODO: I was going to cache this, but we'd still have to check to make sure the binding
        // hasn't been changed to point to a value (perhaps via a different namespace_binding
        // object.
        return make(ch, _namespace, _name);

      }
      operator mds_ptr<mds_namespace>() const {
        return as_namespace();
      }
      template <typename ...Cpts>
      const name_binding at(Cpts&& ...cpts) const {
        return as_namespace()->at(std::forward<Cpts>(cpts)...);
      }
      template <typename ...Cpts>
      name_binding at(Cpts&& ...cpts) {
        return as_namespace()->at(std::forward<Cpts>(cpts)...);
      }
      template <typename ...Cpts>
      const name_binding operator()(Cpts&& ...cpts) const {
        return at(std::forward<Cpts>(cpts)...);
      }
      template <typename ...Cpts>
      name_binding operator()(Cpts&& ...cpts) {
        return at(std::forward<Cpts>(cpts)...);
      }
      template <typename Cpt>
      const name_binding operator[](Cpt&& cpt) const {
        return at(std::forward<Cpt>(cpt));
      }
      template <typename Cpt>
      name_binding operator[](Cpt&& cpt) {
        return at(std::forward<Cpt>(cpt));
      }
    };
    const name_binding at_(const path &p) const {
      if (p.is_absolute()) {
        throw illegal_path_ex{p};
      }
      return resolve_to_binding(p);
    }
    name_binding at_(const path &p) {
      if (p.is_absolute()) {
        throw illegal_path_ex{p};
      }
      return resolve_to_binding(p);
    }
    template <typename First, typename ...Cpts>
    const name_binding at(First &&first, Cpts&& ...cpts) const {
      return at_(mds::path::of(std::forward<First>(first), std::forward<Cpts>(cpts)...));
    }
    template <typename First, typename ...Cpts>
    name_binding at(First &&first, Cpts&& ...cpts) {
      return at_(mds::path::of(std::forward<First>(first), std::forward<Cpts>(cpts)...));
    }
    template <typename First>
    const name_binding operator[](First &&first) const {
      return at(std::forward<First>(first));
    }
    template <typename First>
    name_binding operator[](First &&first) {
      return at(std::forward<First>(first));
    }
    template <typename First, typename ...Cpts>
    const name_binding operator()(First &&first, Cpts &&...cpts) const {
      return at(std::forward<First>(first), std::forward<Cpts>(cpts)...);
    }
    template <typename First, typename ...Cpts>
    name_binding operator()(First &&first, Cpts &&...cpts) {
      return at(std::forward<First>(first), std::forward<Cpts>(cpts)...);
    }
  };

  template <typename C, typename T, typename X>
  inline
  std::basic_ostream<C, T> &
  operator <<(std::basic_ostream<C, T> &os, const mds_namespace::typed_name_binding<X> &b) {
    return os << b.get();
  }

  template <typename C, typename T>
  inline std::basic_ostream<C,T> &
  operator <<(std::basic_ostream<C,T> &os, const path &p) {
    return p.print_on(os);
  }



}


#endif /* MANAGED_NAMESPACE_H_ */
