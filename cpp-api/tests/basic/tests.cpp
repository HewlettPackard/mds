/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include "driver.h"
#include "store.h"

namespace {
  void print_final(const mds_ptr<Store> &store) {
    unsigned i = 0;
    for(mds_ptr<Product> p : store->ranked_products()) {
      cout << i++ << " " << p << endl;
    }
  }
}


/*
 * Test 1: Initialize the store, make a purchase, update the ranks,
 * and print the ranked products.
 */
int test1(int argc, char *argv[], const string &name) {
  mds_ptr<Store> store;
  vector<double> popularity;
  tie(store, popularity) = init_store();

  auto b = make_basket(5, store, popularity);
  store->purchase(b);

  store->update_ranks();

  print_final(store);
    
  return 0;
}

/*
 * Test 2: Like test 1, two conflicting purchases in separate threads.
 * The first has five items, and the second has the same number of the
 * first item in the first thread's basket, with the second purchase
 * allowed to succeed first.  Resolution on the first purchase should
 * succeed after reprocessing the single conflicted BasketItem and the
 * task adding the basket to recent purchases (conflicted because the
 * other thread grabbed the index first).
 */
int test2(int argc, char *argv[], const string &name) {
  mds_ptr<Store> store;
  vector<double> popularity;
  tie(store, popularity) = init_store();

  auto b1 = make_basket(5, store, popularity);

  std::array<mds_ptr<BasketItem>, 1> singleton{ b1->items[0] };
  auto b2 = new_record<Basket>(singleton);
  shared_ptr<pause::button> button = make_shared<pause::button>();

  mds_thread t1([&]{
      store->purchase(b1, button);
    });

  mds_thread t2([&]{
      pause::time(3s);
      store->purchase(b2);
      button->press();
    });

  t1.join();
  t2.join();

  store->update_ranks();

  print_final(store);
    
  return 0;
}

/*
 * Test 3 is identical to test 2, but the second purchase happens in
 * the main thread.
 */
int test3(int argc, char *argv[], const string &name) {
  mds_ptr<Store> store;
  vector<double> popularity;
  tie(store, popularity) = init_store();

  auto b1 = make_basket(5, store, popularity);

  std::array<mds_ptr<BasketItem>, 1> singleton{ b1->items[0] };
  auto b2 = new_record<Basket>(singleton);
  shared_ptr<pause::button> button = make_shared<pause::button>();

  mds_thread t1([&]{
      store->purchase(b1, button);
    });

  pause::time(3s);
  store->purchase(b2);
  button->press();

  t1.join();

  store->update_ranks();

  print_final(store);
    
  return 0;
}

/*
 * Test 4: Update ranks in a thread, but pause before finishing.
 * Meanwhile, do a purchase and allow the update to finish.  It needs
 * to redo the task for the recent slot filled by the purchase and
 * setting the ranks.
 */
int test4(int argc, char *argv[], const string &name) {
  mds_ptr<Store> store;
  vector<double> popularity;
  tie(store, popularity) = init_store();

  auto b = make_basket(5, store, popularity);

  shared_ptr<pause::button> button = make_shared<pause::button>();
  mds_thread t1([&]{
      store->update_ranks(button);
    });

  pause::time(3s);
  store->purchase(b);
  button->press();

  t1.join();

  print_final(store);
  return 0;
}


/*
 * Test 5: The paused thread does a restock of 5 of every product
 */
int test5(int argc, char *argv[], const string &name) {
  mds_ptr<Store> store;
  vector<double> popularity;
  tie(store, popularity) = init_store();

  auto b = make_basket(5, store, popularity);

  shared_ptr<pause::button> button = make_shared<pause::button>();
  mds_thread t1([&]{
      store->restock([](const mds_ptr<Product> &p) {
          return 5;
        });
    });

  pause::time(3s);
  store->purchase(b);
  button->press();
  store->update_ranks();

  t1.join();

  print_final(store);
  return 0;
}

/*
 * Test 6: Testing detached contexts and namespaces.
 */
int test6(int argc, char *argv[], const string &name) {
  string p = "path";
  string key = "key";
  mds_string outer_val = "Outer";
  mds_string inner_val = "Inner";

  auto trace = [](const string &which,
                  const mds_ptr<mds_namespace> &ns,
                  const string &key)
    {
      mds_string s = ns->at(key).as_mds_string();
      cout << which << " = " << s << endl;
    };
    

  mds_ptr<mds_namespace> gns = mds_namespace::from_path(p);
  gns->at(key).as_mds_string() = outer_val;
  trace("GNS", gns, key);
  iso_ctxt c = iso_ctxt::nested_detached_from_current();
  mds_ptr<mds_namespace> lns = c.call([&]{
      cout << "--- In detached context" << endl;
      mds_ptr<mds_namespace> local = mds_namespace::from_path(p);
      trace("GNS", gns, key);
      trace("LNS", local, key);
      cout << "--- Binding" << endl;
      gns->at(key).as_mds_string() = inner_val;
      trace("GNS", gns, key);
      trace("LNS", local, key);
      cout << "--- Returning from detached context" << endl;
      return local;
    });
  trace("GNS", gns, key);
  trace("LNS", lns, key);

  return 0;
}

/*
 * Tests 7 and 8 are inapplicable to C++
 */

/*
 * Test 9: Testing accumulators
 */
int test9(int argc, char *argv[], const string &name) {
  unsigned n = 10;
  mds_array_ptr<unsigned> array = make_mds_array<unsigned>(n);
  for (unsigned i=0; i<n; i++) {
    array[i] = i;
  }

  shared_ptr<pause::button> button1 = make_shared<pause::button>();
  shared_ptr<pause::button> button2 = make_shared<pause::button>();

  unsigned sum;
  
  mds_thread t([&]{
    isolated([&]{
        accumulator<unsigned> accum;
        for (unsigned i=0; i<n; i++) {
          unsigned j=i;
          as_task([=]() mutable{
              unsigned k = array[j];
              cout << task::current() << ": Adding value " << j << ": " << k << endl;
              accum += k;
            });
        }
        as_task([accum, &sum]() mutable{
            sum = accum;
            cout << task::current() << ": Reading sum: " << sum << endl;
          });
        button1->press();
        pause::on(button2, "after change: ");
      });
    });
  pause::on(button1, "before change: ");
  cout << task::current() << ": Conflicting change: array[5] = 0" << endl;
  array[5] = 0;
  button2->press();
  t.join();
  cout << "Final sum: " << sum << endl;

  return 0;
}



int pausetest(int argc, char *argv[], const string &name) {
  cout << "Hi" << endl;
  pause::time(3s);
  cout << "There" << endl;
  return 0;
}

void register_tests() {
  register_test("1", test1);
  register_test("2", test2);
  register_test("3", test3);
  register_test("4", test4);
  register_test("5", test5);
  register_test("6", test6);
  register_test("9", test9);
}

