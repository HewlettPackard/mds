/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef STORE_H
#define STORE_H

#include "mds.h"
#include "util.h"
#include <ostream>
#include <algorithm>
#include <functional>
#include <vector>
#include <utility>
#include <unordered_map>

using namespace mds;
using namespace std;

inline string record_name(const string &n) {
  return "JavaTest::"+n;
}

class Trace : public publish_report {
  using super = publish_report;
  enum class State { Reset, Running, Resolving, Succeeded, Failed };

  const string prefix;
  State state = State::Reset;
  unsigned n_runs = 0;
  unsigned n_resolves = 0;
public:

  Trace(const string &p)
    : prefix(p.empty() ? p : p+": ")
  {}

  void reset() override {
    super::reset();
    state = State::Reset;
    n_runs = 0;
  }

  void before_run(iso_ctxt &ctxt) override {
    string ss = ctxt.is_snapshot() ? "snapshot " : "";
    if (n_runs++ == 0) {
      cout << prefix << "Isolated in " << ss << "context " << ctxt
           << " (TL task: " << ctxt.top_level_task() << ")"
           << endl;
    } else {
      if (state == State::Resolving) {
        cout << prefix << "Resolution failed after attempt " << n_resolves << endl;
      } else {
        cout << prefix << "Publish failed" << endl;
      }
      cout << prefix << "Rerun " << n_runs 
           << " in " << ss << "context " << ctxt
           << endl;
    }
    state = State::Running;
  }

  void before_resolve(const pub_result &pr) override {
    cout << prefix << "Publish failed" << endl;
    cout << prefix << "Resolving, attempt " << ++n_resolves
         << ", tasks = ";
    for (const task &t : pr.redo_tasks_by_start_time()) {
      cout << t << " ";
    }
    cout << endl;
    state = State::Resolving;
  }

  void note_success() override {
    cout << prefix << "Publish succeeded" << endl;
    state = State::Succeeded;
    super::note_success();
  }

  void note_failure() override {
    cout << prefix << "Publish failed" << endl;
    state = State::Failed;
    super::note_failure();
  }
}; // Trace


class Department : public mds_record {
  using super = mds_record;
public:
  DECLARE_CONST_FIELD(Department, mds_string, name);
  DECLARE_CONST_FIELD(Department, unsigned, number);
  DECLARE_FIELD(Department, unsigned, sales_rank);

  RECORD_SETUP(Department, super, record_name("Department"),
               REGISTER_FIELD(name),
               REGISTER_FIELD(number),
               REGISTER_FIELD(sales_rank));

  Department(const rc_token &tok, unsigned num_, const string &name_)
    : super(tok), name{name_}, number{num_}
  {
  }
}; // Department

class Product : public mds_record {
  using super = mds_record;
public:
  DECLARE_CONST_FIELD(Product, mds_string, name);
  DECLARE_CONST_FIELD(Product, unsigned, number);
  DECLARE_CONST_FIELD(Product, Department, dept);
  DECLARE_FIELD(Product, unsigned, nbr_sold);
  DECLARE_FIELD(Product, unsigned, sales_rank);

  RECORD_SETUP(Product, super, record_name("Product"),
               REGISTER_FIELD(name),
               REGISTER_FIELD(number),
               REGISTER_FIELD(dept),
               REGISTER_FIELD(nbr_sold),
               REGISTER_FIELD(sales_rank));

  Product(const rc_token &tok,
          unsigned num_, const string &name_, const mds_ptr<Department> &dept_)
    : super(tok), name{name_}, number{num_}, dept{dept_}
  {
  }
                 

  virtual unsigned remove_stock(unsigned n) = 0;
  virtual void add_stock(unsigned n, const shared_ptr<pause::button> &pb = nullptr) = 0;
  virtual unsigned in_stock() const = 0;
  virtual bool is_perishable() const = 0;
}; // Product

inline
ostream &operator <<(ostream &os, const mds_ptr<Product> &prod) {
  if (prod == nullptr) {
    return os << "null";
  }
  return os << "[" << prod->number << "]"
            << " " << prod->name
            << " (" << prod->dept->name << ")"
            << " [sold " << prod->nbr_sold << ", inStock " << prod->in_stock() << "]";
}

class NonPerishableProduct : public Product {
  using super = Product;
public:
  DECLARE_FIELD(NonPerishableProduct, unsigned, stock_on_hand);
  RECORD_SETUP(NonPerishableProduct, super, record_name("NonPerishableProduct"),
               REGISTER_FIELD(stock_on_hand));

  NonPerishableProduct(const rc_token &tok,
                       unsigned num_, const string &name_, const mds_ptr<Department> &dept_,
                       unsigned initial_stock)
    : super(tok, num_, name_, dept_), stock_on_hand{initial_stock}
  {
  }

  bool is_perishable() const {
    return false;
  }

  void add_stock(unsigned n, const shared_ptr<pause::button> &pb = nullptr) override {
    string tag = "Adding to "+name.read().utf8_copy()+": ";
    isolated([&](){
        mds_ptr<Product> me = THIS_RECORD;
        cout << "Adding " << n << " of " << me << endl;
        stock_on_hand += n;
        cout << "Now " << THIS_RECORD << endl;
        pause::on(pb, tag);
        
      });
  }

  unsigned remove_stock(unsigned n) override {
    unsigned current = stock_on_hand;
    if(current < n) {
      n = current;
    }
    stock_on_hand = current - n;
    nbr_sold += n;
    return n;
  }

  unsigned in_stock() const override {
    return stock_on_hand;
  }
}; // NonPerishableProduct

class PerishableProduct : public Product {
  using super = Product;
public:
  DECLARE_CONST_FIELD(PerishableProduct, unsigned, shelf_life);
  DECLARE_FIELD(PerishableProduct, unsigned, oldest);
  DECLARE_FIELD(PerishableProduct, unsigned, today);
  DECLARE_FIELD(PerishableProduct, unsigned, wastage);
  DECLARE_CONST_FIELD(PerishableProduct, mds_array<unsigned>, stock_on_hand);
  RECORD_SETUP(PerishableProduct, super, record_name("PerishableProduct"),
               REGISTER_FIELD(shelf_life),
               REGISTER_FIELD(oldest),
               REGISTER_FIELD(today),
               REGISTER_FIELD(wastage),
               REGISTER_FIELD(stock_on_hand));

  PerishableProduct(const rc_token &tok,
                    unsigned num_, const string &name_, const mds_ptr<Department> &dept_,
                    unsigned life,
                    unsigned initial_stock)
    : super(tok, num_, name_, dept_), shelf_life{life}, stock_on_hand(life)
  {
    stock_on_hand[0] = initial_stock;
  }

  bool is_perishable() const {
    return true;
  }

  void add_stock(unsigned n, const shared_ptr<pause::button> &pb = nullptr) override {
    string tag = "Adding to "+name.read().utf8_copy()+": ";
    isolated([&](){
        cout << "Adding " << n << " of " << THIS_RECORD << endl;
        stock_on_hand[today % shelf_life] += n;
        cout << "Now " << THIS_RECORD << endl;
        pause::on(pb, tag);
        
      });
  }

  unsigned remove_stock(unsigned n) override {
    mds_array_ptr<unsigned> stock = stock_on_hand;
    unsigned wanted = n;
    bool bumped = false;
    unsigned life = shelf_life;
    unsigned o = oldest;
    unsigned t = today;
    while (n > 0) {
      unsigned i = o%life;
      unsigned k = stock[i];
      if (k >= n) {
        stock[i] -= n;
        n = 0;
        break;
      } else {
        stock[i] = 0;
        n -= k;
        if (o == t) {
          break;
        }
        o++;
        bumped = true;
      }
    }
    if (bumped) {
      oldest = o;
    }
    nbr_sold += wanted-n;
    return wanted - n;
  }

  unsigned in_stock() const override {
    unsigned n = 0;
    for (unsigned s : stock_on_hand) {
      n += s;
    }
    return n;
  }

  void new_day() {
    unsigned t = ++today;
    unsigned o = oldest;
    unsigned life = shelf_life;
    mds_array_ptr<unsigned> stock = stock_on_hand;
    if (t % life == o % life) {
      /*
       * We've bumped so that we've wrapped around to the oldest.
       */
      unsigned wasted = stock[o%life].exchange(0);
      wastage += wasted;
      oldest++;
    }
  }
}; // PerishableProduct

class RecentPurchases;

namespace mds {
  template<> struct is_record_type<RecentPurchases> : true_type{};
}

class BasketItem : public mds_record {
  using super = mds_record;
public:
  DECLARE_CONST_FIELD(BasketItem, Product, product);
  DECLARE_FIELD(BasketItem, unsigned, quantity);

  RECORD_SETUP(BasketItem, super, record_name("BasketItem"),
               REGISTER_FIELD(product),
               REGISTER_FIELD(quantity));

  BasketItem(const rc_token &tok, const mds_ptr<Product> &p, unsigned q)
    : super(tok), product{p}, quantity{q}
  {
  }

  void purchase() {
    mds_ptr<Product> p = product;
    unsigned q = quantity;
    cout << "Purchasing " << q << " of " << p << endl;
    p->remove_stock(q);
    cout << "Now " << p << endl;
  }
}; // BasketItem

inline
ostream &operator <<(ostream &os, const mds_ptr<BasketItem> &item) {
  if (item == nullptr) {
    return os << "null";
  }
  return os << item->quantity << " of " << item->product;
}

class Basket : public mds_record {
  using super = mds_record;
public:
  DECLARE_CONST_FIELD(Basket, mds_array<BasketItem>, items);

  RECORD_SETUP(Basket, super, record_name("Basket"),
               REGISTER_FIELD(items));

  template <typename C>
  Basket(const rc_token &tok, C&& items)
    : super(tok),
      items{ new_array<BasketItem>(std::forward<C>(items).begin(),
                                   std::forward<C>(items).end()) }
  {
  }

  void purchase(const mds_ptr<RecentPurchases> &recent,
                const shared_ptr<pause::button> &button = nullptr);

  template <typename M>
  void add_to(M &total, int mult) const {
    for (const auto &item : items) {
      as_task([=, &total](){
        mds_ptr<Product> p = item->product;
        unsigned q = item->quantity;
        total[p] += mult*q;
      });
    }
  }
}; // Basket

inline
ostream &operator <<(ostream &os, const mds_ptr<Basket> &b) {
  if (b == nullptr) {
    return os << "null";
  }
  string sep = "[";
  for_each(b->items.begin(), b->items.end(),
           [&](const auto &item) {
             os << sep << item;
             sep = ", ";
           });
  return os << "]";
}



class RecentPurchases : public mds_record {
  using super = mds_record;
public:
  DECLARE_CONST_FIELD(RecentPurchases, mds_array<Basket>, purchases);
  DECLARE_FIELD(RecentPurchases, unsigned, next_purchase);
  DECLARE_CONST_FIELD(RecentPurchases, unsigned, window_size);
  
  RECORD_SETUP(RecentPurchases, super, record_name("RecentPurchases"),
               REGISTER_FIELD(purchases),
               REGISTER_FIELD(next_purchase),
               REGISTER_FIELD(window_size)
               );

  RecentPurchases(const rc_token &tok, unsigned n)
    : super(tok),
      purchases(n),
      next_purchase{0},
      window_size{n}
  {
  }

  void note(const mds_ptr<Basket> b) {
    /*
     * This needs to be done transactionally.  We assume it is being
     * done inside an isolation block in Basket.purchase().
     */
    unsigned i = next_purchase++;
    if (i == window_size-1) {
      next_purchase = 0;
    }
    cout << "Recent[" << i << "] = " << b << endl;
    purchases[i] = b;
  }

  void update_ranks(const mds_array_ptr<Product> &prods,
                    const shared_ptr<pause::button> &button = nullptr)
  {
    mds_array_ptr<Basket> array = purchases;
    unordered_map<mds_ptr<Product>, unsigned,
                  hash<mds_ptr<mds_record> > > total;
    vector<task::computed_val<mds_ptr<Basket> > > tcs;

    isolated(iso_ctxt::view_type::snapshot,
             report_to(make_shared<Trace>("Update")),
             [&](){
               cout << "In snapshot" << endl;
               pause::on(button);
               cout << "Outside task " << task::current() << endl;

               tcs.reserve(array.size());
               for (size_t i : ruts::indexes(array)) {
                 auto tc_fn = [i, &array, &total](const mds_ptr<Basket> &old) {
                   cout << "Basket task " << i << ": " << task::current() << endl;
                   mds_ptr<Basket> b = array[i];
                   if (b != nullptr) {
                     cout << "Basket: " << b << endl;
                   }
                   if (old != nullptr) {
                     old->add_to(total, -1);
                   }
                   if (b != nullptr) {
                     b->add_to(total, 1);
                   }
                   return b;
                 };
                 auto tc = task::computed<mds_ptr<Basket>>(tc_fn);
                 tcs.push_back(tc);
               }
               as_task([&tcs, &prods, &total](){
                   cout << "Sort task " << task::current() << endl;
                   /*
                    * We touch each of the tcs to ensure that this task is
                    * dependent on all products.
                    */
                   for (const auto &tc : tcs) {
                     tc.get();
                   }
                   vector<pair<unsigned, mds_ptr<Product>>> pairs;
                   pairs.reserve(prods.size());
                   for (const auto &p : prods) {
                     pairs.push_back(make_pair(total[p], p));
                   }
                   
                   sort(pairs.begin(), pairs.end(),
                        greater<decltype(pairs)::value_type>());
                   unsigned rank = 0;
                   for (const auto &p : pairs) {
                     p.second->sales_rank = rank++;
                   }
                 });
             });
  }

}; // RecentPurchases 


inline
void
Basket::purchase(const mds_ptr<RecentPurchases> &recent,
                 const shared_ptr<pause::button> &button)
{
  mds_array_ptr<BasketItem> is = items;
  isolated(report_to(make_shared<Trace>("purchase")),
           [=, self=THIS_RECORD](){
             for_each_in_tasks(is.begin(), is.end(),
                               [](const mds_ptr<BasketItem> &bi){
                                 cout << "Purchase task " << task::current() << endl;
                                 bi->purchase();
                               });
             as_task([=](){
                 cout << "Adding basket to recent: " << self << endl;
                 recent->note(self);
               });
             pause::on(button);
           });
}

class Store : public mds_record {
  using super = mds_record;

  mds_array_ptr<PerishableProduct> only_perishable() const {
    vector<mds_ptr<PerishableProduct>> v;
    v.reserve(products.size());
    for (mds_ptr<Product> p : products) {
      mds_ptr<PerishableProduct>
        pp = dynamic_pointer_cast<PerishableProduct>(p);
      //        pp = p.dynamic_pointer_cast<PerishableProduct>();
      if (pp != nullptr) {
        v.push_back(pp);
      }
    }
    return new_array<PerishableProduct>(v.begin(), v.end());
  }
public:
  DECLARE_CONST_FIELD(Store, mds_array<Department>, depts);
  DECLARE_CONST_FIELD(Store, mds_array<Product>, products);
  DECLARE_CONST_FIELD(Store, mds_array<PerishableProduct>, perishable);
  DECLARE_CONST_FIELD(Store, RecentPurchases, recent_purchases);

  RECORD_SETUP(Store, super, record_name("Store"),
               REGISTER_FIELD(depts),
               REGISTER_FIELD(products),
               REGISTER_FIELD(perishable),
               REGISTER_FIELD(recent_purchases));

  template <typename Depts, typename Prods>
  Store(const rc_token &tok, Depts&& ds, Prods&& ps, unsigned window_size)
    : super(tok),
      depts(new_array<Department>(std::forward<Depts>(ds).begin(),
                                  std::forward<Depts>(ds).end())),
      products(new_array<Product>(std::forward<Prods>(ps).begin(),
                                  std::forward<Prods>(ps).end())),
      perishable(only_perishable()),
      recent_purchases(new_record<RecentPurchases>(window_size))
  {
  }

  void purchase(const mds_ptr<Basket> &b,
                const shared_ptr<pause::button> &button = nullptr)
  {
    b->purchase(recent_purchases, button);
  }

  template <typename Fn>
  void restock(Fn&& qfn,
               const shared_ptr<pause::button> &button = nullptr)
  {
    auto update = [&button, qfn=forward<Fn>(qfn)](const auto &p){
      unsigned q = qfn(p);
      if (q > 0) {
        p->add_stock(q, button);
      }
    };
    isolated(report_to(make_shared<Trace>("Restock")),
             [&, this](){
               for_each(products.begin(), products.end(),
                        task::task_fn(update));
             });
  }

  void new_day() {
    auto update = [](const auto &p){
      p->new_day();
    };
    isolated(report_to(make_shared<Trace>("NewDay")),
             [&, this](){
               for_each(perishable.begin(), perishable.end(),
                        task::task_fn(update));
             });
  }

  void update_ranks(const shared_ptr<pause::button> &button = nullptr)
  {
    recent_purchases->update_ranks(products, button);
  }

  vector<mds_ptr<Product>> ranked_products() const {
    mds_array_ptr<Product> prods = in_read_only_snapshot([this]{ return products.read(); });
    vector<mds_ptr<Product>> v(prods.begin(), prods.end());
    sort(v.begin(), v.end(),
         [](const auto &p1, const auto &p2) {
           return p1->sales_rank < p2->sales_rank;
         });
    return v;
  }

}; // Store

class StoreBuilder {
  unordered_map<string, mds_ptr<Department>> dept_map;
  vector<mds_ptr<Department>> depts;
  vector<mds_ptr<Product>> prods;

  mds_ptr<Department> find_dept(const string &name) {
    mds_ptr<Department> d = dept_map[name];
    if (d != nullptr) {
      return d;
    }
    return create_dept(name);
  }

public:
  int window_size = 10;

  mds_ptr<Department> create_dept(const string &name) {
    unsigned i = depts.size();
    mds_ptr<Department> d = new_record<Department>(i, name);
    depts.push_back(d);
    return d;
  }

  mds_ptr<NonPerishableProduct> add_non_perishable(const string &dname,
                                                   const string &pname,
                                                   unsigned initial)
  {
    auto dept = find_dept(dname);
    auto prod = new_record<NonPerishableProduct>(prods.size(), pname,
                                                 dept, initial);
    prods.push_back(prod);
    return prod;
  }

  mds_ptr<PerishableProduct> add_perishable(const string &dname,
                                            const string &pname,
                                            unsigned life,
                                            unsigned initial)
  {
    auto dept = find_dept(dname);
    auto prod = new_record<PerishableProduct>(prods.size(), pname,
                                              dept, life, initial);
    prods.push_back(prod);
    return prod;
  }

  mds_ptr<Store> build() const {
    return new_record<Store>(depts, prods, window_size);
  }

}; // StoreBuilder

pair<mds_ptr<Store>, vector<double>> init_store();

mds_ptr<Product> choose_product(const mds_ptr<Store> &, const vector<double>);
mds_ptr<Basket> make_basket(unsigned n, const mds_ptr<Store> &, const vector<double>);

#endif // STORE_H
    
