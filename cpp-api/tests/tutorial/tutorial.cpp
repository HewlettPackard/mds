/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include "tutorial.h"

struct LineItem {
  unsigned quantity;
  float price;
  string sku;
};


const mds_ptr<mds_namespace>
Product::data_ns = mds_namespace::from_path("/MyCo/data");

const mds_ptr<mds_namespace>
Product::by_sku = (*data_ns)["SKUs"];

const mds_string
Product::first_product_key = "first_product";

mds_ptr<Product> new_product(const string &sku, float price, unsigned n_in_stock) {
  mds_ptr<Product> p;
  isolated([&]{
      if (Product::lookup(sku) != nullptr) { throw sku_exists{sku}; }
      p = make_mds<Product>(sku, price, n_in_stock);
    });
  return p;
}

void stock_in(const string &sku, unsigned n) {
  Product::lookup(sku)->n_in_stock += n;
}

void new_price(const string &sku, float p) {
  Product::lookup(sku)->price = p;
}

float price_check(const string &sku) {
  return Product::lookup(sku)->price;
}

void proces_sale(const vector<LineItem> &items) {
  isolated([&]{
      for (const LineItem &item : items) {
        auto p = Product::lookup(item.sku);
        p->check(item.quantity, item.price);
      }
      for (const LineItem &item : items) {
        auto p = Product::lookup(item.sku);
        p->sell(item.quantity, item.price);
      }
    });
    
}

mds_ptr<Report> get_report() {
  vector<mds_ptr<Product>> all;
  float total_revenue = 0;
  float stock_value = 0;

  mds_ptr<Product> p = in_read_only_snapshot(Product::get_first_product);

  for (; p != nullptr; p = p->next_product) {
    total_revenue += p->revenue;
    stock_value += p->n_in_stock * p->price;
    all.push_back(p);
  }
  sort(all.begin(), all.end(),
       [](const auto &p1, const auto &p2) { return p2->price < p1-> price; });
  vector<mds_ptr<Product>> top_ten{ all.begin(), all.size() > 10 ? all.begin()+10 : all.end() };

  return make_mds<Report>(total_revenue, stock_value, top_ten);
}

void test(const mds_array_ptr<unsigned> &a) {
  for (auto i : a) {
    i++;
  }
  auto iter = find_if(a.begin(), a.end(), [](unsigned i){ return i>10; });
  bool found = iter != a.end();
  if (found) {
    for (unsigned u : a) {
      cout << u << endl;
    }
  }
  for (auto i : a) {
    as_task([i]()mutable {
        i++;
      });
  }
  for_each(a.begin(), a.end(),
           [](auto i){
             as_task([i]()mutable {
                 i++;
               });
           });
  for_each_in_tasks(a.begin(), a.end(), [](mds_array<unsigned>::reference &i){ i++; });
  vector<double> v;
  for_each_in_tasks(v.begin(), v.end(), [](double &d){ d = 0; });
  auto tc = task::computed<unsigned>([=](unsigned old){ return a[0]; });
  cout << tc.get() << endl;
  
}
