/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

/*
 * test.cpp
 *
 *  Created on: Mar 12, 2015
 *      Author: evank
 */


#include "mds.h"
#include <iostream>
#include <string>

using namespace mds;
using namespace std;
using namespace std::chrono;


class Item;
class Prop;
class PrintableList;

namespace mds {
  template<> struct is_record_type<Item> : true_type{};
  template<> struct is_record_type<Prop> : true_type{};
  template<> struct is_record_type<PrintableList> : true_type{};
}

class Item : public mds_record {
  using super = mds_record;
public:
  DECLARE_FIELD(Item, int, count)
  DECLARE_CONST_FIELD(Item, mds_string, name)
  DECLARE_FIELD(Item, Item, next)
  DECLARE_FIELD(Item, Prop, prop)
  RECORD_SETUP(Item, super, "Item",
	       REGISTER_FIELD(count),
	       REGISTER_FIELD(name),
	       REGISTER_FIELD(next),
	       REGISTER_FIELD(prop))
  
  Item(const rc_token &tok, int c = 0, const mds_ptr<Item> n = nullptr);
};

template <typename C, typename Tr>
auto &operator<<(basic_ostream<C,Tr> &s, const mds_ptr<Item> &item) {
  if (item == nullptr) {
    return s << "null";
  } else {
    return s << "Item["<< item->count << "]";
  }
}

class Sub : public Item {
  using super = Item;
public:
  RECORD_SETUP(Sub, super, "Sub", NO_FIELDS)
  
  Sub(const rc_token &tok, int c = 0, const mds_ptr<Item> n = nullptr)
    : super(tok, c, n)
  {}

};

class Prop : public mds_record {
  using super = mds_record;
public:
  DECLARE_FIELD(Prop, Item, in_item)
  RECORD_SETUP(Prop, super, "Prop",
	       REGISTER_FIELD(in_item))
  
  Prop(const rc_token &tok, const mds_ptr<Item> item)
  : super{tok}, in_item{item}
  {
  }

  mds_ptr<Prop> set_prop(const mds_ptr<Prop> p);
};


Item::Item(const rc_token &tok, int c, const mds_ptr<Item> n)
  : super{tok}, count{c}, name{"Fred"}, next{n},
    prop{ new_record<Prop>(THIS_RECORD) }
{
}


class PrintableList : public mds_record {
  using super = mds_record;
public:
  DECLARE_FIELD(PrintableList, PrintableList, next)
  RECORD_SETUP(PrintableList, super, "PrintableList",
	       REGISTER_FIELD(next))
  
  PrintableList(const rc_token &tok, const mds_ptr<PrintableList> &n)
  : super(tok), next{n}
  {
  }

  virtual void print() const = 0;
  virtual ~PrintableList() {}

  void print_all() const {
    for (mds_ptr<const PrintableList> plist = THIS_RECORD;
	 plist != nullptr;
	 plist = plist->next.read()) // The read() is necessary to get to the ptr-to-const
      {
	plist->print();
	cout << " ";
      }
  }
};

class Singleton : public PrintableList {
  using super = PrintableList;
public:
  DECLARE_FIELD(Singleton, int, elt)
  RECORD_SETUP(Singleton, super, "Singleton",
	       REGISTER_FIELD(elt))
  
  Singleton(const rc_token &tok, int e, const mds_ptr<PrintableList> &n = nullptr)
  : super(tok, n), elt{e}
  {
  }

  void print() const override {
    cout << elt;
  }
};

class Pair : public PrintableList {
  using super = PrintableList;
public:
  DECLARE_FIELD(Pair, int, first)
  DECLARE_FIELD(Pair, int, second)
  RECORD_SETUP(Pair, super, "Pair",
	       REGISTER_FIELD(first),
	       REGISTER_FIELD(second))
  
  Pair(const rc_token &tok, int a, int b, const mds_ptr<PrintableList> &n = nullptr)
  : super(tok, n), first{a}, second{b}
  {
  }

  void print() const override {
    cout << "(" << first << ", " << second << ")";
  }
};

class WithArray : public mds_record {
  using super = mds_record;
public:
  DECLARE_FIELD(WithArray, mds_array<int>, array)
  RECORD_SETUP(WithArray, super, "WithArray",
               REGISTER_FIELD(array))
  WithArray(const rc_token &tok, size_t n=5)
  : super(tok), array{ new_array<int>(n) }
  {
  }
};


void test_mds_string() {
  mds_string a;
  mds_string b = a;
  mds_string c{"Test"};

  cout << c << endl;

  string s = "TESTING";
  int v = c.compare(s);
  cout << "Compare to " << s << ": " << v << endl;
  v = c.compare_using(mds_string::case_insensitive, s);
  cout << "Case-insensitive compare to " << s << ": " << v << endl;
  s = "Testing";
  v = c.compare(s);
  cout << "Compare to " << s << ": " << v << endl;
  s = "Test";
  v = c.compare(s);
  cout << "Compare to " << s << ": " << v << endl;
  v = c.compare(1,2,"es");
  cout << "Compare p=1,c=2 to literal 'es': " << v << endl;

  auto pos = c.find('s');
  cout << "Char 's' at pos : " << pos << endl;
  pos = c.find("es");
  cout << "'es' at pos : " << pos << endl;

  mds_string c2 = c.substr(1);
  cout << "substr(1): " << c2 << endl;

  cout << c << " == " << s << ": " << (c==s) << endl;
  cout << c << " != " << s << ": " << (c!=s) << endl;
  cout << c << " > " << s << ": " << (c>s) << endl;
  cout << c << " >= " << s << ": " << (c>=s) << endl;
  cout << c << " < " << s << ": " << (c<s) << endl;
  cout << c << " <= " << s << ": " << (c<=s) << endl;

  auto lit = "Lit";
  cout << lit << " == " << c << ": " << (lit==c) << endl;
  cout << lit << " != " << c << ": " << (lit!=c) << endl;
  cout << lit << " > " << c << ": " << (lit>c) << endl;
  cout << lit << " >= " << c << ": " << (lit>=c) << endl;
  cout << lit << " < " << c << ": " << (lit<c) << endl;
  cout << lit << " <= " << c << ": " << (lit<=c) << endl;
}

void test_namespace() {
  path p = path::of("/foo/bar", "..", string{"baz"});
//  mds_namespace ns{mds_string{"/dir"}};
  mds_ptr<mds_namespace> ns = mds_namespace::from_path("/dir");
  path name = path::of("test");
  auto nb = ns->at(name);

  auto count = ns->at("count").as_int();
  if (count) {
    cout << "Count was " << count.get() << endl;
  } else if (count.is_bound()){
    cout << "Count was bound to something else" << endl;
  } else {
    cout << "Count was unbound" << endl;
  }
  count = count+1;
  cout << "Done" << endl;

  auto title = (*ns)["title"].as_mds_string();
  if (title) {
    cout << "Title was " << title.get() << endl;
  } else if (title.is_bound()){
    cout << "Title was bound to something else" << endl;
  } else {
    cout << "Title was unbound" << endl;
  }
  title = mds_string("The count is "+ruts::to_string(count));
}


int compilation_test_1() {
  /*
   * TODO: task::computed no longer takes extra arguments, because it
   * needs to accept the old value.  Revisit this.
   *
   * Also, can no longer deduce return type.  This is a problem.
   */
  // auto tc = task::computed([](int x){ return x+1; },
  //                          5);
  auto tc = task::computed<int>([](int old){ return old+1; });

  weak_handle<task> wh = task::current();
  task t = wh.lock();
  return tc;
}


int compilation_test_2() {
  auto report = make_shared<publish_report>();
  return iso_ctxt::current().call_isolated(rerun(max_tries(3),
                                                 try_until(steady_clock::now()+1h)),
                                           resolve(try_for(5s)),
                                           iso_ctxt::mod_type::publishable,
                                           resolve(10_times),
                                           iso_ctxt::view_type::snapshot,
                                           report_to(report),
                                           [](int x){ return x+1; }, 5);
}

void hdl_segv(int sig, siginfo_t *siginfo, void *context) {
  kill(0, SIGSTOP);
}


void stop_on_seg_fault() {
  struct sigaction act;
  std::memset(&act, '\0', sizeof(act));
  act.sa_flags = SA_SIGINFO | SA_RESTART;
  act.sa_sigaction = &hdl_segv;
  if (sigaction(SIGSEGV, &act, NULL) < 0) {
    std::abort();
  }
}

void test_records(const mds_ptr<mds_namespace> &ns) {
  mds_ptr<Item> item = new_record<Item>(2);
  cout << item->count << endl;
  item->count++;
  cout << item->count << endl;
  item->count+=2;
  cout << item->count << endl;
  
  auto saved = (*ns)["saved"].as<Item>();
  if (saved) {
    cout << "Saved count was " << saved->count << endl;
  } else if (saved.is_bound()) {
    cout << "Saved was something else" << endl;
  } else {
    cout << "Saved was unbound" << endl;
    saved = new_record<Item>();
  }
  saved->count++;

  mds_ptr<Item> old_chain = ns->at("chain").as<Item>();
  int next_count = old_chain==nullptr ? 0 : old_chain->count+1;
  mds_ptr<Item> new_chain = new_record<Item>(next_count, old_chain);
  size_t n = 0;
  for (mds_ptr<Item> i = new_chain;
       i != nullptr;
       i = i->next)
    {
      cout << i->count << " ";
      n++;
    }
  cout << endl;
  ns->at("chain").as<Item>().bind(new_chain);

  mds_record::force<Singleton, Pair>();
  auto plist = (*ns)["plist"].as<PrintableList>();
  mds_ptr<PrintableList> p = plist;
  if (p != nullptr) {
    cout << "Found a printable list" << endl;
  } else {
    p = new_record<Singleton>(1);
    p = new_record<Pair>(3, 2, p);
    p = new_record<Singleton>(4, p);
    plist = p;
    //     plist = new_record<Singleton>(10);
    //       plist = new_record<Singleton>(5, plist);
  }
  plist->print_all();
  cout << endl;
   
  mds_ptr<Sub> sp = new_record<Sub>(5);
  cout << sp->count << endl;
}

void test_contexts(const mds_ptr<mds_namespace> &ns) {

  auto place = (*ns)["foo"].as<int>();
  place = 0;
  cout << "outside: " << place.get() << endl;
  detached([&]{
      place = 5;
      cout << "in_detached: " << place.get() << endl;
    });
  cout << "outside: " << place.get() << endl;
  iso_ctxt s = iso_ctxt::snapshot_from_current();
  place = 10;
  cout << "outside: " << place.get() << endl;
  s.run([&]{
      cout << "in_snapshot: " << place.get() << endl;
    });
  cout << "outside: " << place.get() << endl;
  isolated(rerun(4_times),
           [&]{
             place = 20;
             cout << "in_isolated: " << place.get() << endl;
           });
  cout << "outside: " << place.get() << endl;
}

template <typename C>
void print_collection(C&& coll) {
  string sep = "[";
  for (const auto &elt : forward<C>(coll)) {
    cout << sep << elt;
    sep = ", ";
  }
  cout << "]" << endl;
}

template <typename Fn>
auto munge_array(string msg, Fn&& fn) {
  cout << msg << ":" << endl;
  auto val = std::forward<Fn>(fn)();
  cout << "  ";
  print_collection(val);
  return val;
}

int main() {
  stop_on_seg_fault();
   // test_mds_string();
  //  test_namespace();
  mds_ptr<mds_namespace> ns = mds_namespace::from_path("/dir");
  test_records(ns);
  test_contexts(ns);


  mds_array_ptr<int> array = munge_array("Create array of ints",
                                         [&](){
                                           return new_array<int>(5);
                                         });
  cout << "Array size is " << array.size() << endl;
  munge_array("Fill with 5", [&](){
      array.fill(5);
      return array;
    });
  munge_array("array[1] = 10", [&](){
      array[1] = 10;
      return array;
    });
  munge_array("array[4] += array[1]", [&](){
      array[4] += array[1];
      return array;
    });
  munge_array("array[2]++", [&](){
      array[2]++;
      return array;
    });
  munge_array("convert to vector<long>", [&](){
      vector<long> v(array.begin(), array.end());
      return v;
    });
  mds_array_ptr<Item> a2 = munge_array("Create array of records",
                                         [&](){
                                           return new_array<Item>(3);
                                         });
  cout << "Array size is " << a2.size() << endl;
  munge_array("Fill with same new record", [&](){
      a2.fill(new_record<Item>(1));
      return a2;
    });
  munge_array("change the count at one index", [&](){
      a2[1]->count = 2;
      return a2;
    });

  mds_ptr<WithArray> r = new_record<WithArray>(4);
  munge_array("Created record with array",
              [&](){
                return r->array.read();
              });
  
}






