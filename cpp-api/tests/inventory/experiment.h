/*
 *
 *  Managed Data Structures
 *  Copyright Â© 2016 Hewlett Packard Enterprise Development Company LP.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the 
 *  Application containing code generated by the Library and added to the 
 *  Application during this compilation process under terms of your choice, 
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef INVENTORY_EXPERIMENT_H
#define INVENTORY_EXPERIMENT_H


#include "mds_thread.h"
#include "ruts/runtime_array.h"
#include "util.h"
#include <atomic>
#include <chrono>
#include <memory>
#include <random>
#include <thread>
#include <vector>

using namespace std;
using namespace mds;
using namespace std::chrono;
using namespace ruts;

class Experiment : public enable_shared_from_this<Experiment> {
public:
  class Run;
  friend class Run;
private:
  function<bool(const Run &)> stop_test = nullptr;
  milliseconds delay_mean;
  milliseconds delay_sd;
  vector<function<void()>> actions;
  vector<double> weights;

  void sleep_until_next() const {
    normal_distribution<> nd(delay_mean.count(), delay_sd.count());
    duration<double,milli> delay{nd(tl_rand())};;
    this_thread::sleep_for(delay);
  }
  
public:
  auto add_action(double weight, const function<void()> &fn) {
    actions.push_back(fn);
    weights.push_back(weight);
    return shared_from_this();
  }
  
  auto stop_when(const function<bool(const Run &)> &test) {
    if (stop_test != nullptr) {
      auto old_test = stop_test;
      stop_test = [=](const Run &r) {
        return old_test(r) || test(r);
      };
    } else {
      stop_test = test;
    }
    return shared_from_this();
  }

  template <typename C, typename D>
  auto stop_after(const time_point<C,D> &t) {
    return stop_when([t](const Run &r) {
        return system_clock::now() > t;
      });
  }
  
  template <typename R, typename P>
  auto stop_after(const duration<R,P> &d) {
    return stop_when([d](const Run &r) {
        return system_clock::now() > r._start_time+d;
      });
  }

  auto stop_after_n(size_t n) {
    return stop_when([n](const Run &r) {
        return r._n_performed >= n;
      });
  }

  auto set_delay(milliseconds mean, milliseconds sd) {
    delay_mean = mean;
    delay_sd = sd;
    return shared_from_this();
  }

  shared_ptr<Run> start(size_t n_threads) {
    return make_shared<Run>(shared_from_this(), n_threads);
  }
  
  class Run {
    friend class Experiment;
    const shared_ptr<const Experiment> _experiment;
    runtime_array<mds_thread> _threads;
    atomic<bool> _running{true};
    atomic<size_t> _n_performed{0};
    const time_point<system_clock> _start_time = system_clock::now();
  public:
    Run(const shared_ptr<const Experiment> &e, size_t n_threads)
      : _experiment{e},
        _threads{n_threads}
    {
      auto rfn = [this](){
        discrete_distribution<size_t> d(_experiment->weights.begin(),
                                        _experiment->weights.end());
        while (keep_running()) {
          size_t i = d(tl_rand());
          const auto &action = _experiment->actions[i];
          action();
          _n_performed++;
          _experiment->sleep_until_next();
        }
      };

      for (size_t i=0; i<n_threads; i++) {
        _threads[i] = mds_thread{rfn};
      }
      for (mds_thread &t : _threads) {
        t.join();
      }
    }

    bool keep_running() {
      if (!_running) {
        return false;
      }
      if (_experiment->stop_test == nullptr) {
        return true;
      }
      bool val = !_experiment->stop_test(*this);
      if (!val) {
        _running = false;
      }
      return val;
    }
  };
};

#endif
